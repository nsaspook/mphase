Disassembly Listing for mphase
Generated From:
/fred/mphase_v80/mphase.X/dist/default/production/mphase.X.production.elf
Nov 18, 2018 8:58:13 AM

---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/xxtofl.c  ------------------------------------------
1:             // since we use tests on the size of operands, suppress the warnings that
2:             // would be generated
3:             #pragma warning disable 757
4:             
5:             /* Convert an integer to a 32-bit floating point value.
6:              * sign : is val actually a signed value
7:              * val  : the incoming integer (signed or unsigned) for conversion, cast to a signed long
8:              */ 
9:             double
10:            __xxtofl(unsigned char sign, signed long val)
4DBA  6E1D     MOVWF divisor, ACCESS
11:            {
12:            	unsigned char exp;
13:            	unsigned long arg;
14:            
15:            	if(sign && val < 0) {
4DBC  501D     MOVF divisor, W, ACCESS
4DBE  A4D8     BTFSS STATUS, 2, ACCESS
4DC0  AE18     BTFSS 0x18, 7, ACCESS
4DC2  D01A     BRA 0x4DF8
16:            		arg = -val;
4DC4  C015     MOVFF dividend, multiplicand
4DC6  F019     NOP
4DC8  C016     MOVFF Message, s
4DCA  F01A     NOP
4DCC  C017     MOVFF _r, c
4DCE  F01B     NOP
4DD0  C018     MOVFF 0x18, c
4DD2  F01C     NOP
4DD4  1E19     COMF multiplicand, F, ACCESS
4DD6  1E1A     COMF s, F, ACCESS
4DD8  1E1B     COMF c, F, ACCESS
4DDA  1E1C     COMF c, F, ACCESS
4DDC  2A19     INCF multiplicand, F, ACCESS
4DDE  0E00     MOVLW 0x0
4DE0  221A     ADDWFC s, F, ACCESS
4DE2  221B     ADDWFC c, F, ACCESS
4DE4  221C     ADDWFC c, F, ACCESS
4DE6  C019     MOVFF multiplicand, i
4DE8  F01F     NOP
4DEA  C01A     MOVFF s, r
4DEC  F020     NOP
4DEE  C01B     MOVFF c, s
4DF0  F021     NOP
4DF2  C01C     MOVFF c, s
4DF4  F022     NOP
17:            	}
4DF6  D008     BRA 0x4E08
18:            	else {
19:            		arg = val;
4DF8  C015     MOVFF dividend, i
4DFA  F01F     NOP
4DFC  C016     MOVFF Message, r
4DFE  F020     NOP
4E00  C017     MOVFF _r, s
4E02  F021     NOP
4E04  C018     MOVFF 0x18, s
4E06  F022     NOP
20:            	}
21:            	if(val == 0)
4E08  5015     MOVF dividend, W, ACCESS
4E0A  1016     IORWF Message, W, ACCESS
4E0C  1017     IORWF _r, W, ACCESS
4E0E  1018     IORWF 0x18, W, ACCESS
4E10  A4D8     BTFSS STATUS, 2, ACCESS
4E12  D009     BRA 0x4E26
22:            		return 0.0;
4E14  0E00     MOVLW 0x0
4E16  6E15     MOVWF dividend, ACCESS
4E18  0E00     MOVLW 0x0
4E1A  6E16     MOVWF Message, ACCESS
4E1C  0E00     MOVLW 0x0
4E1E  6E17     MOVWF _r, ACCESS
4E20  0E00     MOVLW 0x0
4E22  6E18     MOVWF 0x18, ACCESS
4E24  0012     RETURN 0
23:            	exp = (127 + 23);
4E26  0E96     MOVLW 0x96
4E28  6E1E     MOVWF l, ACCESS
24:            	while(arg & ~0x1FFFFFFUL) {
4E2A  D006     BRA 0x4E38
25:            		++exp;
4E2C  2A1E     INCF l, F, ACCESS
26:            		arg >>= 1;
4E2E  90D8     BCF STATUS, 0, ACCESS
4E30  3222     RRCF s, F, ACCESS
4E32  3221     RRCF s, F, ACCESS
4E34  3220     RRCF r, F, ACCESS
4E36  321F     RRCF i, F, ACCESS
27:            	}
4E38  0E00     MOVLW 0x0
4E3A  141F     ANDWF i, W, ACCESS
4E3C  6E19     MOVWF multiplicand, ACCESS
4E3E  0E00     MOVLW 0x0
4E40  1420     ANDWF r, W, ACCESS
4E42  6E1A     MOVWF s, ACCESS
4E44  0E00     MOVLW 0x0
4E46  1421     ANDWF s, W, ACCESS
4E48  6E1B     MOVWF c, ACCESS
4E4A  0EFE     MOVLW 0xFE
4E4C  1422     ANDWF s, W, ACCESS
4E4E  6E1C     MOVWF c, ACCESS
4E50  5019     MOVF multiplicand, W, ACCESS
4E52  101A     IORWF s, W, ACCESS
4E54  101B     IORWF c, W, ACCESS
4E56  101C     IORWF c, W, ACCESS
4E58  B4D8     BTFSC STATUS, 2, ACCESS
4E5A  D00D     BRA 0x4E76
4E5C  D7E7     BRA 0x4E2C
28:            	while(arg & ~0xFFFFFFUL) {
29:            		++exp;
4E5E  2A1E     INCF l, F, ACCESS
30:            		++arg;
4E60  0E01     MOVLW 0x1
4E62  261F     ADDWF i, F, ACCESS
4E64  0E00     MOVLW 0x0
4E66  2220     ADDWFC r, F, ACCESS
4E68  2221     ADDWFC s, F, ACCESS
4E6A  2222     ADDWFC s, F, ACCESS
31:            		arg >>= 1;
4E6C  90D8     BCF STATUS, 0, ACCESS
4E6E  3222     RRCF s, F, ACCESS
4E70  3221     RRCF s, F, ACCESS
4E72  3220     RRCF r, F, ACCESS
4E74  321F     RRCF i, F, ACCESS
32:            	}
4E76  0E00     MOVLW 0x0
4E78  141F     ANDWF i, W, ACCESS
4E7A  6E19     MOVWF multiplicand, ACCESS
4E7C  0E00     MOVLW 0x0
4E7E  1420     ANDWF r, W, ACCESS
4E80  6E1A     MOVWF s, ACCESS
4E82  0E00     MOVLW 0x0
4E84  1421     ANDWF s, W, ACCESS
4E86  6E1B     MOVWF c, ACCESS
4E88  0EFF     MOVLW 0xFF
4E8A  1422     ANDWF s, W, ACCESS
4E8C  6E1C     MOVWF c, ACCESS
4E8E  5019     MOVF multiplicand, W, ACCESS
4E90  101A     IORWF s, W, ACCESS
4E92  101B     IORWF c, W, ACCESS
4E94  101C     IORWF c, W, ACCESS
4E96  B4D8     BTFSC STATUS, 2, ACCESS
4E98  D007     BRA 0x4EA8
4E9A  D7E1     BRA 0x4E5E
33:            	while(!(arg & 0x800000UL) && exp > 1) {
34:            		--exp;
4E9C  061E     DECF l, F, ACCESS
35:            		arg <<= 1;
4E9E  90D8     BCF STATUS, 0, ACCESS
4EA0  361F     RLCF i, F, ACCESS
4EA2  3620     RLCF r, F, ACCESS
4EA4  3621     RLCF s, F, ACCESS
4EA6  3622     RLCF s, F, ACCESS
36:            	}
4EA8  BE21     BTFSC s, 7, ACCESS
4EAA  D003     BRA 0x4EB2
4EAC  0E02     MOVLW 0x2
4EAE  601E     CPFSLT l, ACCESS
4EB0  D7F5     BRA 0x4E9C
37:            	if(!(exp & 1))
4EB2  A01E     BTFSS l, 0, ACCESS
38:            		arg &= ~0x800000UL;
4EB4  9E21     BCF s, 7, ACCESS
39:            	exp >>= 1;
4EB6  90D8     BCF STATUS, 0, ACCESS
4EB8  321E     RRCF l, F, ACCESS
40:            	arg |= (unsigned long)exp << 24;
4EBA  C01E     MOVFF l, multiplicand
4EBC  F019     NOP
4EBE  6A1A     CLRF s, ACCESS
4EC0  6A1B     CLRF c, ACCESS
4EC2  6A1C     CLRF c, ACCESS
4EC4  C019     MOVFF multiplicand, c
4EC6  F01C     NOP
4EC8  6A1B     CLRF c, ACCESS
4ECA  6A1A     CLRF s, ACCESS
4ECC  6A19     CLRF multiplicand, ACCESS
4ECE  5019     MOVF multiplicand, W, ACCESS
4ED0  121F     IORWF i, F, ACCESS
4ED2  501A     MOVF s, W, ACCESS
4ED4  1220     IORWF r, F, ACCESS
4ED6  501B     MOVF c, W, ACCESS
4ED8  1221     IORWF s, F, ACCESS
4EDA  501C     MOVF c, W, ACCESS
4EDC  1222     IORWF s, F, ACCESS
41:            	if(sign && val < 0)
4EDE  501D     MOVF divisor, W, ACCESS
4EE0  A4D8     BTFSS STATUS, 2, ACCESS
4EE2  AE18     BTFSS 0x18, 7, ACCESS
4EE4  D001     BRA 0x4EE8
42:            		arg |= 0x80000000UL;
4EE6  8E22     BSF s, 7, ACCESS
43:            	return *(double *)&arg;
4EE8  C01F     MOVFF i, dividend
4EEA  F015     NOP
4EEC  C020     MOVFF r, Message
4EEE  F016     NOP
4EF0  C021     MOVFF s, _r
4EF2  F017     NOP
4EF4  C022     MOVFF s, 0x18
4EF6  F018     NOP
4EF8  0012     RETURN 0
44:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/truncf.c  ------------------------------------------
1:             #include "libm.h"
2:             
3:             float truncf(float x)
4:             {
5:             	union {float f; uint32_t i;} u = {x};
5038  C116     MOVFF F520, quotient
503A  F025     NOP
503C  C117     MOVFF 0x117, sign
503E  F026     NOP
5040  C118     MOVFF 0x118, quotient
5042  F027     NOP
5044  C119     MOVFF 0x119, 0x28
5046  F028     NOP
5048  C015     MOVFF dividend, quotient
504A  F025     NOP
504C  C016     MOVFF Message, sign
504E  F026     NOP
5050  C017     MOVFF _r, quotient
5052  F027     NOP
5054  C018     MOVFF 0x18, 0x28
5056  F028     NOP
6:             	int e = (int)(u.i >> 23 & 0xff) - 0x7f + 9;
5058  0E8A     MOVLW 0x8A
505A  6E19     MOVWF multiplicand, ACCESS
505C  0EFF     MOVLW 0xFF
505E  6E1A     MOVWF s, ACCESS
5060  C025     MOVFF quotient, c
5062  F01B     NOP
5064  C026     MOVFF sign, c
5066  F01C     NOP
5068  C027     MOVFF quotient, divisor
506A  F01D     NOP
506C  C028     MOVFF 0x28, l
506E  F01E     NOP
5070  0E18     MOVLW 0x18
5072  D005     BRA 0x507E
5074  90D8     BCF STATUS, 0, ACCESS
5076  321E     RRCF l, F, ACCESS
5078  321D     RRCF divisor, F, ACCESS
507A  321C     RRCF c, F, ACCESS
507C  321B     RRCF c, F, ACCESS
507E  2EE8     DECFSZ WREG, F, ACCESS
5080  D7F9     BRA 0x5074
5082  501B     MOVF c, W, ACCESS
5084  2419     ADDWF multiplicand, W, ACCESS
5086  6E23     MOVWF sep, ACCESS
5088  0E00     MOVLW 0x0
508A  201A     ADDWFC s, W, ACCESS
508C  6E24     MOVWF n, ACCESS
7:             	uint32_t m;
8:             
9:             	if (e >= 23 + 9)
508E  BE24     BTFSC n, 7, ACCESS
5090  D00F     BRA 0x50B0
5092  5024     MOVF n, W, ACCESS
5094  E104     BNZ 0x509E
5096  0E20     MOVLW 0x20
5098  5C23     SUBWF sep, W, ACCESS
509A  A0D8     BTFSS STATUS, 0, ACCESS
509C  D009     BRA 0x50B0
10:            		return x;
509E  C015     MOVFF dividend, dividend
50A0  F015     NOP
50A2  C016     MOVFF Message, Message
50A4  F016     NOP
50A6  C017     MOVFF _r, _r
50A8  F017     NOP
50AA  C018     MOVFF 0x18, 0x18
50AC  F018     NOP
50AE  0012     RETURN 0
11:            	if (e < 9)
50B0  BE24     BTFSC n, 7, ACCESS
50B2  D006     BRA 0x50C0
50B4  5024     MOVF n, W, ACCESS
50B6  E108     BNZ 0x50C8
50B8  0E09     MOVLW 0x9
50BA  5C23     SUBWF sep, W, ACCESS
50BC  B0D8     BTFSC STATUS, 0, ACCESS
50BE  D004     BRA 0x50C8
12:            		e = 1;
50C0  0E00     MOVLW 0x0
50C2  6E24     MOVWF n, ACCESS
50C4  0E01     MOVLW 0x1
50C6  6E23     MOVWF sep, ACCESS
13:            	m = UINT32_C(-1) >> e;
50C8  0EFF     MOVLW 0xFF
50CA  6E19     MOVWF multiplicand, ACCESS
50CC  0EFF     MOVLW 0xFF
50CE  6E1A     MOVWF s, ACCESS
50D0  0EFF     MOVLW 0xFF
50D2  6E1B     MOVWF c, ACCESS
50D4  0EFF     MOVLW 0xFF
50D6  6E1C     MOVWF c, ACCESS
50D8  5023     MOVF sep, W, ACCESS
50DA  2AE8     INCF WREG, F, ACCESS
50DC  D005     BRA 0x50E8
50DE  90D8     BCF STATUS, 0, ACCESS
50E0  321C     RRCF c, F, ACCESS
50E2  321B     RRCF c, F, ACCESS
50E4  321A     RRCF s, F, ACCESS
50E6  3219     RRCF multiplicand, F, ACCESS
50E8  2EE8     DECFSZ WREG, F, ACCESS
50EA  D7F9     BRA 0x50DE
50EC  C019     MOVFF multiplicand, i
50EE  F01F     NOP
50F0  C01A     MOVFF s, r
50F2  F020     NOP
50F4  C01B     MOVFF c, s
50F6  F021     NOP
50F8  C01C     MOVFF c, s
50FA  F022     NOP
14:            	if ((u.i & m) == 0)
50FC  501F     MOVF i, W, ACCESS
50FE  1425     ANDWF quotient, W, ACCESS
5100  6E19     MOVWF multiplicand, ACCESS
5102  5020     MOVF r, W, ACCESS
5104  1426     ANDWF sign, W, ACCESS
5106  6E1A     MOVWF s, ACCESS
5108  5021     MOVF s, W, ACCESS
510A  1427     ANDWF quotient, W, ACCESS
510C  6E1B     MOVWF c, ACCESS
510E  5022     MOVF s, W, ACCESS
5110  1428     ANDWF 0x28, W, ACCESS
5112  6E1C     MOVWF c, ACCESS
5114  5019     MOVF multiplicand, W, ACCESS
5116  101A     IORWF s, W, ACCESS
5118  101B     IORWF c, W, ACCESS
511A  101C     IORWF c, W, ACCESS
511C  A4D8     BTFSS STATUS, 2, ACCESS
511E  D009     BRA 0x5132
15:            		return x;
5120  C015     MOVFF dividend, dividend
5122  F015     NOP
5124  C016     MOVFF Message, Message
5126  F016     NOP
5128  C017     MOVFF _r, _r
512A  F017     NOP
512C  C018     MOVFF 0x18, 0x18
512E  F018     NOP
5130  0012     RETURN 0
16:            	FORCE_EVAL(x + 0x1p120f);
17:            	u.i &= ~m;
5132  1C1F     COMF i, W, ACCESS
5134  6E19     MOVWF multiplicand, ACCESS
5136  1C20     COMF r, W, ACCESS
5138  6E1A     MOVWF s, ACCESS
513A  1C21     COMF s, W, ACCESS
513C  6E1B     MOVWF c, ACCESS
513E  1C22     COMF s, W, ACCESS
5140  6E1C     MOVWF c, ACCESS
5142  5019     MOVF multiplicand, W, ACCESS
5144  1625     ANDWF quotient, F, ACCESS
5146  501A     MOVF s, W, ACCESS
5148  1626     ANDWF sign, F, ACCESS
514A  501B     MOVF c, W, ACCESS
514C  1627     ANDWF quotient, F, ACCESS
514E  501C     MOVF c, W, ACCESS
5150  1628     ANDWF 0x28, F, ACCESS
18:            	return u.f;
5152  C025     MOVFF quotient, dividend
5154  F015     NOP
5156  C026     MOVFF sign, Message
5158  F016     NOP
515A  C027     MOVFF quotient, _r
515C  F017     NOP
515E  C028     MOVFF 0x28, 0x18
5160  F018     NOP
5162  0012     RETURN 0
19:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/toupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int toupper(int c)
5:             {
6:             	if (islower(c)) return c & 0x5f;
622C  0E9F     MOVLW 0x9F
622E  6E1D     MOVWF divisor, ACCESS
6230  0EFF     MOVLW 0xFF
6232  6E1E     MOVWF l, ACCESS
6234  C01B     MOVFF c, i
6236  F01F     NOP
6238  C01C     MOVFF c, r
623A  F020     NOP
623C  501D     MOVF divisor, W, ACCESS
623E  261F     ADDWF i, F, ACCESS
6240  501E     MOVF l, W, ACCESS
6242  2220     ADDWFC r, F, ACCESS
6244  5020     MOVF r, W, ACCESS
6246  E106     BNZ 0x6254
6248  0E1A     MOVLW 0x1A
624A  5C1F     SUBWF i, W, ACCESS
624C  B0D8     BTFSC STATUS, 0, ACCESS
624E  D002     BRA 0x6254
6250  0E01     MOVLW 0x1
6252  D001     BRA 0x6256
6254  0E00     MOVLW 0x0
6256  6E21     MOVWF s, ACCESS
6258  6A22     CLRF s, ACCESS
625A  5021     MOVF s, W, ACCESS
625C  1022     IORWF s, W, ACCESS
625E  B4D8     BTFSC STATUS, 2, ACCESS
6260  D005     BRA 0x626C
6262  0E5F     MOVLW 0x5F
6264  141B     ANDWF c, W, ACCESS
6266  6E1B     MOVWF c, ACCESS
6268  6A1C     CLRF c, ACCESS
626A  0012     RETURN 0
7:             	return c;
626C  C01B     MOVFF c, c
626E  F01B     NOP
6270  C01C     MOVFF c, c
6272  F01C     NOP
8:             }
6274  0012     RETURN 0
9:             
10:            int __toupper_l(int c, locale_t l)
11:            {
12:            	return toupper(c);
13:            }
14:            
15:            weak_alias(__toupper_l, toupper_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strtok.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             char *strtok(char *restrict s, const char *restrict sep)
4:             {
5:             	static char *p;
6:             	if (!s && !(s = p)) return NULL;
5930  5021     MOVF s, W, ACCESS
5932  1022     IORWF s, W, ACCESS
5934  A4D8     BTFSS STATUS, 2, ACCESS
5936  D00D     BRA 0x5952
5938  C11E     MOVFF p, s
593A  F021     NOP
593C  C11F     MOVFF 0x11F, s
593E  F022     NOP
5940  5021     MOVF s, W, ACCESS
5942  1022     IORWF s, W, ACCESS
5944  A4D8     BTFSS STATUS, 2, ACCESS
5946  D005     BRA 0x5952
5948  0E00     MOVLW 0x0
594A  6E21     MOVWF s, ACCESS
594C  0E00     MOVLW 0x0
594E  6E22     MOVWF s, ACCESS
5950  0012     RETURN 0
7:             	s += strspn(s, sep);
5952  C021     MOVFF s, s
5954  F01A     NOP
5956  C022     MOVFF s, c
5958  F01B     NOP
595A  C023     MOVFF sep, c
595C  F01C     NOP
595E  C024     MOVFF n, divisor
5960  F01D     NOP
5962  EC2C     CALL 0x6058, 0
5964  F030     NOP
5966  501A     MOVF s, W, ACCESS
5968  2621     ADDWF s, F, ACCESS
596A  501B     MOVF c, W, ACCESS
596C  2222     ADDWFC s, F, ACCESS
8:             	if (!*s) return p = 0;
596E  C021     MOVFF s, FSR2
5970  FFD9     NOP
5972  C022     MOVFF s, FSR2H
5974  FFDA     NOP
5976  50DF     MOVF INDF2, W, ACCESS
5978  A4D8     BTFSS STATUS, 2, ACCESS
597A  D00A     BRA 0x5990
597C  0E00     MOVLW 0x0
597E  0101     MOVLB 0x1
5980  6F1E     MOVWF l, BANKED
5982  0E00     MOVLW 0x0
5984  6F1F     MOVWF i, BANKED
5986  C11E     MOVFF p, s
5988  F021     NOP
598A  C11F     MOVFF 0x11F, s
598C  F022     NOP
598E  0012     RETURN 0
9:             	p = s + strcspn(s, sep);
5990  C021     MOVFF s, s
5992  F01A     NOP
5994  C022     MOVFF s, c
5996  F01B     NOP
5998  C023     MOVFF sep, c
599A  F01C     NOP
599C  C024     MOVFF n, divisor
599E  F01D     NOP
59A0  EC54     CALL 0x60A8, 0
59A2  F030     NOP
59A4  501A     MOVF s, W, ACCESS
59A6  2421     ADDWF s, W, ACCESS
59A8  0101     MOVLB 0x1
59AA  6F1E     MOVWF l, BANKED
59AC  501B     MOVF c, W, ACCESS
59AE  2022     ADDWFC s, W, ACCESS
59B0  6F1F     MOVWF i, BANKED
10:            	if (*p) *p++ = 0;
59B2  C11E     MOVFF p, FSR2
59B4  FFD9     NOP
59B6  C11F     MOVFF 0x11F, FSR2H
59B8  FFDA     NOP
59BA  50DF     MOVF INDF2, W, ACCESS
59BC  B4D8     BTFSC STATUS, 2, ACCESS
59BE  D009     BRA 0x59D2
59C0  C11E     MOVFF p, FSR2
59C2  FFD9     NOP
59C4  C11F     MOVFF 0x11F, FSR2H
59C6  FFDA     NOP
59C8  0E00     MOVLW 0x0
59CA  6EDF     MOVWF INDF2, ACCESS
59CC  4B1E     INFSNZ l, F, BANKED
59CE  2B1F     INCF i, F, BANKED
59D0  D004     BRA 0x59DA
11:            	else p = 0;
59D2  0E00     MOVLW 0x0
59D4  6F1E     MOVWF l, BANKED
59D6  0E00     MOVLW 0x0
59D8  6F1F     MOVWF i, BANKED
12:            	return s;
59DA  C021     MOVFF s, s
59DC  F021     NOP
59DE  C022     MOVFF s, s
59E0  F022     NOP
59E2  0012     RETURN 0
13:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strtof.c  ------------------------------------------
1:             #include	<ctype.h>
2:             #include	<float.h>
3:             #include	<math.h>
4:             #include	<stdlib.h>
5:             #include	<stdint.h>
6:             
7:             /*
8:              * $Header$
9:              */
10:            
11:            #define	NDIG	FLT_DIG+3 	/* Number of digits (ANSI 5.2.4.2.2) */
12:            
13:            #if		defined(_MPC_) && !defined(__DSPICC__) 		/* If Microchip PIC */
14:            // undefining this macro can lead to more accurate results, but at the cost of much
15:            // increased code size.
16:            #define	SMALLCODE
17:            #endif
18:            
19:            
20:            #ifndef	SMALLCODE
21:            /*
22:             *	Tables of powers of 10
23:             */
24:            static const float	_powers_[] =
25:            {
26:            	1e0,
27:            	1e1,
28:            	1e2,
29:            	1e3,
30:            	1e4,
31:            	1e5,
32:            	1e6,
33:            	1e7,
34:            	1e8,
35:            	1e9,
36:            	1e10,
37:            #if	FLT_MAX_10_EXP >= 20
38:            	1e20,
39:            	1e30,
40:            #endif
41:            #if	FLT_MAX_10_EXP >= 40
42:            	1e40,
43:            	1e50,
44:            	1e60,
45:            	1e70,
46:            	1e80,
47:            	1e90,
48:            #endif
49:            #if	FLT_MAX_10_EXP >= 100
50:            	1e100,
51:            	1e200,
52:            	1e300,
53:            #endif
54:            };
55:            
56:            static const float	_npowers_[] =
57:            {
58:            	1e-0,
59:            	1e-1,
60:            	1e-2,
61:            	1e-3,
62:            	1e-4,
63:            	1e-5,
64:            	1e-6,
65:            	1e-7,
66:            	1e-8,
67:            	1e-9,
68:            	1e-10,
69:            #if	FLT_MIN_10_EXP <= -20
70:            	1e-20,
71:            	1e-30,
72:            #endif
73:            #if	FLT_MIN_10_EXP <= -40
74:            	1e-40,
75:            	1e-50,
76:            	1e-60,
77:            	1e-70,
78:            	1e-80,
79:            	1e-90,
80:            #endif
81:            #if	FLT_MIN_10_EXP <= -100
82:            	1e-100,
83:            	1e-200,
84:            	1e-300,
85:            #endif
86:            };
87:            #endif
88:            
89:            #define CSTRLEN(s)	((sizeof (s) / sizeof (s)[0])-1)
90:            
91:            /*
92:             *	String to float
93:             */
94:            float
95:            strtof(const char * __restrict s, char ** __restrict res)
96:            {
97:            	char	flags, i;
98:            	
99:            /*	values in flags :
100:            */	
101:           
102:           #define	ISNEG	1	/* Number is negative */
103:           #define	DIGSEEN	2	/* We saw at least one digit */
104:           #define	EXPNEG	8	/* Exponent is negative */
105:           #define	DOTSEEN	16	/* We have seen a dot */
106:           
107:           	unsigned char digit;
108:           	signed int	expon;
109:           	signed int	eexp;
110:           	union {			/* A union to hold the integer	*/
111:           		float	_l;	/* component and then the resultant */
112:           		uint32_t	_v;
113:           	}	_u;
114:           #define	v	_u._v
115:           #define	l	_u._l
116:           
117:           	if(res)
26AE  0100     MOVLB 0x0
26B0  518C     MOVF res, W, BANKED
26B2  118D     IORWF 0x8D, W, BANKED
26B4  B4D8     BTFSC STATUS, 2, ACCESS
26B6  D00B     BRA 0x26CE
118:           		*res = (char*) s;
26B8  C08C     MOVFF res, FSR2
26BA  FFD9     NOP
26BC  C08D     MOVFF 0x8D, FSR2H
26BE  FFDA     NOP
26C0  C08A     MOVFF s, POSTINC2
26C2  FFDE     NOP
26C4  C08B     MOVFF ap, POSTDEC2
26C6  FFDD     NOP
119:           	while(isspace(eexp = *s))
26C8  D002     BRA 0x26CE
26CE  0E01     MOVLW 0x1
26D0  6FA4     MOVWF llu, BANKED
26D2  C08A     MOVFF s, FSR2
26D4  FFD9     NOP
26D6  C08B     MOVFF ap, FSR2H
26D8  FFDA     NOP
26DA  0E20     MOVLW 0x20
26DC  18DE     XORWF POSTINC2, W, ACCESS
26DE  A4D8     BTFSS STATUS, 2, ACCESS
26E0  D002     BRA 0x26E6
26E2  0E01     MOVLW 0x1
26E4  D001     BRA 0x26E8
26E6  0E00     MOVLW 0x0
26E8  6FA9     MOVWF eexp, BANKED
26EA  6BAA     CLRF 0xAA, BANKED
26EC  51A9     MOVF eexp, W, BANKED
26EE  11AA     IORWF 0xAA, W, BANKED
26F0  A4D8     BTFSS STATUS, 2, ACCESS
26F2  D01D     BRA 0x272E
26F4  0EF7     MOVLW 0xF7
26F6  6F8E     MOVWF 0x8E, BANKED
26F8  0EFF     MOVLW 0xFF
26FA  6F8F     MOVWF 0x8F, BANKED
26FC  C08A     MOVFF s, FSR2
26FE  FFD9     NOP
2700  C08B     MOVFF ap, FSR2H
2702  FFDA     NOP
2704  50DF     MOVF INDF2, W, ACCESS
2706  6F90     MOVWF 0x90, BANKED
2708  5190     MOVF 0x90, W, BANKED
270A  6FA9     MOVWF eexp, BANKED
270C  6BAA     CLRF 0xAA, BANKED
270E  C0A9     MOVFF eexp, cp
2710  F091     NOP
2712  C0AA     MOVFF 0xAA, 0x92
2714  F092     NOP
2716  518E     MOVF 0x8E, W, BANKED
2718  2791     ADDWF cp, F, BANKED
271A  518F     MOVF 0x8F, W, BANKED
271C  2392     ADDWFC 0x92, F, BANKED
271E  5192     MOVF 0x92, W, BANKED
2720  E104     BNZ 0x272A
2722  0E05     MOVLW 0x5
2724  5D91     SUBWF cp, W, BANKED
2726  A0D8     BTFSS STATUS, 0, ACCESS
2728  D002     BRA 0x272E
272A  0E00     MOVLW 0x0
272C  6FA4     MOVWF llu, BANKED
272E  C0A4     MOVFF llu, 0x94
2730  F094     NOP
2732  6B95     CLRF 0x95, BANKED
2734  0100     MOVLB 0x0
2736  5194     MOVF 0x94, W, BANKED
2738  1195     IORWF 0x95, W, BANKED
273A  A4D8     BTFSS STATUS, 2, ACCESS
273C  D7C6     BRA 0x26CA
120:           		s++;
26CA  4B8A     INFSNZ s, F, BANKED
26CC  2B8B     INCF ap, F, BANKED
121:           	flags = 0;			/* Reset flags */
273E  0E00     MOVLW 0x0
2740  6FA6     MOVWF flags, BANKED
122:           	if(eexp == '-') {	/* Check for sign */
2742  0E2D     MOVLW 0x2D
2744  19A9     XORWF eexp, W, BANKED
2746  11AA     IORWF 0xAA, W, BANKED
2748  A4D8     BTFSS STATUS, 2, ACCESS
274A  D003     BRA 0x2752
123:           		flags = ISNEG;
274C  0E01     MOVLW 0x1
274E  6FA6     MOVWF flags, BANKED
124:           		s++;
2750  D005     BRA 0x275C
125:           	} else if(eexp == '+')
2752  0E2B     MOVLW 0x2B
2754  19A9     XORWF eexp, W, BANKED
2756  11AA     IORWF 0xAA, W, BANKED
2758  A4D8     BTFSS STATUS, 2, ACCESS
275A  D002     BRA 0x2760
126:           		s++;
275C  4B8A     INFSNZ s, F, BANKED
275E  2B8B     INCF ap, F, BANKED
127:           	
128:           	// check for infinity
129:           	for (i = 0; s[i] != '\0' && (s[i] == "infinity"[i] || s[i] == "INFINITY"[i]); i++) {
2760  0E00     MOVLW 0x0
2762  6FAF     MOVWF i, BANKED
2764  D001     BRA 0x2768
130:           		continue;
131:           	}
2766  2BAF     INCF i, F, BANKED
2768  51AF     MOVF i, W, BANKED
276A  0D01     MULLW 0x1
276C  50F3     MOVF PROD, W, ACCESS
276E  258A     ADDWF s, W, BANKED
2770  6ED9     MOVWF FSR2, ACCESS
2772  50F4     MOVF PRODH, W, ACCESS
2774  218B     ADDWFC ap, W, BANKED
2776  6EDA     MOVWF FSR2H, ACCESS
2778  50DF     MOVF INDF2, W, ACCESS
277A  B4D8     BTFSC STATUS, 2, ACCESS
277C  D02E     BRA 0x27DA
277E  51AF     MOVF i, W, BANKED
2780  0D01     MULLW 0x1
2782  50F3     MOVF PROD, W, ACCESS
2784  258A     ADDWF s, W, BANKED
2786  6ED9     MOVWF FSR2, ACCESS
2788  50F4     MOVF PRODH, W, ACCESS
278A  218B     ADDWFC ap, W, BANKED
278C  6EDA     MOVWF FSR2H, ACCESS
278E  50DF     MOVF INDF2, W, ACCESS
2790  6F8E     MOVWF 0x8E, BANKED
2792  51AF     MOVF i, W, BANKED
2794  0D01     MULLW 0x1
2796  0E3C     MOVLW 0x3C
2798  24F3     ADDWF PROD, W, ACCESS
279A  6EF6     MOVWF TBLPTR, ACCESS
279C  0E7F     MOVLW 0x7F
279E  20F4     ADDWFC PRODH, W, ACCESS
27A0  6EF7     MOVWF TBLPTRH, ACCESS
27A2  0008     TBLRD*
27A4  50F5     MOVF TABLAT, W, ACCESS
27A6  198E     XORWF 0x8E, W, BANKED
27A8  B4D8     BTFSC STATUS, 2, ACCESS
27AA  D7DD     BRA 0x2766
27AC  51AF     MOVF i, W, BANKED
27AE  0D01     MULLW 0x1
27B0  50F3     MOVF PROD, W, ACCESS
27B2  258A     ADDWF s, W, BANKED
27B4  6ED9     MOVWF FSR2, ACCESS
27B6  50F4     MOVF PRODH, W, ACCESS
27B8  218B     ADDWFC ap, W, BANKED
27BA  6EDA     MOVWF FSR2H, ACCESS
27BC  50DF     MOVF INDF2, W, ACCESS
27BE  6F8E     MOVWF 0x8E, BANKED
27C0  51AF     MOVF i, W, BANKED
27C2  0D01     MULLW 0x1
27C4  0E33     MOVLW 0x33
27C6  24F3     ADDWF PROD, W, ACCESS
27C8  6EF6     MOVWF TBLPTR, ACCESS
27CA  0E7F     MOVLW 0x7F
27CC  20F4     ADDWFC PRODH, W, ACCESS
27CE  6EF7     MOVWF TBLPTRH, ACCESS
27D0  0008     TBLRD*
27D2  50F5     MOVF TABLAT, W, ACCESS
27D4  198E     XORWF 0x8E, W, BANKED
27D6  B4D8     BTFSC STATUS, 2, ACCESS
27D8  D7C6     BRA 0x2766
132:           	if (i >= CSTRLEN("inf")) {
27DA  0E02     MOVLW 0x2
27DC  65AF     CPFSGT i, BANKED
27DE  D023     BRA 0x2826
133:           #pragma clang diagnostic push
134:           #pragma clang diagnostic ignored "-Wliteral-range"
135:           		l = INFINITY;
27E0  0E00     MOVLW 0x0
27E2  6FAB     MOVWF _u, BANKED
27E4  0E00     MOVLW 0x0
27E6  6FAC     MOVWF fp, BANKED
27E8  0E80     MOVLW 0x80
27EA  6FAD     MOVWF 0xAD, BANKED
27EC  0E7F     MOVLW 0x7F
27EE  6FAE     MOVWF fmt, BANKED
136:           #pragma clang diagnostic pop
137:           		if (res != NULL) {
27F0  518C     MOVF res, W, BANKED
27F2  118D     IORWF 0x8D, W, BANKED
27F4  B4D8     BTFSC STATUS, 2, ACCESS
27F6  EF49     GOTO 0x3492
27F8  F01A     NOP
138:           			if (i != CSTRLEN("infinity")) {
27FA  0E08     MOVLW 0x8
27FC  19AF     XORWF i, W, BANKED
27FE  B4D8     BTFSC STATUS, 2, ACCESS
2800  D002     BRA 0x2806
139:           				i = CSTRLEN("inf");
2802  0E03     MOVLW 0x3
2804  6FAF     MOVWF i, BANKED
140:           			}
141:           			*res = (char*)s+i;
2806  51AF     MOVF i, W, BANKED
2808  258A     ADDWF s, W, BANKED
280A  6F8E     MOVWF 0x8E, BANKED
280C  0E00     MOVLW 0x0
280E  218B     ADDWFC ap, W, BANKED
2810  6F8F     MOVWF 0x8F, BANKED
2812  C08C     MOVFF res, FSR2
2814  FFD9     NOP
2816  C08D     MOVFF 0x8D, FSR2H
2818  FFDA     NOP
281A  C08E     MOVFF 0x8E, POSTINC2
281C  FFDE     NOP
281E  C08F     MOVFF 0x8F, POSTDEC2
2820  FFDD     NOP
142:           		}
143:           		goto exit_strtof;		
2822  EF49     GOTO 0x3492
2824  F01A     NOP
144:           	}
145:           	// check for NaN
146:           	for (i = 0; s[i] != '\0' && (s[i] == "nan"[i] || s[i] == "NAN"[i]); i++) {
2826  0E00     MOVLW 0x0
2828  6FAF     MOVWF i, BANKED
282A  D001     BRA 0x282E
147:           		continue;
148:           	}
282C  2BAF     INCF i, F, BANKED
282E  51AF     MOVF i, W, BANKED
2830  0D01     MULLW 0x1
2832  50F3     MOVF PROD, W, ACCESS
2834  258A     ADDWF s, W, BANKED
2836  6ED9     MOVWF FSR2, ACCESS
2838  50F4     MOVF PRODH, W, ACCESS
283A  218B     ADDWFC ap, W, BANKED
283C  6EDA     MOVWF FSR2H, ACCESS
283E  50DF     MOVF INDF2, W, ACCESS
2840  B4D8     BTFSC STATUS, 2, ACCESS
2842  D02E     BRA 0x28A0
2844  51AF     MOVF i, W, BANKED
2846  0D01     MULLW 0x1
2848  50F3     MOVF PROD, W, ACCESS
284A  258A     ADDWF s, W, BANKED
284C  6ED9     MOVWF FSR2, ACCESS
284E  50F4     MOVF PRODH, W, ACCESS
2850  218B     ADDWFC ap, W, BANKED
2852  6EDA     MOVWF FSR2H, ACCESS
2854  50DF     MOVF INDF2, W, ACCESS
2856  6F8E     MOVWF 0x8E, BANKED
2858  51AF     MOVF i, W, BANKED
285A  0D01     MULLW 0x1
285C  0EC3     MOVLW 0xC3
285E  24F3     ADDWF PROD, W, ACCESS
2860  6EF6     MOVWF TBLPTR, ACCESS
2862  0E7F     MOVLW 0x7F
2864  20F4     ADDWFC PRODH, W, ACCESS
2866  6EF7     MOVWF TBLPTRH, ACCESS
2868  0008     TBLRD*
286A  50F5     MOVF TABLAT, W, ACCESS
286C  198E     XORWF 0x8E, W, BANKED
286E  B4D8     BTFSC STATUS, 2, ACCESS
2870  D7DD     BRA 0x282C
2872  51AF     MOVF i, W, BANKED
2874  0D01     MULLW 0x1
2876  50F3     MOVF PROD, W, ACCESS
2878  258A     ADDWF s, W, BANKED
287A  6ED9     MOVWF FSR2, ACCESS
287C  50F4     MOVF PRODH, W, ACCESS
287E  218B     ADDWFC ap, W, BANKED
2880  6EDA     MOVWF FSR2H, ACCESS
2882  50DF     MOVF INDF2, W, ACCESS
2884  6F8E     MOVWF 0x8E, BANKED
2886  51AF     MOVF i, W, BANKED
2888  0D01     MULLW 0x1
288A  0EBB     MOVLW 0xBB
288C  24F3     ADDWF PROD, W, ACCESS
288E  6EF6     MOVWF TBLPTR, ACCESS
2890  0E7F     MOVLW 0x7F
2892  20F4     ADDWFC PRODH, W, ACCESS
2894  6EF7     MOVWF TBLPTRH, ACCESS
2896  0008     TBLRD*
2898  50F5     MOVF TABLAT, W, ACCESS
289A  198E     XORWF 0x8E, W, BANKED
289C  B4D8     BTFSC STATUS, 2, ACCESS
289E  D7C6     BRA 0x282C
149:           	if (i == CSTRLEN("nan")) {
28A0  0E03     MOVLW 0x3
28A2  19AF     XORWF i, W, BANKED
28A4  A4D8     BTFSS STATUS, 2, ACCESS
28A6  D05C     BRA 0x2960
150:           		l = NAN;
28A8  0ED3     MOVLW 0xD3
28AA  6E15     MOVWF dividend, ACCESS
28AC  0E7D     MOVLW 0x7D
28AE  6E16     MOVWF Message, ACCESS
28B0  ECB2     CALL 0x6964, 0
28B2  F034     NOP
28B4  C015     MOVFF dividend, _u
28B6  F0AB     NOP
28B8  C016     MOVFF Message, fp
28BA  F0AC     NOP
28BC  C017     MOVFF _r, 0xAD
28BE  F0AD     NOP
28C0  C018     MOVFF 0x18, fmt
28C2  F0AE     NOP
151:           		if (res != NULL) {
28C4  0100     MOVLB 0x0
28C6  518C     MOVF res, W, BANKED
28C8  118D     IORWF 0x8D, W, BANKED
28CA  B4D8     BTFSC STATUS, 2, ACCESS
28CC  EF49     GOTO 0x3492
28CE  F01A     NOP
152:           			s += i;
28D0  51AF     MOVF i, W, BANKED
28D2  278A     ADDWF s, F, BANKED
28D4  0E00     MOVLW 0x0
28D6  238B     ADDWFC ap, F, BANKED
153:           			if (*s == '(') {
28D8  C08A     MOVFF s, FSR2
28DA  FFD9     NOP
28DC  C08B     MOVFF ap, FSR2H
28DE  FFDA     NOP
28E0  0E28     MOVLW 0x28
28E2  18DE     XORWF POSTINC2, W, ACCESS
28E4  A4D8     BTFSS STATUS, 2, ACCESS
28E6  D032     BRA 0x294C
154:           				for (i = 0; s[i] != '\0' && s[i] != ')'; i++) {
28E8  0E00     MOVLW 0x0
28EA  6FAF     MOVWF i, BANKED
28EC  D001     BRA 0x28F0
155:           					continue;
156:           				}
28EE  2BAF     INCF i, F, BANKED
28F0  51AF     MOVF i, W, BANKED
28F2  0D01     MULLW 0x1
28F4  50F3     MOVF PROD, W, ACCESS
28F6  258A     ADDWF s, W, BANKED
28F8  6ED9     MOVWF FSR2, ACCESS
28FA  50F4     MOVF PRODH, W, ACCESS
28FC  218B     ADDWFC ap, W, BANKED
28FE  6EDA     MOVWF FSR2H, ACCESS
2900  50DF     MOVF INDF2, W, ACCESS
2902  B4D8     BTFSC STATUS, 2, ACCESS
2904  D00C     BRA 0x291E
2906  51AF     MOVF i, W, BANKED
2908  0D01     MULLW 0x1
290A  50F3     MOVF PROD, W, ACCESS
290C  258A     ADDWF s, W, BANKED
290E  6ED9     MOVWF FSR2, ACCESS
2910  50F4     MOVF PRODH, W, ACCESS
2912  218B     ADDWFC ap, W, BANKED
2914  6EDA     MOVWF FSR2H, ACCESS
2916  0E29     MOVLW 0x29
2918  18DE     XORWF POSTINC2, W, ACCESS
291A  A4D8     BTFSS STATUS, 2, ACCESS
291C  D7E8     BRA 0x28EE
157:           				if (s[i] == ')') {
291E  51AF     MOVF i, W, BANKED
2920  0D01     MULLW 0x1
2922  50F3     MOVF PROD, W, ACCESS
2924  258A     ADDWF s, W, BANKED
2926  6ED9     MOVWF FSR2, ACCESS
2928  50F4     MOVF PRODH, W, ACCESS
292A  218B     ADDWFC ap, W, BANKED
292C  6EDA     MOVWF FSR2H, ACCESS
292E  0E29     MOVLW 0x29
2930  18DE     XORWF POSTINC2, W, ACCESS
2932  A4D8     BTFSS STATUS, 2, ACCESS
2934  D00B     BRA 0x294C
158:           					s += i + 1;
2936  51AF     MOVF i, W, BANKED
2938  6F8E     MOVWF 0x8E, BANKED
293A  6B8F     CLRF 0x8F, BANKED
293C  0E01     MOVLW 0x1
293E  278E     ADDWF 0x8E, F, BANKED
2940  0E00     MOVLW 0x0
2942  238F     ADDWFC 0x8F, F, BANKED
2944  518E     MOVF 0x8E, W, BANKED
2946  278A     ADDWF s, F, BANKED
2948  518F     MOVF 0x8F, W, BANKED
294A  238B     ADDWFC ap, F, BANKED
159:           				}
160:           			}
161:           			*res = (char*)s;
294C  C08C     MOVFF res, FSR2
294E  FFD9     NOP
2950  C08D     MOVFF 0x8D, FSR2H
2952  FFDA     NOP
2954  C08A     MOVFF s, POSTINC2
2956  FFDE     NOP
2958  C08B     MOVFF ap, POSTDEC2
295A  FFDD     NOP
162:           		}
163:           		goto exit_strtof;		
295C  EF49     GOTO 0x3492
295E  F01A     NOP
164:           	}
165:           
166:           	eexp = 0;			/* Clear digit count */
2960  0E00     MOVLW 0x0
2962  6FAA     MOVWF 0xAA, BANKED
2964  0E00     MOVLW 0x0
2966  6FA9     MOVWF eexp, BANKED
167:           	v = 0;				/* Clear integer component */
2968  0E00     MOVLW 0x0
296A  6FAB     MOVWF _u, BANKED
296C  0E00     MOVLW 0x0
296E  6FAC     MOVWF fp, BANKED
2970  0E00     MOVLW 0x0
2972  6FAD     MOVWF 0xAD, BANKED
2974  0E00     MOVLW 0x0
2976  6FAE     MOVWF fmt, BANKED
168:           	expon = 0;			/* Total exponent for integer */
2978  0E00     MOVLW 0x0
297A  6FA8     MOVWF 0xA8, BANKED
297C  0E00     MOVLW 0x0
297E  6FA7     MOVWF expon, BANKED
169:           
170:           	// 6.4.4.2 hexadecimal floating constants
171:           	for (i = 0; s[i] == '0'; i++) {
2980  0E00     MOVLW 0x0
2982  6FAF     MOVWF i, BANKED
2984  D001     BRA 0x2988
172:           		// find first non-zero character
173:           		continue;
174:           	}
2986  2BAF     INCF i, F, BANKED
2988  51AF     MOVF i, W, BANKED
298A  0D01     MULLW 0x1
298C  50F3     MOVF PROD, W, ACCESS
298E  258A     ADDWF s, W, BANKED
2990  6ED9     MOVWF FSR2, ACCESS
2992  50F4     MOVF PRODH, W, ACCESS
2994  218B     ADDWFC ap, W, BANKED
2996  6EDA     MOVWF FSR2H, ACCESS
2998  0E30     MOVLW 0x30
299A  18DE     XORWF POSTINC2, W, ACCESS
299C  B4D8     BTFSC STATUS, 2, ACCESS
299E  D7F3     BRA 0x2986
175:           	if (i != 0 && (s[i] == 'x' || s[i] == 'X')) {
29A0  51AF     MOVF i, W, BANKED
29A2  B4D8     BTFSC STATUS, 2, ACCESS
29A4  D301     BRA 0x2FA8
29A6  51AF     MOVF i, W, BANKED
29A8  0D01     MULLW 0x1
29AA  50F3     MOVF PROD, W, ACCESS
29AC  258A     ADDWF s, W, BANKED
29AE  6ED9     MOVWF FSR2, ACCESS
29B0  50F4     MOVF PRODH, W, ACCESS
29B2  218B     ADDWFC ap, W, BANKED
29B4  6EDA     MOVWF FSR2H, ACCESS
29B6  0E78     MOVLW 0x78
29B8  18DE     XORWF POSTINC2, W, ACCESS
29BA  B4D8     BTFSC STATUS, 2, ACCESS
29BC  D00C     BRA 0x29D6
29BE  51AF     MOVF i, W, BANKED
29C0  0D01     MULLW 0x1
29C2  50F3     MOVF PROD, W, ACCESS
29C4  258A     ADDWF s, W, BANKED
29C6  6ED9     MOVWF FSR2, ACCESS
29C8  50F4     MOVF PRODH, W, ACCESS
29CA  218B     ADDWFC ap, W, BANKED
29CC  6EDA     MOVWF FSR2H, ACCESS
29CE  0E58     MOVLW 0x58
29D0  18DE     XORWF POSTINC2, W, ACCESS
29D2  A4D8     BTFSS STATUS, 2, ACCESS
29D4  D2E9     BRA 0x2FA8
176:           		s += i+1;
29D6  51AF     MOVF i, W, BANKED
29D8  6F8E     MOVWF 0x8E, BANKED
29DA  6B8F     CLRF 0x8F, BANKED
29DC  0E01     MOVLW 0x1
29DE  278E     ADDWF 0x8E, F, BANKED
29E0  0E00     MOVLW 0x0
29E2  238F     ADDWFC 0x8F, F, BANKED
29E4  518E     MOVF 0x8E, W, BANKED
29E6  278A     ADDWF s, F, BANKED
29E8  518F     MOVF 0x8F, W, BANKED
29EA  238B     ADDWFC ap, F, BANKED
177:           		// read the hexadecimal significand.
178:           		// skip leading zeros
179:           		for (i = 0; s[i] == '0'; i++) {
29EC  0E00     MOVLW 0x0
29EE  6FAF     MOVWF i, BANKED
29F0  D001     BRA 0x29F4
180:           			continue;
181:           		}
29F2  2BAF     INCF i, F, BANKED
29F4  51AF     MOVF i, W, BANKED
29F6  0D01     MULLW 0x1
29F8  50F3     MOVF PROD, W, ACCESS
29FA  258A     ADDWF s, W, BANKED
29FC  6ED9     MOVWF FSR2, ACCESS
29FE  50F4     MOVF PRODH, W, ACCESS
2A00  218B     ADDWFC ap, W, BANKED
2A02  6EDA     MOVWF FSR2H, ACCESS
2A04  0E30     MOVLW 0x30
2A06  18DE     XORWF POSTINC2, W, ACCESS
2A08  B4D8     BTFSC STATUS, 2, ACCESS
2A0A  D7F3     BRA 0x29F2
182:           		// first the integer part
183:           		for (i = 0; 1; i++) {
2A0C  0E00     MOVLW 0x0
2A0E  6FAF     MOVWF i, BANKED
184:           			if (s[i] == 'p' || s[i] == 'P') {
2A10  51AF     MOVF i, W, BANKED
2A12  0D01     MULLW 0x1
2A14  50F3     MOVF PROD, W, ACCESS
2A16  258A     ADDWF s, W, BANKED
2A18  6ED9     MOVWF FSR2, ACCESS
2A1A  50F4     MOVF PRODH, W, ACCESS
2A1C  218B     ADDWFC ap, W, BANKED
2A1E  6EDA     MOVWF FSR2H, ACCESS
2A20  0E70     MOVLW 0x70
2A22  18DE     XORWF POSTINC2, W, ACCESS
2A24  B4D8     BTFSC STATUS, 2, ACCESS
2A26  D15A     BRA 0x2CDC
2A28  51AF     MOVF i, W, BANKED
2A2A  0D01     MULLW 0x1
2A2C  50F3     MOVF PROD, W, ACCESS
2A2E  258A     ADDWF s, W, BANKED
2A30  6ED9     MOVWF FSR2, ACCESS
2A32  50F4     MOVF PRODH, W, ACCESS
2A34  218B     ADDWFC ap, W, BANKED
2A36  6EDA     MOVWF FSR2H, ACCESS
2A38  0E50     MOVLW 0x50
2A3A  18DE     XORWF POSTINC2, W, ACCESS
2A3C  B4D8     BTFSC STATUS, 2, ACCESS
2A3E  D14E     BRA 0x2CDC
185:           				break;
186:           			}
187:           			else if (s[i] == '.') {
2A40  51AF     MOVF i, W, BANKED
2A42  0D01     MULLW 0x1
2A44  50F3     MOVF PROD, W, ACCESS
2A46  258A     ADDWF s, W, BANKED
2A48  6ED9     MOVWF FSR2, ACCESS
2A4A  50F4     MOVF PRODH, W, ACCESS
2A4C  218B     ADDWFC ap, W, BANKED
2A4E  6EDA     MOVWF FSR2H, ACCESS
2A50  0E2E     MOVLW 0x2E
2A52  18DE     XORWF POSTINC2, W, ACCESS
2A54  A4D8     BTFSS STATUS, 2, ACCESS
2A56  D002     BRA 0x2A5C
188:           				flags |= DOTSEEN;
2A58  89A6     BSF flags, 4, BANKED
2A5A  D13F     BRA 0x2CDA
189:           				i++;
190:           				break;
191:           			}
192:           			else if (isxdigit(s[i])) {
2A5C  51AF     MOVF i, W, BANKED
2A5E  0D01     MULLW 0x1
2A60  50F3     MOVF PROD, W, ACCESS
2A62  258A     ADDWF s, W, BANKED
2A64  6ED9     MOVWF FSR2, ACCESS
2A66  50F4     MOVF PRODH, W, ACCESS
2A68  218B     ADDWFC ap, W, BANKED
2A6A  6EDA     MOVWF FSR2H, ACCESS
2A6C  50DF     MOVF INDF2, W, ACCESS
2A6E  6F8E     MOVWF 0x8E, BANKED
2A70  518E     MOVF 0x8E, W, BANKED
2A72  6E15     MOVWF dividend, ACCESS
2A74  6A16     CLRF Message, ACCESS
2A76  ECF9     CALL 0x5DF2, 0
2A78  F02E     NOP
2A7A  5015     MOVF dividend, W, ACCESS
2A7C  1016     IORWF Message, W, ACCESS
2A7E  B4D8     BTFSC STATUS, 2, ACCESS
2A80  D072     BRA 0x2B66
193:           				digit = 0;
2A82  0E00     MOVLW 0x0
2A84  0100     MOVLB 0x0
2A86  6FA5     MOVWF digit, BANKED
194:           				if (isdigit(s[i])) {
2A88  0ED0     MOVLW 0xD0
2A8A  6F8E     MOVWF 0x8E, BANKED
2A8C  0EFF     MOVLW 0xFF
2A8E  6F8F     MOVWF 0x8F, BANKED
2A90  51AF     MOVF i, W, BANKED
2A92  0D01     MULLW 0x1
2A94  50F3     MOVF PROD, W, ACCESS
2A96  258A     ADDWF s, W, BANKED
2A98  6ED9     MOVWF FSR2, ACCESS
2A9A  50F4     MOVF PRODH, W, ACCESS
2A9C  218B     ADDWFC ap, W, BANKED
2A9E  6EDA     MOVWF FSR2H, ACCESS
2AA0  50DF     MOVF INDF2, W, ACCESS
2AA2  6F90     MOVWF 0x90, BANKED
2AA4  6B91     CLRF cp, BANKED
2AA6  518E     MOVF 0x8E, W, BANKED
2AA8  2790     ADDWF 0x90, F, BANKED
2AAA  518F     MOVF 0x8F, W, BANKED
2AAC  2391     ADDWFC cp, F, BANKED
2AAE  5191     MOVF cp, W, BANKED
2AB0  E106     BNZ 0x2ABE
2AB2  0E0A     MOVLW 0xA
2AB4  5D90     SUBWF 0x90, W, BANKED
2AB6  B0D8     BTFSC STATUS, 0, ACCESS
2AB8  D002     BRA 0x2ABE
2ABA  0E01     MOVLW 0x1
2ABC  D001     BRA 0x2AC0
2ABE  0E00     MOVLW 0x0
2AC0  6F96     MOVWF 0x96, BANKED
2AC2  6B97     CLRF 0x97, BANKED
2AC4  0100     MOVLB 0x0
2AC6  5196     MOVF 0x96, W, BANKED
2AC8  1197     IORWF 0x97, W, BANKED
2ACA  B4D8     BTFSC STATUS, 2, ACCESS
2ACC  D00B     BRA 0x2AE4
195:           					digit = s[i] - '0';
2ACE  51AF     MOVF i, W, BANKED
2AD0  0D01     MULLW 0x1
2AD2  50F3     MOVF PROD, W, ACCESS
2AD4  258A     ADDWF s, W, BANKED
2AD6  6ED9     MOVWF FSR2, ACCESS
2AD8  50F4     MOVF PRODH, W, ACCESS
2ADA  218B     ADDWFC ap, W, BANKED
2ADC  6EDA     MOVWF FSR2H, ACCESS
2ADE  50DF     MOVF INDF2, W, ACCESS
2AE0  0FD0     ADDLW 0xD0
2AE2  D012     BRA 0x2B08
196:           				}
197:           				else {
198:           					digit = toupper(s[i]) - 'A' + 10;
2AE4  51AF     MOVF i, W, BANKED
2AE6  0D01     MULLW 0x1
2AE8  50F3     MOVF PROD, W, ACCESS
2AEA  258A     ADDWF s, W, BANKED
2AEC  6ED9     MOVWF FSR2, ACCESS
2AEE  50F4     MOVF PRODH, W, ACCESS
2AF0  218B     ADDWFC ap, W, BANKED
2AF2  6EDA     MOVWF FSR2H, ACCESS
2AF4  50DF     MOVF INDF2, W, ACCESS
2AF6  6F8E     MOVWF 0x8E, BANKED
2AF8  518E     MOVF 0x8E, W, BANKED
2AFA  6E1B     MOVWF c, ACCESS
2AFC  6A1C     CLRF c, ACCESS
2AFE  EC16     CALL 0x622C, 0
2B00  F031     NOP
2B02  501B     MOVF c, W, ACCESS
2B04  0FC9     ADDLW 0xC9
2B06  0100     MOVLB 0x0
2B08  6FA5     MOVWF digit, BANKED
199:           				}
200:           				if (eexp < 8) {
2B0A  BFAA     BTFSC 0xAA, 7, BANKED
2B0C  D006     BRA 0x2B1A
2B0E  51AA     MOVF 0xAA, W, BANKED
2B10  E123     BNZ 0x2B58
2B12  0E08     MOVLW 0x8
2B14  5DA9     SUBWF eexp, W, BANKED
2B16  B0D8     BTFSC STATUS, 0, ACCESS
2B18  D01F     BRA 0x2B58
201:           					v |= ((uint32_t)digit << ((8 - eexp - 1) * 4)); 
2B1A  29A9     INCF eexp, W, BANKED
2B1C  0800     SUBLW 0x0
2B1E  6F8E     MOVWF 0x8E, BANKED
2B20  90D8     BCF STATUS, 0, ACCESS
2B22  378E     RLCF 0x8E, F, BANKED
2B24  90D8     BCF STATUS, 0, ACCESS
2B26  378E     RLCF 0x8E, F, BANKED
2B28  0E20     MOVLW 0x20
2B2A  278E     ADDWF 0x8E, F, BANKED
2B2C  C0A5     MOVFF digit, 0x8F
2B2E  F08F     NOP
2B30  6B90     CLRF 0x90, BANKED
2B32  6B91     CLRF cp, BANKED
2B34  6B92     CLRF 0x92, BANKED
2B36  2B8E     INCF 0x8E, F, BANKED
2B38  D005     BRA 0x2B44
2B3A  90D8     BCF STATUS, 0, ACCESS
2B3C  378F     RLCF 0x8F, F, BANKED
2B3E  3790     RLCF 0x90, F, BANKED
2B40  3791     RLCF cp, F, BANKED
2B42  3792     RLCF 0x92, F, BANKED
2B44  2F8E     DECFSZ 0x8E, F, BANKED
2B46  D7F9     BRA 0x2B3A
2B48  518F     MOVF 0x8F, W, BANKED
2B4A  13AB     IORWF _u, F, BANKED
2B4C  5190     MOVF 0x90, W, BANKED
2B4E  13AC     IORWF fp, F, BANKED
2B50  5191     MOVF cp, W, BANKED
2B52  13AD     IORWF 0xAD, F, BANKED
2B54  5192     MOVF 0x92, W, BANKED
2B56  13AE     IORWF fmt, F, BANKED
202:           				}
203:           				eexp++;
2B58  4BA9     INFSNZ eexp, F, BANKED
2B5A  2BAA     INCF 0xAA, F, BANKED
204:           				expon += 4;
2B5C  0E04     MOVLW 0x4
2B5E  27A7     ADDWF expon, F, BANKED
2B60  0E00     MOVLW 0x0
2B62  23A8     ADDWFC 0xA8, F, BANKED
205:           			}
2B64  D00A     BRA 0x2B7A
206:           			else {
207:           				return 0.0f;
2B66  0E00     MOVLW 0x0
2B68  0100     MOVLB 0x0
2B6A  6F8A     MOVWF s, BANKED
2B6C  0E00     MOVLW 0x0
2B6E  6F8B     MOVWF ap, BANKED
2B70  0E00     MOVLW 0x0
2B72  6F8C     MOVWF res, BANKED
2B74  0E00     MOVLW 0x0
2B76  6F8D     MOVWF 0x8D, BANKED
2B78  0012     RETURN 0
208:           			}
209:           
210:           		}
2B7A  2BAF     INCF i, F, BANKED
2B7C  D749     BRA 0x2A10
211:           		// fraction part
212:           		for (; flags & DOTSEEN ;i++) {
213:           			if (s[i] == 'p' || s[i] == 'P') {
2B7E  51AF     MOVF i, W, BANKED
2B80  0D01     MULLW 0x1
2B82  50F3     MOVF PROD, W, ACCESS
2B84  258A     ADDWF s, W, BANKED
2B86  6ED9     MOVWF FSR2, ACCESS
2B88  50F4     MOVF PRODH, W, ACCESS
2B8A  218B     ADDWFC ap, W, BANKED
2B8C  6EDA     MOVWF FSR2H, ACCESS
2B8E  0E70     MOVLW 0x70
2B90  18DE     XORWF POSTINC2, W, ACCESS
2B92  B4D8     BTFSC STATUS, 2, ACCESS
2B94  D0A5     BRA 0x2CE0
2B96  51AF     MOVF i, W, BANKED
2B98  0D01     MULLW 0x1
2B9A  50F3     MOVF PROD, W, ACCESS
2B9C  258A     ADDWF s, W, BANKED
2B9E  6ED9     MOVWF FSR2, ACCESS
2BA0  50F4     MOVF PRODH, W, ACCESS
2BA2  218B     ADDWFC ap, W, BANKED
2BA4  6EDA     MOVWF FSR2H, ACCESS
2BA6  0E50     MOVLW 0x50
2BA8  18DE     XORWF POSTINC2, W, ACCESS
2BAA  B4D8     BTFSC STATUS, 2, ACCESS
2BAC  D099     BRA 0x2CE0
214:           				break;
215:           			}
216:           			else if (s[i] == '0' && eexp == 0) {
2BAE  51AF     MOVF i, W, BANKED
2BB0  0D01     MULLW 0x1
2BB2  50F3     MOVF PROD, W, ACCESS
2BB4  258A     ADDWF s, W, BANKED
2BB6  6ED9     MOVWF FSR2, ACCESS
2BB8  50F4     MOVF PRODH, W, ACCESS
2BBA  218B     ADDWFC ap, W, BANKED
2BBC  6EDA     MOVWF FSR2H, ACCESS
2BBE  0E30     MOVLW 0x30
2BC0  18DE     XORWF POSTINC2, W, ACCESS
2BC2  A4D8     BTFSS STATUS, 2, ACCESS
2BC4  D009     BRA 0x2BD8
2BC6  51A9     MOVF eexp, W, BANKED
2BC8  11AA     IORWF 0xAA, W, BANKED
2BCA  A4D8     BTFSS STATUS, 2, ACCESS
2BCC  D005     BRA 0x2BD8
217:           				expon -= 4;
2BCE  0EFC     MOVLW 0xFC
2BD0  27A7     ADDWF expon, F, BANKED
2BD2  0EFF     MOVLW 0xFF
2BD4  23A8     ADDWFC 0xA8, F, BANKED
218:           			}	
2BD6  D080     BRA 0x2CD8
219:           			else if (isxdigit(s[i])) {
2BD8  51AF     MOVF i, W, BANKED
2BDA  0D01     MULLW 0x1
2BDC  50F3     MOVF PROD, W, ACCESS
2BDE  258A     ADDWF s, W, BANKED
2BE0  6ED9     MOVWF FSR2, ACCESS
2BE2  50F4     MOVF PRODH, W, ACCESS
2BE4  218B     ADDWFC ap, W, BANKED
2BE6  6EDA     MOVWF FSR2H, ACCESS
2BE8  50DF     MOVF INDF2, W, ACCESS
2BEA  6F8E     MOVWF 0x8E, BANKED
2BEC  518E     MOVF 0x8E, W, BANKED
2BEE  6E15     MOVWF dividend, ACCESS
2BF0  6A16     CLRF Message, ACCESS
2BF2  ECF9     CALL 0x5DF2, 0
2BF4  F02E     NOP
2BF6  5015     MOVF dividend, W, ACCESS
2BF8  1016     IORWF Message, W, ACCESS
2BFA  B4D8     BTFSC STATUS, 2, ACCESS
2BFC  D06D     BRA 0x2CD8
220:           				digit = 0;
2BFE  0E00     MOVLW 0x0
2C00  0100     MOVLB 0x0
2C02  6FA5     MOVWF digit, BANKED
221:           				if (isdigit(s[i])) {
2C04  0ED0     MOVLW 0xD0
2C06  6F8E     MOVWF 0x8E, BANKED
2C08  0EFF     MOVLW 0xFF
2C0A  6F8F     MOVWF 0x8F, BANKED
2C0C  51AF     MOVF i, W, BANKED
2C0E  0D01     MULLW 0x1
2C10  50F3     MOVF PROD, W, ACCESS
2C12  258A     ADDWF s, W, BANKED
2C14  6ED9     MOVWF FSR2, ACCESS
2C16  50F4     MOVF PRODH, W, ACCESS
2C18  218B     ADDWFC ap, W, BANKED
2C1A  6EDA     MOVWF FSR2H, ACCESS
2C1C  50DF     MOVF INDF2, W, ACCESS
2C1E  6F90     MOVWF 0x90, BANKED
2C20  6B91     CLRF cp, BANKED
2C22  518E     MOVF 0x8E, W, BANKED
2C24  2790     ADDWF 0x90, F, BANKED
2C26  518F     MOVF 0x8F, W, BANKED
2C28  2391     ADDWFC cp, F, BANKED
2C2A  5191     MOVF cp, W, BANKED
2C2C  E106     BNZ 0x2C3A
2C2E  0E0A     MOVLW 0xA
2C30  5D90     SUBWF 0x90, W, BANKED
2C32  B0D8     BTFSC STATUS, 0, ACCESS
2C34  D002     BRA 0x2C3A
2C36  0E01     MOVLW 0x1
2C38  D001     BRA 0x2C3C
2C3A  0E00     MOVLW 0x0
2C3C  6F98     MOVWF 0x98, BANKED
2C3E  6B99     CLRF ll, BANKED
2C40  0100     MOVLB 0x0
2C42  5198     MOVF 0x98, W, BANKED
2C44  1199     IORWF ll, W, BANKED
2C46  B4D8     BTFSC STATUS, 2, ACCESS
2C48  D00B     BRA 0x2C60
222:           					digit = s[i] - '0';
2C4A  51AF     MOVF i, W, BANKED
2C4C  0D01     MULLW 0x1
2C4E  50F3     MOVF PROD, W, ACCESS
2C50  258A     ADDWF s, W, BANKED
2C52  6ED9     MOVWF FSR2, ACCESS
2C54  50F4     MOVF PRODH, W, ACCESS
2C56  218B     ADDWFC ap, W, BANKED
2C58  6EDA     MOVWF FSR2H, ACCESS
2C5A  50DF     MOVF INDF2, W, ACCESS
2C5C  0FD0     ADDLW 0xD0
2C5E  D012     BRA 0x2C84
223:           				}
224:           				else {
225:           					digit = toupper(s[i]) - 'A' + 10;
2C60  51AF     MOVF i, W, BANKED
2C62  0D01     MULLW 0x1
2C64  50F3     MOVF PROD, W, ACCESS
2C66  258A     ADDWF s, W, BANKED
2C68  6ED9     MOVWF FSR2, ACCESS
2C6A  50F4     MOVF PRODH, W, ACCESS
2C6C  218B     ADDWFC ap, W, BANKED
2C6E  6EDA     MOVWF FSR2H, ACCESS
2C70  50DF     MOVF INDF2, W, ACCESS
2C72  6F8E     MOVWF 0x8E, BANKED
2C74  518E     MOVF 0x8E, W, BANKED
2C76  6E1B     MOVWF c, ACCESS
2C78  6A1C     CLRF c, ACCESS
2C7A  EC16     CALL 0x622C, 0
2C7C  F031     NOP
2C7E  501B     MOVF c, W, ACCESS
2C80  0FC9     ADDLW 0xC9
2C82  0100     MOVLB 0x0
2C84  6FA5     MOVWF digit, BANKED
226:           				}
227:           				if (eexp < 8) {
2C86  BFAA     BTFSC 0xAA, 7, BANKED
2C88  D006     BRA 0x2C96
2C8A  51AA     MOVF 0xAA, W, BANKED
2C8C  E123     BNZ 0x2CD4
2C8E  0E08     MOVLW 0x8
2C90  5DA9     SUBWF eexp, W, BANKED
2C92  B0D8     BTFSC STATUS, 0, ACCESS
2C94  D01F     BRA 0x2CD4
228:           					v |= ((int32_t)digit << ((8 - eexp - 1) * 4)); 
2C96  29A9     INCF eexp, W, BANKED
2C98  0800     SUBLW 0x0
2C9A  6F8E     MOVWF 0x8E, BANKED
2C9C  90D8     BCF STATUS, 0, ACCESS
2C9E  378E     RLCF 0x8E, F, BANKED
2CA0  90D8     BCF STATUS, 0, ACCESS
2CA2  378E     RLCF 0x8E, F, BANKED
2CA4  0E20     MOVLW 0x20
2CA6  278E     ADDWF 0x8E, F, BANKED
2CA8  C0A5     MOVFF digit, 0x8F
2CAA  F08F     NOP
2CAC  6B90     CLRF 0x90, BANKED
2CAE  6B91     CLRF cp, BANKED
2CB0  6B92     CLRF 0x92, BANKED
2CB2  2B8E     INCF 0x8E, F, BANKED
2CB4  D005     BRA 0x2CC0
2CB6  90D8     BCF STATUS, 0, ACCESS
2CB8  378F     RLCF 0x8F, F, BANKED
2CBA  3790     RLCF 0x90, F, BANKED
2CBC  3791     RLCF cp, F, BANKED
2CBE  3792     RLCF 0x92, F, BANKED
2CC0  2F8E     DECFSZ 0x8E, F, BANKED
2CC2  D7F9     BRA 0x2CB6
2CC4  518F     MOVF 0x8F, W, BANKED
2CC6  13AB     IORWF _u, F, BANKED
2CC8  5190     MOVF 0x90, W, BANKED
2CCA  13AC     IORWF fp, F, BANKED
2CCC  5191     MOVF cp, W, BANKED
2CCE  13AD     IORWF 0xAD, F, BANKED
2CD0  5192     MOVF 0x92, W, BANKED
2CD2  13AE     IORWF fmt, F, BANKED
229:           				}
230:           				eexp++;
2CD4  4BA9     INFSNZ eexp, F, BANKED
2CD6  2BAA     INCF 0xAA, F, BANKED
231:           			}
232:           		}	
2CD8  0100     MOVLB 0x0
2CDA  2BAF     INCF i, F, BANKED
2CDC  B9A6     BTFSC flags, 4, BANKED
2CDE  D74F     BRA 0x2B7E
233:           		// exponent
234:           		if (s[i] != 'p' && s[i] != 'P') {
2CE0  51AF     MOVF i, W, BANKED
2CE2  0D01     MULLW 0x1
2CE4  50F3     MOVF PROD, W, ACCESS
2CE6  258A     ADDWF s, W, BANKED
2CE8  6ED9     MOVWF FSR2, ACCESS
2CEA  50F4     MOVF PRODH, W, ACCESS
2CEC  218B     ADDWFC ap, W, BANKED
2CEE  6EDA     MOVWF FSR2H, ACCESS
2CF0  0E70     MOVLW 0x70
2CF2  18DE     XORWF POSTINC2, W, ACCESS
2CF4  B4D8     BTFSC STATUS, 2, ACCESS
2CF6  D015     BRA 0x2D22
2CF8  51AF     MOVF i, W, BANKED
2CFA  0D01     MULLW 0x1
2CFC  50F3     MOVF PROD, W, ACCESS
2CFE  258A     ADDWF s, W, BANKED
2D00  6ED9     MOVWF FSR2, ACCESS
2D02  50F4     MOVF PRODH, W, ACCESS
2D04  218B     ADDWFC ap, W, BANKED
2D06  6EDA     MOVWF FSR2H, ACCESS
2D08  0E50     MOVLW 0x50
2D0A  18DE     XORWF POSTINC2, W, ACCESS
2D0C  B4D8     BTFSC STATUS, 2, ACCESS
2D0E  D009     BRA 0x2D22
235:           			return 0.0f;
2D10  0E00     MOVLW 0x0
2D12  6F8A     MOVWF s, BANKED
2D14  0E00     MOVLW 0x0
2D16  6F8B     MOVWF ap, BANKED
2D18  0E00     MOVLW 0x0
2D1A  6F8C     MOVWF res, BANKED
2D1C  0E00     MOVLW 0x0
2D1E  6F8D     MOVWF 0x8D, BANKED
2D20  0012     RETURN 0
236:           		}
237:           		i++;
2D22  2BAF     INCF i, F, BANKED
238:           		if (s[i] == '+') {
2D24  51AF     MOVF i, W, BANKED
2D26  0D01     MULLW 0x1
2D28  50F3     MOVF PROD, W, ACCESS
2D2A  258A     ADDWF s, W, BANKED
2D2C  6ED9     MOVWF FSR2, ACCESS
2D2E  50F4     MOVF PRODH, W, ACCESS
2D30  218B     ADDWFC ap, W, BANKED
2D32  6EDA     MOVWF FSR2H, ACCESS
2D34  0E2B     MOVLW 0x2B
2D36  18DE     XORWF POSTINC2, W, ACCESS
2D38  B4D8     BTFSC STATUS, 2, ACCESS
239:           		   // skip the '+'
240:           		   i++;
2D3A  D00D     BRA 0x2D56
241:           		}
242:           		else if (s[i] == '-') {
2D3C  51AF     MOVF i, W, BANKED
2D3E  0D01     MULLW 0x1
2D40  50F3     MOVF PROD, W, ACCESS
2D42  258A     ADDWF s, W, BANKED
2D44  6ED9     MOVWF FSR2, ACCESS
2D46  50F4     MOVF PRODH, W, ACCESS
2D48  218B     ADDWFC ap, W, BANKED
2D4A  6EDA     MOVWF FSR2H, ACCESS
2D4C  0E2D     MOVLW 0x2D
2D4E  18DE     XORWF POSTINC2, W, ACCESS
2D50  A4D8     BTFSS STATUS, 2, ACCESS
2D52  D002     BRA 0x2D58
243:           			flags |= EXPNEG;
2D54  87A6     BSF flags, 3, BANKED
244:           		   i++;
2D56  2BAF     INCF i, F, BANKED
245:           		}
246:           		s += i;
2D58  51AF     MOVF i, W, BANKED
2D5A  278A     ADDWF s, F, BANKED
2D5C  0E00     MOVLW 0x0
2D5E  238B     ADDWFC ap, F, BANKED
247:           		for (i = 0; s[i] == '0'; i++) {
2D60  0E00     MOVLW 0x0
2D62  6FAF     MOVWF i, BANKED
2D64  D001     BRA 0x2D68
248:           			continue; // skip leading zeros
249:           		}
2D66  2BAF     INCF i, F, BANKED
2D68  51AF     MOVF i, W, BANKED
2D6A  0D01     MULLW 0x1
2D6C  50F3     MOVF PROD, W, ACCESS
2D6E  258A     ADDWF s, W, BANKED
2D70  6ED9     MOVWF FSR2, ACCESS
2D72  50F4     MOVF PRODH, W, ACCESS
2D74  218B     ADDWFC ap, W, BANKED
2D76  6EDA     MOVWF FSR2H, ACCESS
2D78  0E30     MOVLW 0x30
2D7A  18DE     XORWF POSTINC2, W, ACCESS
2D7C  B4D8     BTFSC STATUS, 2, ACCESS
2D7E  D7F3     BRA 0x2D66
250:           		eexp = 0;
2D80  0E00     MOVLW 0x0
2D82  6FAA     MOVWF 0xAA, BANKED
2D84  0E00     MOVLW 0x0
2D86  6FA9     MOVWF eexp, BANKED
251:           		for (; isdigit(s[i]); i++) {
2D88  D02A     BRA 0x2DDE
252:           			if (i != 0) {
2D8A  51AF     MOVF i, W, BANKED
2D8C  B4D8     BTFSC STATUS, 2, ACCESS
2D8E  D00E     BRA 0x2DAC
253:           				eexp *= 10;
2D90  C0A9     MOVFF eexp, dividend
2D92  F015     NOP
2D94  C0AA     MOVFF 0xAA, Message
2D96  F016     NOP
2D98  0E00     MOVLW 0x0
2D9A  6E18     MOVWF 0x18, ACCESS
2D9C  0E0A     MOVLW 0xA
2D9E  6E17     MOVWF _r, ACCESS
2DA0  EC57     CALL 0x68AE, 0
2DA2  F034     NOP
2DA4  C015     MOVFF dividend, eexp
2DA6  F0A9     NOP
2DA8  C016     MOVFF Message, 0xAA
2DAA  F0AA     NOP
254:           			}
255:           			eexp += s[i] - '0';
2DAC  0ED0     MOVLW 0xD0
2DAE  0100     MOVLB 0x0
2DB0  6F8E     MOVWF 0x8E, BANKED
2DB2  0EFF     MOVLW 0xFF
2DB4  6F8F     MOVWF 0x8F, BANKED
2DB6  51AF     MOVF i, W, BANKED
2DB8  0D01     MULLW 0x1
2DBA  50F3     MOVF PROD, W, ACCESS
2DBC  258A     ADDWF s, W, BANKED
2DBE  6ED9     MOVWF FSR2, ACCESS
2DC0  50F4     MOVF PRODH, W, ACCESS
2DC2  218B     ADDWFC ap, W, BANKED
2DC4  6EDA     MOVWF FSR2H, ACCESS
2DC6  50DF     MOVF INDF2, W, ACCESS
2DC8  6F90     MOVWF 0x90, BANKED
2DCA  6B91     CLRF cp, BANKED
2DCC  518E     MOVF 0x8E, W, BANKED
2DCE  2790     ADDWF 0x90, F, BANKED
2DD0  518F     MOVF 0x8F, W, BANKED
2DD2  2391     ADDWFC cp, F, BANKED
2DD4  5190     MOVF 0x90, W, BANKED
2DD6  27A9     ADDWF eexp, F, BANKED
2DD8  5191     MOVF cp, W, BANKED
2DDA  23AA     ADDWFC 0xAA, F, BANKED
256:           		}
2DDC  2BAF     INCF i, F, BANKED
2DDE  0ED0     MOVLW 0xD0
2DE0  6F8E     MOVWF 0x8E, BANKED
2DE2  0EFF     MOVLW 0xFF
2DE4  6F8F     MOVWF 0x8F, BANKED
2DE6  51AF     MOVF i, W, BANKED
2DE8  0D01     MULLW 0x1
2DEA  50F3     MOVF PROD, W, ACCESS
2DEC  258A     ADDWF s, W, BANKED
2DEE  6ED9     MOVWF FSR2, ACCESS
2DF0  50F4     MOVF PRODH, W, ACCESS
2DF2  218B     ADDWFC ap, W, BANKED
2DF4  6EDA     MOVWF FSR2H, ACCESS
2DF6  50DF     MOVF INDF2, W, ACCESS
2DF8  6F90     MOVWF 0x90, BANKED
2DFA  6B91     CLRF cp, BANKED
2DFC  518E     MOVF 0x8E, W, BANKED
2DFE  2790     ADDWF 0x90, F, BANKED
2E00  518F     MOVF 0x8F, W, BANKED
2E02  2391     ADDWFC cp, F, BANKED
2E04  5191     MOVF cp, W, BANKED
2E06  E106     BNZ 0x2E14
2E08  0E0A     MOVLW 0xA
2E0A  5D90     SUBWF 0x90, W, BANKED
2E0C  B0D8     BTFSC STATUS, 0, ACCESS
2E0E  D002     BRA 0x2E14
2E10  0E01     MOVLW 0x1
2E12  D001     BRA 0x2E16
2E14  0E00     MOVLW 0x0
2E16  6F9A     MOVWF 0x9A, BANKED
2E18  6B9B     CLRF 0x9B, BANKED
2E1A  0100     MOVLB 0x0
2E1C  519A     MOVF 0x9A, W, BANKED
2E1E  119B     IORWF 0x9B, W, BANKED
2E20  A4D8     BTFSS STATUS, 2, ACCESS
2E22  D7B3     BRA 0x2D8A
257:           		if (i == 0) {
2E24  51AF     MOVF i, W, BANKED
2E26  A4D8     BTFSS STATUS, 2, ACCESS
2E28  D009     BRA 0x2E3C
258:           			return 0.0f;
2E2A  0E00     MOVLW 0x0
2E2C  6F8A     MOVWF s, BANKED
2E2E  0E00     MOVLW 0x0
2E30  6F8B     MOVWF ap, BANKED
2E32  0E00     MOVLW 0x0
2E34  6F8C     MOVWF res, BANKED
2E36  0E00     MOVLW 0x0
2E38  6F8D     MOVWF 0x8D, BANKED
2E3A  0012     RETURN 0
259:           		}
260:           		if (flags & EXPNEG) {
2E3C  A7A6     BTFSS flags, 3, BANKED
2E3E  D004     BRA 0x2E48
261:           			eexp = -eexp;
2E40  6DA9     NEGF eexp, BANKED
2E42  1FAA     COMF 0xAA, F, BANKED
2E44  B0D8     BTFSC STATUS, 0, ACCESS
2E46  2BAA     INCF 0xAA, F, BANKED
262:           		}
263:           		expon += eexp;
2E48  51A9     MOVF eexp, W, BANKED
2E4A  27A7     ADDWF expon, F, BANKED
2E4C  51AA     MOVF 0xAA, W, BANKED
2E4E  23A8     ADDWFC 0xA8, F, BANKED
264:           		if (res != NULL) {
2E50  518C     MOVF res, W, BANKED
2E52  118D     IORWF 0x8D, W, BANKED
2E54  B4D8     BTFSC STATUS, 2, ACCESS
2E56  D00E     BRA 0x2E74
265:           			*res = (char*)s+i;
2E58  51AF     MOVF i, W, BANKED
2E5A  258A     ADDWF s, W, BANKED
2E5C  6F8E     MOVWF 0x8E, BANKED
2E5E  0E00     MOVLW 0x0
2E60  218B     ADDWFC ap, W, BANKED
2E62  6F8F     MOVWF 0x8F, BANKED
2E64  C08C     MOVFF res, FSR2
2E66  FFD9     NOP
2E68  C08D     MOVFF 0x8D, FSR2H
2E6A  FFDA     NOP
2E6C  C08E     MOVFF 0x8E, POSTINC2
2E6E  FFDE     NOP
2E70  C08F     MOVFF 0x8F, POSTDEC2
2E72  FFDD     NOP
266:           		}
267:           		if (v == 0) {
2E74  51AB     MOVF _u, W, BANKED
2E76  11AC     IORWF fp, W, BANKED
2E78  11AD     IORWF 0xAD, W, BANKED
2E7A  11AE     IORWF fmt, W, BANKED
2E7C  A4D8     BTFSS STATUS, 2, ACCESS
2E7E  D009     BRA 0x2E92
268:           			return 0.0f;
2E80  0E00     MOVLW 0x0
2E82  6F8A     MOVWF s, BANKED
2E84  0E00     MOVLW 0x0
2E86  6F8B     MOVWF ap, BANKED
2E88  0E00     MOVLW 0x0
2E8A  6F8C     MOVWF res, BANKED
2E8C  0E00     MOVLW 0x0
2E8E  6F8D     MOVWF 0x8D, BANKED
2E90  0012     RETURN 0
269:           		}
270:           		// round-up mantissa
271:           		if ((v & 0xFF) > 0x80) {
2E92  0EFF     MOVLW 0xFF
2E94  15AB     ANDWF _u, W, BANKED
2E96  6F8E     MOVWF 0x8E, BANKED
2E98  0E00     MOVLW 0x0
2E9A  15AC     ANDWF fp, W, BANKED
2E9C  6F8F     MOVWF 0x8F, BANKED
2E9E  0E00     MOVLW 0x0
2EA0  15AD     ANDWF 0xAD, W, BANKED
2EA2  6F90     MOVWF 0x90, BANKED
2EA4  0E00     MOVLW 0x0
2EA6  15AE     ANDWF fmt, W, BANKED
2EA8  6F91     MOVWF cp, BANKED
2EAA  5191     MOVF cp, W, BANKED
2EAC  1190     IORWF 0x90, W, BANKED
2EAE  118F     IORWF 0x8F, W, BANKED
2EB0  E104     BNZ 0x2EBA
2EB2  0E81     MOVLW 0x81
2EB4  5D8E     SUBWF 0x8E, W, BANKED
2EB6  A0D8     BTFSS STATUS, 0, ACCESS
2EB8  D011     BRA 0x2EDC
272:           			v += 0x100; 
2EBA  0E00     MOVLW 0x0
2EBC  27AB     ADDWF _u, F, BANKED
2EBE  0E01     MOVLW 0x1
2EC0  23AC     ADDWFC fp, F, BANKED
2EC2  0E00     MOVLW 0x0
2EC4  23AD     ADDWFC 0xAD, F, BANKED
2EC6  0E00     MOVLW 0x0
2EC8  23AE     ADDWFC fmt, F, BANKED
273:           		}
274:           		while (!(v & INT32_C(0x80000000))) {
2ECA  D008     BRA 0x2EDC
275:           				v <<= 1;
2ECC  90D8     BCF STATUS, 0, ACCESS
2ECE  37AB     RLCF _u, F, BANKED
2ED0  37AC     RLCF fp, F, BANKED
2ED2  37AD     RLCF 0xAD, F, BANKED
2ED4  37AE     RLCF fmt, F, BANKED
276:           				expon--;
2ED6  07A7     DECF expon, F, BANKED
2ED8  A0D8     BTFSS STATUS, 0, ACCESS
2EDA  07A8     DECF 0xA8, F, BANKED
277:           		}
2EDC  AFAE     BTFSS fmt, 7, BANKED
2EDE  D7F6     BRA 0x2ECC
278:           		// handle denorms
279:           #ifdef __XC8__
280:           		if (expon <= -126) {
2EE0  AFA8     BTFSS 0xA8, 7, BANKED
2EE2  D012     BRA 0x2F08
2EE4  0E83     MOVLW 0x83
2EE6  5DA7     SUBWF expon, W, BANKED
2EE8  0EFF     MOVLW 0xFF
2EEA  59A8     SUBWFB 0xA8, W, BANKED
2EEC  B0D8     BTFSC STATUS, 0, ACCESS
2EEE  D00C     BRA 0x2F08
281:           			expon = -127;
2EF0  0EFF     MOVLW 0xFF
2EF2  6FA8     MOVWF 0xA8, BANKED
2EF4  0E81     MOVLW 0x81
2EF6  6FA7     MOVWF expon, BANKED
282:           			v = 0;
2EF8  0E00     MOVLW 0x0
2EFA  6FAB     MOVWF _u, BANKED
2EFC  0E00     MOVLW 0x0
2EFE  6FAC     MOVWF fp, BANKED
2F00  0E00     MOVLW 0x0
2F02  6FAD     MOVWF 0xAD, BANKED
2F04  0E00     MOVLW 0x0
2F06  6FAE     MOVWF fmt, BANKED
283:           		}
284:           #else
285:           		if (expon <= -126) {
286:           			while (expon <= -127 && v != 0 ) {
287:           				expon++;
288:           				v >>= 1;
289:           			}
290:           			expon = -127;
291:           		}
292:           #endif
293:           		// normalize
294:           		if (expon != -127) {
2F08  0E81     MOVLW 0x81
2F0A  19A7     XORWF expon, W, BANKED
2F0C  E103     BNZ 0x2F14
2F0E  29A8     INCF 0xA8, W, BANKED
2F10  B4D8     BTFSC STATUS, 2, ACCESS
2F12  D008     BRA 0x2F24
295:           			v <<= 1;
2F14  90D8     BCF STATUS, 0, ACCESS
2F16  37AB     RLCF _u, F, BANKED
2F18  37AC     RLCF fp, F, BANKED
2F1A  37AD     RLCF 0xAD, F, BANKED
2F1C  37AE     RLCF fmt, F, BANKED
296:           			expon--;
2F1E  07A7     DECF expon, F, BANKED
2F20  A0D8     BTFSS STATUS, 0, ACCESS
2F22  07A8     DECF 0xA8, F, BANKED
297:           		}
298:           		// got an inifinity?
299:           		if (expon > 127) {
2F24  BFA8     BTFSC 0xA8, 7, BANKED
2F26  D012     BRA 0x2F4C
2F28  51A8     MOVF 0xA8, W, BANKED
2F2A  E104     BNZ 0x2F34
2F2C  0E80     MOVLW 0x80
2F2E  5DA7     SUBWF expon, W, BANKED
2F30  A0D8     BTFSS STATUS, 0, ACCESS
2F32  D00C     BRA 0x2F4C
300:           			v = 0;
2F34  0E00     MOVLW 0x0
2F36  6FAB     MOVWF _u, BANKED
2F38  0E00     MOVLW 0x0
2F3A  6FAC     MOVWF fp, BANKED
2F3C  0E00     MOVLW 0x0
2F3E  6FAD     MOVWF 0xAD, BANKED
2F40  0E00     MOVLW 0x0
2F42  6FAE     MOVWF fmt, BANKED
301:           			expon = 128;
2F44  0E00     MOVLW 0x0
2F46  6FA8     MOVWF 0xA8, BANKED
2F48  0E80     MOVLW 0x80
2F4A  6FA7     MOVWF expon, BANKED
302:           		}
303:           		// assemble float
304:           		v >>= 9;
2F4C  0E09     MOVLW 0x9
2F4E  6F8E     MOVWF 0x8E, BANKED
2F50  90D8     BCF STATUS, 0, ACCESS
2F52  33AE     RRCF fmt, F, BANKED
2F54  33AD     RRCF 0xAD, F, BANKED
2F56  33AC     RRCF fp, F, BANKED
2F58  33AB     RRCF _u, F, BANKED
2F5A  2F8E     DECFSZ 0x8E, F, BANKED
2F5C  D7F9     BRA 0x2F50
305:           		v &= INT32_C(0x7FFFFF);
2F5E  0EFF     MOVLW 0xFF
2F60  17AB     ANDWF _u, F, BANKED
2F62  0EFF     MOVLW 0xFF
2F64  17AC     ANDWF fp, F, BANKED
2F66  0E7F     MOVLW 0x7F
2F68  17AD     ANDWF 0xAD, F, BANKED
2F6A  0E00     MOVLW 0x0
2F6C  17AE     ANDWF fmt, F, BANKED
306:           		v |= (int32_t)((expon+127) & 0xFF) << 23;
2F6E  0E7F     MOVLW 0x7F
2F70  25A7     ADDWF expon, W, BANKED
2F72  6F8E     MOVWF 0x8E, BANKED
2F74  0E00     MOVLW 0x0
2F76  21A8     ADDWFC 0xA8, W, BANKED
2F78  6F8F     MOVWF 0x8F, BANKED
2F7A  0EFF     MOVLW 0xFF
2F7C  158E     ANDWF 0x8E, W, BANKED
2F7E  6F90     MOVWF 0x90, BANKED
2F80  6B91     CLRF cp, BANKED
2F82  6B92     CLRF 0x92, BANKED
2F84  6B93     CLRF done, BANKED
2F86  0E17     MOVLW 0x17
2F88  90D8     BCF STATUS, 0, ACCESS
2F8A  3790     RLCF 0x90, F, BANKED
2F8C  3791     RLCF cp, F, BANKED
2F8E  3792     RLCF 0x92, F, BANKED
2F90  3793     RLCF done, F, BANKED
2F92  2EE8     DECFSZ WREG, F, ACCESS
2F94  D7F9     BRA 0x2F88
2F96  5190     MOVF 0x90, W, BANKED
2F98  13AB     IORWF _u, F, BANKED
2F9A  5191     MOVF cp, W, BANKED
2F9C  13AC     IORWF fp, F, BANKED
2F9E  5192     MOVF 0x92, W, BANKED
2FA0  13AD     IORWF 0xAD, F, BANKED
2FA2  5193     MOVF done, W, BANKED
2FA4  13AE     IORWF fmt, F, BANKED
307:           		goto exit_strtof;
2FA6  D275     BRA 0x3492
308:           	}
309:           
310:           	for(;;) {
311:           		if(!(flags & DOTSEEN) && *s == '.') {
2FA8  B9A6     BTFSC flags, 4, BANKED
2FAA  D00A     BRA 0x2FC0
2FAC  C08A     MOVFF s, FSR2
2FAE  FFD9     NOP
2FB0  C08B     MOVFF ap, FSR2H
2FB2  FFDA     NOP
2FB4  0E2E     MOVLW 0x2E
2FB6  18DE     XORWF POSTINC2, W, ACCESS
2FB8  A4D8     BTFSS STATUS, 2, ACCESS
2FBA  D002     BRA 0x2FC0
312:           			flags |= DOTSEEN;		/* If into decimal set flag */
2FBC  89A6     BSF flags, 4, BANKED
2FBE  D05A     BRA 0x3074
313:           			s++;				
314:           			continue;
315:           		}
316:           		if(!isdigit(*s))			/* If end of valid sequence end */
2FC0  0ED0     MOVLW 0xD0
2FC2  6F8E     MOVWF 0x8E, BANKED
2FC4  0EFF     MOVLW 0xFF
2FC6  6F8F     MOVWF 0x8F, BANKED
2FC8  C08A     MOVFF s, FSR2
2FCA  FFD9     NOP
2FCC  C08B     MOVFF ap, FSR2H
2FCE  FFDA     NOP
2FD0  50DF     MOVF INDF2, W, ACCESS
2FD2  6F90     MOVWF 0x90, BANKED
2FD4  6B91     CLRF cp, BANKED
2FD6  518E     MOVF 0x8E, W, BANKED
2FD8  2790     ADDWF 0x90, F, BANKED
2FDA  518F     MOVF 0x8F, W, BANKED
2FDC  2391     ADDWFC cp, F, BANKED
2FDE  5191     MOVF cp, W, BANKED
2FE0  E106     BNZ 0x2FEE
2FE2  0E0A     MOVLW 0xA
2FE4  5D90     SUBWF 0x90, W, BANKED
2FE6  B0D8     BTFSC STATUS, 0, ACCESS
2FE8  D002     BRA 0x2FEE
2FEA  0E01     MOVLW 0x1
2FEC  D001     BRA 0x2FF0
2FEE  0E00     MOVLW 0x0
2FF0  6F9C     MOVWF 0x9C, BANKED
2FF2  6B9D     CLRF 0x9D, BANKED
2FF4  0100     MOVLB 0x0
2FF6  519C     MOVF 0x9C, W, BANKED
2FF8  119D     IORWF 0x9D, W, BANKED
2FFA  B4D8     BTFSC STATUS, 2, ACCESS
2FFC  D03E     BRA 0x307A
317:           			break;				
318:           		flags |= DIGSEEN;			/* else set flag */
2FFE  83A6     BSF flags, 1, BANKED
319:           		if(eexp != NDIG) {
3000  0E09     MOVLW 0x9
3002  19A9     XORWF eexp, W, BANKED
3004  11AA     IORWF 0xAA, W, BANKED
3006  B4D8     BTFSC STATUS, 2, ACCESS
3008  D031     BRA 0x306C
320:           			if(flags & DOTSEEN)		/* Count decimal  places */
300A  A9A6     BTFSS flags, 4, BANKED
300C  D003     BRA 0x3014
321:           				expon--;
300E  07A7     DECF expon, F, BANKED
3010  A0D8     BTFSS STATUS, 0, ACCESS
3012  07A8     DECF 0xA8, F, BANKED
322:           			eexp++;
3014  4BA9     INFSNZ eexp, F, BANKED
3016  2BAA     INCF 0xAA, F, BANKED
323:           			v *= 10;
3018  C0AB     MOVFF _u, dividend
301A  F015     NOP
301C  C0AC     MOVFF fp, Message
301E  F016     NOP
3020  C0AD     MOVFF 0xAD, _r
3022  F017     NOP
3024  C0AE     MOVFF fmt, 0x18
3026  F018     NOP
3028  0E0A     MOVLW 0xA
302A  6E19     MOVWF multiplicand, ACCESS
302C  0E00     MOVLW 0x0
302E  6E1A     MOVWF s, ACCESS
3030  0E00     MOVLW 0x0
3032  6E1B     MOVWF c, ACCESS
3034  0E00     MOVLW 0x0
3036  6E1C     MOVWF c, ACCESS
3038  ECAD     CALL 0x5F5A, 0
303A  F02F     NOP
303C  C015     MOVFF dividend, _u
303E  F0AB     NOP
3040  C016     MOVFF Message, fp
3042  F0AC     NOP
3044  C017     MOVFF _r, 0xAD
3046  F0AD     NOP
3048  C018     MOVFF 0x18, fmt
304A  F0AE     NOP
324:           			v += (unsigned char)(*s - '0');	/* Convert digits to integer part */
304C  C08A     MOVFF s, FSR2
304E  FFD9     NOP
3050  C08B     MOVFF ap, FSR2H
3052  FFDA     NOP
3054  50DF     MOVF INDF2, W, ACCESS
3056  0100     MOVLB 0x0
3058  6F8E     MOVWF 0x8E, BANKED
305A  0ED0     MOVLW 0xD0
305C  278E     ADDWF 0x8E, F, BANKED
305E  518E     MOVF 0x8E, W, BANKED
3060  27AB     ADDWF _u, F, BANKED
3062  0E00     MOVLW 0x0
3064  23AC     ADDWFC fp, F, BANKED
3066  23AD     ADDWFC 0xAD, F, BANKED
3068  23AE     ADDWFC fmt, F, BANKED
325:           		} else if(!(flags & DOTSEEN))
306A  D004     BRA 0x3074
306C  B9A6     BTFSC flags, 4, BANKED
306E  D002     BRA 0x3074
326:           			expon++;
3070  4BA7     INFSNZ expon, F, BANKED
3072  2BA8     INCF 0xA8, F, BANKED
327:           		s++;
3074  4B8A     INFSNZ s, F, BANKED
3076  2B8B     INCF ap, F, BANKED
328:           	}
3078  D797     BRA 0x2FA8
329:           	
330:           	eexp = 0;						/* Zero users exponent */
307A  0E00     MOVLW 0x0
307C  6FAA     MOVWF 0xAA, BANKED
307E  0E00     MOVLW 0x0
3080  6FA9     MOVWF eexp, BANKED
331:           	if(*s == 'e' || *s == 'E') {	/* Look at exponent */
3082  C08A     MOVFF s, FSR2
3084  FFD9     NOP
3086  C08B     MOVFF ap, FSR2H
3088  FFDA     NOP
308A  0E65     MOVLW 0x65
308C  18DE     XORWF POSTINC2, W, ACCESS
308E  B4D8     BTFSC STATUS, 2, ACCESS
3090  D008     BRA 0x30A2
3092  C08A     MOVFF s, FSR2
3094  FFD9     NOP
3096  C08B     MOVFF ap, FSR2H
3098  FFDA     NOP
309A  0E45     MOVLW 0x45
309C  18DE     XORWF POSTINC2, W, ACCESS
309E  A4D8     BTFSS STATUS, 2, ACCESS
30A0  D0C2     BRA 0x3226
332:           		if(*++s == '-') {			/* Check sign */
30A2  4B8A     INFSNZ s, F, BANKED
30A4  2B8B     INCF ap, F, BANKED
30A6  C08A     MOVFF s, FSR2
30A8  FFD9     NOP
30AA  C08B     MOVFF ap, FSR2H
30AC  FFDA     NOP
30AE  0E2D     MOVLW 0x2D
30B0  18DE     XORWF POSTINC2, W, ACCESS
30B2  A4D8     BTFSS STATUS, 2, ACCESS
30B4  D002     BRA 0x30BA
333:           			flags |= EXPNEG;
30B6  87A6     BSF flags, 3, BANKED
30B8  D008     BRA 0x30CA
334:           			s++;
335:           		} else if(*s == '+')
30BA  C08A     MOVFF s, FSR2
30BC  FFD9     NOP
30BE  C08B     MOVFF ap, FSR2H
30C0  FFDA     NOP
30C2  0E2B     MOVLW 0x2B
30C4  18DE     XORWF POSTINC2, W, ACCESS
30C6  A4D8     BTFSS STATUS, 2, ACCESS
30C8  D002     BRA 0x30CE
336:           			s++;
337:           		while(*s=='0')s++;		/* Skip leading zeros */
30CA  4B8A     INFSNZ s, F, BANKED
30CC  2B8B     INCF ap, F, BANKED
30CE  C08A     MOVFF s, FSR2
30D0  FFD9     NOP
30D2  C08B     MOVFF ap, FSR2H
30D4  FFDA     NOP
30D6  0E30     MOVLW 0x30
30D8  18DE     XORWF POSTINC2, W, ACCESS
30DA  B4D8     BTFSC STATUS, 2, ACCESS
30DC  D7F6     BRA 0x30CA
338:           		if(isdigit(*s)) {		/* Read three digits */
30DE  0ED0     MOVLW 0xD0
30E0  6F8E     MOVWF 0x8E, BANKED
30E2  0EFF     MOVLW 0xFF
30E4  6F8F     MOVWF 0x8F, BANKED
30E6  C08A     MOVFF s, FSR2
30E8  FFD9     NOP
30EA  C08B     MOVFF ap, FSR2H
30EC  FFDA     NOP
30EE  50DF     MOVF INDF2, W, ACCESS
30F0  6F90     MOVWF 0x90, BANKED
30F2  6B91     CLRF cp, BANKED
30F4  518E     MOVF 0x8E, W, BANKED
30F6  2790     ADDWF 0x90, F, BANKED
30F8  518F     MOVF 0x8F, W, BANKED
30FA  2391     ADDWFC cp, F, BANKED
30FC  5191     MOVF cp, W, BANKED
30FE  E106     BNZ 0x310C
3100  0E0A     MOVLW 0xA
3102  5D90     SUBWF 0x90, W, BANKED
3104  B0D8     BTFSC STATUS, 0, ACCESS
3106  D002     BRA 0x310C
3108  0E01     MOVLW 0x1
310A  D001     BRA 0x310E
310C  0E00     MOVLW 0x0
310E  6F9E     MOVWF 0x9E, BANKED
3110  6B9F     CLRF 0x9F, BANKED
3112  0100     MOVLB 0x0
3114  519E     MOVF 0x9E, W, BANKED
3116  119F     IORWF 0x9F, W, BANKED
3118  B4D8     BTFSC STATUS, 2, ACCESS
311A  D07F     BRA 0x321A
339:           			eexp = (unsigned char)(*s++ - '0');
311C  C08A     MOVFF s, FSR2
311E  FFD9     NOP
3120  C08B     MOVFF ap, FSR2H
3122  FFDA     NOP
3124  50DF     MOVF INDF2, W, ACCESS
3126  6F8E     MOVWF 0x8E, BANKED
3128  0ED0     MOVLW 0xD0
312A  278E     ADDWF 0x8E, F, BANKED
312C  518E     MOVF 0x8E, W, BANKED
312E  6FA9     MOVWF eexp, BANKED
3130  6BAA     CLRF 0xAA, BANKED
3132  4B8A     INFSNZ s, F, BANKED
3134  2B8B     INCF ap, F, BANKED
340:           			if(isdigit(*s)) {
3136  0ED0     MOVLW 0xD0
3138  6F8E     MOVWF 0x8E, BANKED
313A  0EFF     MOVLW 0xFF
313C  6F8F     MOVWF 0x8F, BANKED
313E  C08A     MOVFF s, FSR2
3140  FFD9     NOP
3142  C08B     MOVFF ap, FSR2H
3144  FFDA     NOP
3146  50DF     MOVF INDF2, W, ACCESS
3148  6F90     MOVWF 0x90, BANKED
314A  6B91     CLRF cp, BANKED
314C  518E     MOVF 0x8E, W, BANKED
314E  2790     ADDWF 0x90, F, BANKED
3150  518F     MOVF 0x8F, W, BANKED
3152  2391     ADDWFC cp, F, BANKED
3154  5191     MOVF cp, W, BANKED
3156  E106     BNZ 0x3164
3158  0E0A     MOVLW 0xA
315A  5D90     SUBWF 0x90, W, BANKED
315C  B0D8     BTFSC STATUS, 0, ACCESS
315E  D002     BRA 0x3164
3160  0E01     MOVLW 0x1
3162  D001     BRA 0x3166
3164  0E00     MOVLW 0x0
3166  6FA0     MOVWF 0xA0, BANKED
3168  6BA1     CLRF vp, BANKED
316A  0100     MOVLB 0x0
316C  51A0     MOVF 0xA0, W, BANKED
316E  11A1     IORWF vp, W, BANKED
3170  B4D8     BTFSC STATUS, 2, ACCESS
3172  D053     BRA 0x321A
341:           				eexp = eexp*10 + (unsigned char)(*s++ - '0');
3174  C08A     MOVFF s, FSR2
3176  FFD9     NOP
3178  C08B     MOVFF ap, FSR2H
317A  FFDA     NOP
317C  50DF     MOVF INDF2, W, ACCESS
317E  6F8E     MOVWF 0x8E, BANKED
3180  0ED0     MOVLW 0xD0
3182  278E     ADDWF 0x8E, F, BANKED
3184  C0A9     MOVFF eexp, dividend
3186  F015     NOP
3188  C0AA     MOVFF 0xAA, Message
318A  F016     NOP
318C  0E00     MOVLW 0x0
318E  6E18     MOVWF 0x18, ACCESS
3190  0E0A     MOVLW 0xA
3192  6E17     MOVWF _r, ACCESS
3194  EC57     CALL 0x68AE, 0
3196  F034     NOP
3198  0100     MOVLB 0x0
319A  518E     MOVF 0x8E, W, BANKED
319C  2415     ADDWF dividend, W, ACCESS
319E  6FA9     MOVWF eexp, BANKED
31A0  0E00     MOVLW 0x0
31A2  2016     ADDWFC Message, W, ACCESS
31A4  6FAA     MOVWF 0xAA, BANKED
31A6  4B8A     INFSNZ s, F, BANKED
31A8  2B8B     INCF ap, F, BANKED
342:           				if(isdigit(*s))
31AA  0ED0     MOVLW 0xD0
31AC  6F8E     MOVWF 0x8E, BANKED
31AE  0EFF     MOVLW 0xFF
31B0  6F8F     MOVWF 0x8F, BANKED
31B2  C08A     MOVFF s, FSR2
31B4  FFD9     NOP
31B6  C08B     MOVFF ap, FSR2H
31B8  FFDA     NOP
31BA  50DF     MOVF INDF2, W, ACCESS
31BC  6F90     MOVWF 0x90, BANKED
31BE  6B91     CLRF cp, BANKED
31C0  518E     MOVF 0x8E, W, BANKED
31C2  2790     ADDWF 0x90, F, BANKED
31C4  518F     MOVF 0x8F, W, BANKED
31C6  2391     ADDWFC cp, F, BANKED
31C8  5191     MOVF cp, W, BANKED
31CA  E106     BNZ 0x31D8
31CC  0E0A     MOVLW 0xA
31CE  5D90     SUBWF 0x90, W, BANKED
31D0  B0D8     BTFSC STATUS, 0, ACCESS
31D2  D002     BRA 0x31D8
31D4  0E01     MOVLW 0x1
31D6  D001     BRA 0x31DA
31D8  0E00     MOVLW 0x0
31DA  6FA2     MOVWF 0xA2, BANKED
31DC  6BA3     CLRF c, BANKED
31DE  0100     MOVLB 0x0
31E0  51A2     MOVF 0xA2, W, BANKED
31E2  11A3     IORWF c, W, BANKED
31E4  B4D8     BTFSC STATUS, 2, ACCESS
31E6  D019     BRA 0x321A
343:           					eexp = eexp*10 + (unsigned char)(*s - '0');
31E8  C08A     MOVFF s, FSR2
31EA  FFD9     NOP
31EC  C08B     MOVFF ap, FSR2H
31EE  FFDA     NOP
31F0  50DF     MOVF INDF2, W, ACCESS
31F2  6F8E     MOVWF 0x8E, BANKED
31F4  0ED0     MOVLW 0xD0
31F6  278E     ADDWF 0x8E, F, BANKED
31F8  C0A9     MOVFF eexp, dividend
31FA  F015     NOP
31FC  C0AA     MOVFF 0xAA, Message
31FE  F016     NOP
3200  0E00     MOVLW 0x0
3202  6E18     MOVWF 0x18, ACCESS
3204  0E0A     MOVLW 0xA
3206  6E17     MOVWF _r, ACCESS
3208  EC57     CALL 0x68AE, 0
320A  F034     NOP
320C  0100     MOVLB 0x0
320E  518E     MOVF 0x8E, W, BANKED
3210  2415     ADDWF dividend, W, ACCESS
3212  6FA9     MOVWF eexp, BANKED
3214  0E00     MOVLW 0x0
3216  2016     ADDWFC Message, W, ACCESS
3218  6FAA     MOVWF 0xAA, BANKED
344:           			}
345:           		}
346:           		if(flags & EXPNEG)
321A  A7A6     BTFSS flags, 3, BANKED
321C  D004     BRA 0x3226
347:           			eexp = -eexp;
321E  6DA9     NEGF eexp, BANKED
3220  1FAA     COMF 0xAA, F, BANKED
3222  B0D8     BTFSC STATUS, 0, ACCESS
3224  2BAA     INCF 0xAA, F, BANKED
348:           	}
349:           	expon += eexp;			/* Add user and integer exponents */
3226  51A9     MOVF eexp, W, BANKED
3228  27A7     ADDWF expon, F, BANKED
322A  51AA     MOVF 0xAA, W, BANKED
322C  23A8     ADDWFC 0xA8, F, BANKED
350:           
351:           	if(res && flags & DIGSEEN)
322E  518C     MOVF res, W, BANKED
3230  118D     IORWF 0x8D, W, BANKED
3232  A4D8     BTFSS STATUS, 2, ACCESS
3234  A3A6     BTFSS flags, 1, BANKED
3236  D008     BRA 0x3248
352:           		*res = (char*) s;
3238  C08C     MOVFF res, FSR2
323A  FFD9     NOP
323C  C08D     MOVFF 0x8D, FSR2H
323E  FFDA     NOP
3240  C08A     MOVFF s, POSTINC2
3242  FFDE     NOP
3244  C08B     MOVFF ap, POSTDEC2
3246  FFDD     NOP
353:           	l = (float)v;			/* Convert the integer component to a float */ 
3248  C0AB     MOVFF _u, dividend
324A  F015     NOP
324C  C0AC     MOVFF fp, Message
324E  F016     NOP
3250  C0AD     MOVFF 0xAD, _r
3252  F017     NOP
3254  C0AE     MOVFF fmt, 0x18
3256  F018     NOP
3258  0E00     MOVLW 0x0
325A  ECDD     CALL 0x4DBA, 0
325C  F026     NOP
325E  C015     MOVFF dividend, _u
3260  F0AB     NOP
3262  C016     MOVFF Message, fp
3264  F0AC     NOP
3266  C017     MOVFF _r, 0xAD
3268  F0AD     NOP
326A  C018     MOVFF 0x18, fmt
326C  F0AE     NOP
354:           	if(l == 0.0)			/* simply return zero */
326E  C0AB     MOVFF _u, dividend
3270  F015     NOP
3272  C0AC     MOVFF fp, Message
3274  F016     NOP
3276  C0AD     MOVFF 0xAD, _r
3278  F017     NOP
327A  C0AE     MOVFF fmt, 0x18
327C  F018     NOP
327E  0E00     MOVLW 0x0
3280  6E19     MOVWF multiplicand, ACCESS
3282  0E00     MOVLW 0x0
3284  6E1A     MOVWF s, ACCESS
3286  0E00     MOVLW 0x0
3288  6E1B     MOVWF c, ACCESS
328A  0E00     MOVLW 0x0
328C  6E1C     MOVWF c, ACCESS
328E  EC76     CALL 0x5CEC, 0
3290  F02E     NOP
3292  A0D8     BTFSS STATUS, 0, ACCESS
3294  D00A     BRA 0x32AA
355:           		return 0.0;
3296  0E00     MOVLW 0x0
3298  0100     MOVLB 0x0
329A  6F8A     MOVWF s, BANKED
329C  0E00     MOVLW 0x0
329E  6F8B     MOVWF ap, BANKED
32A0  0E00     MOVLW 0x0
32A2  6F8C     MOVWF res, BANKED
32A4  0E00     MOVLW 0x0
32A6  6F8D     MOVWF 0x8D, BANKED
32A8  0012     RETURN 0
356:           	if(expon < 0) {
32AA  0100     MOVLB 0x0
32AC  AFA8     BTFSS 0xA8, 7, BANKED
32AE  D078     BRA 0x33A0
357:           		expon = -expon;
32B0  6DA7     NEGF expon, BANKED
32B2  1FA8     COMF 0xA8, F, BANKED
32B4  B0D8     BTFSC STATUS, 0, ACCESS
32B6  2BA8     INCF 0xA8, F, BANKED
358:           #if	FLT_MAX_10_EXP >= 100
359:           		while(expon >= 100) {
360:           			l /= 1e+100;
361:           			expon -= 100;
362:           		}
363:           #endif
364:           #ifdef	SMALLCODE
365:           		while(expon >= 10) {
32B8  D01F     BRA 0x32F8
366:           			l /= 1e+10;
32BA  C0AB     MOVFF _u, b
32BC  F071     NOP
32BE  C0AC     MOVFF fp, p
32C0  F072     NOP
32C2  C0AD     MOVFF 0xAD, 0x73
32C4  F073     NOP
32C6  C0AE     MOVFF fmt, w
32C8  F074     NOP
32CA  0EF9     MOVLW 0xF9
32CC  6F75     MOVWF a, BANKED
32CE  0E02     MOVLW 0x2
32D0  6F76     MOVWF n, BANKED
32D2  0E15     MOVLW 0x15
32D4  6F77     MOVWF p, BANKED
32D6  0E50     MOVLW 0x50
32D8  6F78     MOVWF n, BANKED
32DA  EC71     CALL 0x3EE2, 0
32DC  F01F     NOP
32DE  C071     MOVFF b, _u
32E0  F0AB     NOP
32E2  C072     MOVFF p, fp
32E4  F0AC     NOP
32E6  C073     MOVFF 0x73, 0xAD
32E8  F0AD     NOP
32EA  C074     MOVFF w, fmt
32EC  F0AE     NOP
367:           			expon -= 10;
32EE  0100     MOVLB 0x0
32F0  0EF6     MOVLW 0xF6
32F2  27A7     ADDWF expon, F, BANKED
32F4  0EFF     MOVLW 0xFF
32F6  23A8     ADDWFC 0xA8, F, BANKED
368:           		}
32F8  BFA8     BTFSC 0xA8, 7, BANKED
32FA  D025     BRA 0x3346
32FC  51A8     MOVF 0xA8, W, BANKED
32FE  E1DD     BNZ 0x32BA
3300  0E0A     MOVLW 0xA
3302  5DA7     SUBWF expon, W, BANKED
3304  A0D8     BTFSS STATUS, 0, ACCESS
3306  D01F     BRA 0x3346
3308  D7D8     BRA 0x32BA
369:           		while(expon != 0) {
370:           			l /= 1e+1;
330A  C0AB     MOVFF _u, b
330C  F071     NOP
330E  C0AC     MOVFF fp, p
3310  F072     NOP
3312  C0AD     MOVFF 0xAD, 0x73
3314  F073     NOP
3316  C0AE     MOVFF fmt, w
3318  F074     NOP
331A  0E00     MOVLW 0x0
331C  6F75     MOVWF a, BANKED
331E  0E00     MOVLW 0x0
3320  6F76     MOVWF n, BANKED
3322  0E20     MOVLW 0x20
3324  6F77     MOVWF p, BANKED
3326  0E41     MOVLW 0x41
3328  6F78     MOVWF n, BANKED
332A  EC71     CALL 0x3EE2, 0
332C  F01F     NOP
332E  C071     MOVFF b, _u
3330  F0AB     NOP
3332  C072     MOVFF p, fp
3334  F0AC     NOP
3336  C073     MOVFF 0x73, 0xAD
3338  F0AD     NOP
333A  C074     MOVFF w, fmt
333C  F0AE     NOP
371:           			expon--;
333E  0100     MOVLB 0x0
3340  07A7     DECF expon, F, BANKED
3342  A0D8     BTFSS STATUS, 0, ACCESS
3344  07A8     DECF 0xA8, F, BANKED
372:           		}
3346  51A7     MOVF expon, W, BANKED
3348  11A8     IORWF 0xA8, W, BANKED
334A  A4D8     BTFSS STATUS, 2, ACCESS
334C  D7DE     BRA 0x330A
373:           #else
374:           		if(expon >= 10) {
375:           			l /= _powers_[expon/10+9];
376:           			expon %= 10;
377:           		}
378:           		if(expon)
379:           			l /= _powers_[expon];
380:           #endif	/* SMALLCODE */
381:           		if(l < FLT_MIN) {
334E  C0AB     MOVFF _u, dividend
3350  F015     NOP
3352  C0AC     MOVFF fp, Message
3354  F016     NOP
3356  C0AD     MOVFF 0xAD, _r
3358  F017     NOP
335A  C0AE     MOVFF fmt, 0x18
335C  F018     NOP
335E  0E00     MOVLW 0x0
3360  6E19     MOVWF multiplicand, ACCESS
3362  0E00     MOVLW 0x0
3364  6E1A     MOVWF s, ACCESS
3366  0E80     MOVLW 0x80
3368  6E1B     MOVWF c, ACCESS
336A  0E00     MOVLW 0x0
336C  6E1C     MOVWF c, ACCESS
336E  EC44     CALL 0x5288, 0
3370  F029     NOP
3372  B0D8     BTFSC STATUS, 0, ACCESS
3374  D08E     BRA 0x3492
382:           			if(flags & ISNEG)
3376  0100     MOVLB 0x0
3378  A1A6     BTFSS flags, 0, BANKED
337A  D009     BRA 0x338E
383:           				return -FLT_MIN;
337C  0E00     MOVLW 0x0
337E  6F8A     MOVWF s, BANKED
3380  0E00     MOVLW 0x0
3382  6F8B     MOVWF ap, BANKED
3384  0E80     MOVLW 0x80
3386  6F8C     MOVWF res, BANKED
3388  0E80     MOVLW 0x80
338A  6F8D     MOVWF 0x8D, BANKED
338C  0012     RETURN 0
384:           			return FLT_MIN;
338E  0E00     MOVLW 0x0
3390  6F8A     MOVWF s, BANKED
3392  0E00     MOVLW 0x0
3394  6F8B     MOVWF ap, BANKED
3396  0E80     MOVLW 0x80
3398  6F8C     MOVWF res, BANKED
339A  0E00     MOVLW 0x0
339C  6F8D     MOVWF 0x8D, BANKED
339E  0012     RETURN 0
385:           		}
386:           	} else if(expon > 0) {
33A0  BFA8     BTFSC 0xA8, 7, BANKED
33A2  D077     BRA 0x3492
33A4  51A8     MOVF 0xA8, W, BANKED
33A6  E123     BNZ 0x33EE
33A8  05A7     DECF expon, W, BANKED
33AA  B0D8     BTFSC STATUS, 0, ACCESS
33AC  D020     BRA 0x33EE
33AE  D071     BRA 0x3492
387:           #if	FLT_MAX_10_EXP >= 100
388:           		while(expon >= 100) {
389:           			l *= 1e100;
390:           			expon -= 100;
391:           		}
392:           #endif
393:           #ifdef	SMALLCODE
394:           		while((unsigned int)expon >= 10) {
395:           			l *= 1e10;
33B0  C0AB     MOVFF _u, counter
33B2  F02D     NOP
33B4  C0AC     MOVFF fp, w
33B6  F02E     NOP
33B8  C0AD     MOVFF 0xAD, 0x2F
33BA  F02F     NOP
33BC  C0AE     MOVFF fmt, cp
33BE  F030     NOP
33C0  0EF9     MOVLW 0xF9
33C2  6E31     MOVWF a, ACCESS
33C4  0E02     MOVLW 0x2
33C6  6E32     MOVWF p, ACCESS
33C8  0E15     MOVLW 0x15
33CA  6E33     MOVWF 0x33, ACCESS
33CC  0E50     MOVLW 0x50
33CE  6E34     MOVWF l, ACCESS
33D0  EC2B     CALL 0x3856, 0
33D2  F01C     NOP
33D4  C02D     MOVFF counter, _u
33D6  F0AB     NOP
33D8  C02E     MOVFF w, fp
33DA  F0AC     NOP
33DC  C02F     MOVFF 0x2F, 0xAD
33DE  F0AD     NOP
33E0  C030     MOVFF cp, fmt
33E2  F0AE     NOP
396:           			expon -= 10;
33E4  0100     MOVLB 0x0
33E6  0EF6     MOVLW 0xF6
33E8  27A7     ADDWF expon, F, BANKED
33EA  0EFF     MOVLW 0xFF
33EC  23A8     ADDWFC 0xA8, F, BANKED
397:           		}
33EE  51A8     MOVF 0xA8, W, BANKED
33F0  E1DF     BNZ 0x33B0
33F2  0E0A     MOVLW 0xA
33F4  5DA7     SUBWF expon, W, BANKED
33F6  A0D8     BTFSS STATUS, 0, ACCESS
33F8  D01F     BRA 0x3438
33FA  D7DA     BRA 0x33B0
398:           		while(expon != 0) {
399:           			l *= 1e1;
33FC  C0AB     MOVFF _u, counter
33FE  F02D     NOP
3400  C0AC     MOVFF fp, w
3402  F02E     NOP
3404  C0AD     MOVFF 0xAD, 0x2F
3406  F02F     NOP
3408  C0AE     MOVFF fmt, cp
340A  F030     NOP
340C  0E00     MOVLW 0x0
340E  6E31     MOVWF a, ACCESS
3410  0E00     MOVLW 0x0
3412  6E32     MOVWF p, ACCESS
3414  0E20     MOVLW 0x20
3416  6E33     MOVWF 0x33, ACCESS
3418  0E41     MOVLW 0x41
341A  6E34     MOVWF l, ACCESS
341C  EC2B     CALL 0x3856, 0
341E  F01C     NOP
3420  C02D     MOVFF counter, _u
3422  F0AB     NOP
3424  C02E     MOVFF w, fp
3426  F0AC     NOP
3428  C02F     MOVFF 0x2F, 0xAD
342A  F0AD     NOP
342C  C030     MOVFF cp, fmt
342E  F0AE     NOP
400:           			expon--;
3430  0100     MOVLB 0x0
3432  07A7     DECF expon, F, BANKED
3434  A0D8     BTFSS STATUS, 0, ACCESS
3436  07A8     DECF 0xA8, F, BANKED
401:           		}
3438  51A7     MOVF expon, W, BANKED
343A  11A8     IORWF 0xA8, W, BANKED
343C  A4D8     BTFSS STATUS, 2, ACCESS
343E  D7DE     BRA 0x33FC
402:           #else
403:           		if(expon >= 10) {
404:           			l *= _powers_[expon/10+9];
405:           			expon %= 10;
406:           		}
407:           		if(expon)
408:           			l *= _powers_[expon];
409:           #endif	/* SMALLCODE */
410:           		if(l > FLT_MAX) {
3440  0EFF     MOVLW 0xFF
3442  6E15     MOVWF dividend, ACCESS
3444  0EFF     MOVLW 0xFF
3446  6E16     MOVWF Message, ACCESS
3448  0E7F     MOVLW 0x7F
344A  6E17     MOVWF _r, ACCESS
344C  0E7F     MOVLW 0x7F
344E  6E18     MOVWF 0x18, ACCESS
3450  C0AB     MOVFF _u, multiplicand
3452  F019     NOP
3454  C0AC     MOVFF fp, s
3456  F01A     NOP
3458  C0AD     MOVFF 0xAD, c
345A  F01B     NOP
345C  C0AE     MOVFF fmt, c
345E  F01C     NOP
3460  EC44     CALL 0x5288, 0
3462  F029     NOP
3464  B0D8     BTFSC STATUS, 0, ACCESS
3466  D015     BRA 0x3492
411:           			if(flags & ISNEG)
3468  0100     MOVLB 0x0
346A  A1A6     BTFSS flags, 0, BANKED
346C  D009     BRA 0x3480
412:           				return -FLT_MIN;
346E  0E00     MOVLW 0x0
3470  6F8A     MOVWF s, BANKED
3472  0E00     MOVLW 0x0
3474  6F8B     MOVWF ap, BANKED
3476  0E80     MOVLW 0x80
3478  6F8C     MOVWF res, BANKED
347A  0E80     MOVLW 0x80
347C  6F8D     MOVWF 0x8D, BANKED
347E  0012     RETURN 0
413:           			return FLT_MIN;
3480  0E00     MOVLW 0x0
3482  6F8A     MOVWF s, BANKED
3484  0E00     MOVLW 0x0
3486  6F8B     MOVWF ap, BANKED
3488  0E80     MOVLW 0x80
348A  6F8C     MOVWF res, BANKED
348C  0E00     MOVLW 0x0
348E  6F8D     MOVWF 0x8D, BANKED
3490  0012     RETURN 0
414:           		}
415:           	}
416:           exit_strtof:
417:           	if(flags & ISNEG)
3492  0100     MOVLB 0x0
3494  A1A6     BTFSS flags, 0, BANKED
3496  D012     BRA 0x34BC
418:           		l = -l;
3498  C0AB     MOVFF _u, dividend
349A  F015     NOP
349C  C0AC     MOVFF fp, Message
349E  F016     NOP
34A0  C0AD     MOVFF 0xAD, _r
34A2  F017     NOP
34A4  C0AE     MOVFF fmt, 0x18
34A6  F018     NOP
34A8  ECC3     CALL 0x6786, 0
34AA  F033     NOP
34AC  C015     MOVFF dividend, _u
34AE  F0AB     NOP
34B0  C016     MOVFF Message, fp
34B2  F0AC     NOP
34B4  C017     MOVFF _r, 0xAD
34B6  F0AD     NOP
34B8  C018     MOVFF 0x18, fmt
34BA  F0AE     NOP
419:           	return l;
34BC  C0AB     MOVFF _u, s
34BE  F08A     NOP
34C0  C0AC     MOVFF fp, ap
34C2  F08B     NOP
34C4  C0AD     MOVFF 0xAD, res
34C6  F08C     NOP
34C8  C0AE     MOVFF fmt, 0x8D
34CA  F08D     NOP
34CC  0012     RETURN 0
420:           }
421:           
422:           double
423:           atof(register const char * s)
424:           {
425:           	return strtod(s, 0);
6860  C0B0     MOVFF ap, s
6862  F08A     NOP
6864  C0B1     MOVFF 0xB1, ap
6866  F08B     NOP
6868  0E00     MOVLW 0x0
686A  0100     MOVLB 0x0
686C  6F8C     MOVWF res, BANKED
686E  0E00     MOVLW 0x0
6870  6F8D     MOVWF 0x8D, BANKED
6872  EC57     CALL 0x26AE, 0
6874  F013     NOP
6876  C08A     MOVFF s, ap
6878  F0B0     NOP
687A  C08B     MOVFF ap, 0xB1
687C  F0B1     NOP
687E  C08C     MOVFF res, cfmt
6880  F0B2     NOP
6882  C08D     MOVFF 0x8D, 0xB3
6884  F0B3     NOP
6886  0012     RETURN 0
426:           }
427:           
428:           #ifdef strtod
429:           #undef strtod
430:           #endif
431:           
432:           double 
433:           strtod(const char * __restrict nptr, char ** __restrict endptr)
434:           {
435:           	return strtof(nptr, endptr);
436:           }
437:           
438:           #ifdef strtold
439:           #undef strtold
440:           #endif
441:           
442:           long double 
443:           strtold(const char * __restrict nptr, char ** __restrict endptr)
444:           {
445:           	return strtof(nptr, endptr);
446:           }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strstr.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             
4:             #ifndef __XC8__
5:             
6:             static char *twobyte_strstr(const unsigned char *h, const unsigned char *n)
7:             {
8:             	uint16_t nw = n[0]<<8 | n[1], hw = h[0]<<8 | h[1];
9:             	for (h++; *h && hw != nw; hw = hw<<8 | *++h);
10:            	return *h ? (char *)h-1 : 0;
11:            }
12:            
13:            static char *threebyte_strstr(const unsigned char *h, const unsigned char *n)
14:            {
15:            	uint32_t nw = n[0]<<24 | n[1]<<16 | n[2]<<8;
16:            	uint32_t hw = h[0]<<24 | h[1]<<16 | h[2]<<8;
17:            	for (h+=2; *h && hw != nw; hw = (hw|*++h)<<8);
18:            	return *h ? (char *)h-2 : 0;
19:            }
20:            
21:            static char *fourbyte_strstr(const unsigned char *h, const unsigned char *n)
22:            {
23:            	uint32_t nw = n[0]<<24 | n[1]<<16 | n[2]<<8 | n[3];
24:            	uint32_t hw = h[0]<<24 | h[1]<<16 | h[2]<<8 | h[3];
25:            	for (h+=3; *h && hw != nw; hw = hw<<8 | *++h);
26:            	return *h ? (char *)h-3 : 0;
27:            }
28:            
29:            #define MAX(a,b) ((a)>(b)?(a):(b))
30:            #define MIN(a,b) ((a)<(b)?(a):(b))
31:            
32:            #define BITOP(a,b,op) \
33:             ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
34:            
35:            static char *twoway_strstr(const unsigned char *h, const unsigned char *n)
36:            {
37:            	const unsigned char *z;
38:            	size_t l, ip, jp, k, p, ms, p0, mem, mem0;
39:            	size_t byteset[32 / sizeof(size_t)] = { 0 };
40:            	size_t shift[256];
41:            
42:            	/* Computing length of needle and fill shift table */
43:            	for (l=0; n[l] && h[l]; l++)
44:            		BITOP(byteset, n[l], |=), shift[n[l]] = l+1;
45:            	if (n[l]) return 0; /* hit the end of h */
46:            
47:            	/* Compute maximal suffix */
48:            	ip = -1; jp = 0; k = p = 1;
49:            	while (jp+k<l) {
50:            		if (n[ip+k] == n[jp+k]) {
51:            			if (k == p) {
52:            				jp += p;
53:            				k = 1;
54:            			} else k++;
55:            		} else if (n[ip+k] > n[jp+k]) {
56:            			jp += k;
57:            			k = 1;
58:            			p = jp - ip;
59:            		} else {
60:            			ip = jp++;
61:            			k = p = 1;
62:            		}
63:            	}
64:            	ms = ip;
65:            	p0 = p;
66:            
67:            	/* And with the opposite comparison */
68:            	ip = -1; jp = 0; k = p = 1;
69:            	while (jp+k<l) {
70:            		if (n[ip+k] == n[jp+k]) {
71:            			if (k == p) {
72:            				jp += p;
73:            				k = 1;
74:            			} else k++;
75:            		} else if (n[ip+k] < n[jp+k]) {
76:            			jp += k;
77:            			k = 1;
78:            			p = jp - ip;
79:            		} else {
80:            			ip = jp++;
81:            			k = p = 1;
82:            		}
83:            	}
84:            	if (ip+1 > ms+1) ms = ip;
85:            	else p = p0;
86:            
87:            	/* Periodic needle? */
88:            	if (memcmp(n, n+p, ms+1)) {
89:            		mem0 = 0;
90:            		p = MAX(ms, l-ms-1) + 1;
91:            	} else mem0 = l-p;
92:            	mem = 0;
93:            
94:            	/* Initialize incremental end-of-haystack pointer */
95:            	z = h;
96:            
97:            	/* Search loop */
98:            	for (;;) {
99:            		/* Update incremental end-of-haystack pointer */
100:           		if (z-h < l) {
101:           			/* Fast estimate for MIN(l,63) */
102:           			size_t grow = l | 63;
103:           			const unsigned char *z2 = memchr(z, 0, grow);
104:           			if (z2) {
105:           				z = z2;
106:           				if (z-h < l) return 0;
107:           			} else z += grow;
108:           		}
109:           
110:           		/* Check last byte first; advance by shift on mismatch */
111:           		if (BITOP(byteset, h[l-1], &)) {
112:           			k = l-shift[h[l-1]];
113:           			//printf("adv by %zu (on %c) at [%s] (%zu;l=%zu)\n", k, h[l-1], h, shift[h[l-1]], l);
114:           			if (k) {
115:           				if (mem0 && mem && k < p) k = l-p;
116:           				h += k;
117:           				mem = 0;
118:           				continue;
119:           			}
120:           		} else {
121:           			h += l;
122:           			mem = 0;
123:           			continue;
124:           		}
125:           
126:           		/* Compare right half */
127:           		for (k=MAX(ms+1,mem); n[k] && n[k] == h[k]; k++);
128:           		if (n[k]) {
129:           			h += k-ms;
130:           			mem = 0;
131:           			continue;
132:           		}
133:           		/* Compare left half */
134:           		for (k=ms+1; k>mem && n[k-1] == h[k-1]; k--);
135:           		if (k <= mem) return (char *)h;
136:           		h += p;
137:           		mem = mem0;
138:           	}
139:           }
140:           
141:           #endif // not __XC8__
142:           
143:           char *strstr(const char *h, const char *n)
144:           {
145:           #ifdef __XC8__
146:           	if (n != NULL) {
5BC8  5024     MOVF n, W, ACCESS
5BCA  1025     IORWF quotient, W, ACCESS
5BCC  B4D8     BTFSC STATUS, 2, ACCESS
5BCE  D041     BRA 0x5C52
147:           		size_t nl = strlen(n);
5BD0  C024     MOVFF n, dividend
5BD2  F015     NOP
5BD4  C025     MOVFF quotient, Message
5BD6  F016     NOP
5BD8  EC03     CALL 0x6006, 0
5BDA  F030     NOP
5BDC  C015     MOVFF dividend, sign
5BDE  F026     NOP
5BE0  C016     MOVFF Message, quotient
5BE2  F027     NOP
148:           		while(h && *h) {
5BE4  D02B     BRA 0x5C3C
149:           			if(strncmp(h, n, nl) == 0)
5BE6  C022     MOVFF s, dividend
5BE8  F015     NOP
5BEA  C023     MOVFF sep, Message
5BEC  F016     NOP
5BEE  C024     MOVFF n, _r
5BF0  F017     NOP
5BF2  C025     MOVFF quotient, 0x18
5BF4  F018     NOP
5BF6  C026     MOVFF sign, multiplicand
5BF8  F019     NOP
5BFA  C027     MOVFF quotient, s
5BFC  F01A     NOP
5BFE  ECD7     CALL 0x55AE, 0
5C00  F02A     NOP
5C02  5015     MOVF dividend, W, ACCESS
5C04  1016     IORWF Message, W, ACCESS
5C06  A4D8     BTFSS STATUS, 2, ACCESS
5C08  D005     BRA 0x5C14
150:           				return ( char *)h;
5C0A  C022     MOVFF s, s
5C0C  F022     NOP
5C0E  C023     MOVFF sep, sep
5C10  F023     NOP
5C12  0012     RETURN 0
151:           			h = strchr(h+1, *n);
5C14  0E01     MOVLW 0x1
5C16  2422     ADDWF s, W, ACCESS
5C18  6E15     MOVWF dividend, ACCESS
5C1A  0E00     MOVLW 0x0
5C1C  2023     ADDWFC sep, W, ACCESS
5C1E  6E16     MOVWF Message, ACCESS
5C20  C024     MOVFF n, TBLPTR
5C22  FFF6     NOP
5C24  C025     MOVFF quotient, TBLPTRH
5C26  FFF7     NOP
5C28  0008     TBLRD*
5C2A  50F5     MOVF TABLAT, W, ACCESS
5C2C  6E17     MOVWF _r, ACCESS
5C2E  6A18     CLRF 0x18, ACCESS
5C30  EC81     CALL 0x6502, 0
5C32  F032     NOP
5C34  C015     MOVFF dividend, s
5C36  F022     NOP
5C38  C016     MOVFF Message, sep
5C3A  F023     NOP
152:           		}
5C3C  5022     MOVF s, W, ACCESS
5C3E  1023     IORWF sep, W, ACCESS
5C40  B4D8     BTFSC STATUS, 2, ACCESS
5C42  D007     BRA 0x5C52
5C44  C022     MOVFF s, FSR2
5C46  FFD9     NOP
5C48  C023     MOVFF sep, FSR2H
5C4A  FFDA     NOP
5C4C  50DF     MOVF INDF2, W, ACCESS
5C4E  A4D8     BTFSS STATUS, 2, ACCESS
5C50  D7CA     BRA 0x5BE6
153:           	}
154:           	return NULL;
5C52  0E00     MOVLW 0x0
5C54  6E22     MOVWF s, ACCESS
5C56  0E00     MOVLW 0x0
5C58  6E23     MOVWF sep, ACCESS
5C5A  0012     RETURN 0
155:           #else
156:           	/* Return immediately on empty needle */
157:           	if (!n[0]) return (char *)h;
158:           
159:           	/* Use faster algorithms for short needles */
160:           	h = strchr(h, *n);
161:           	if (!h || !n[1]) return (char *)h;
162:           	if (!h[1]) return 0;
163:           	if (!n[2]) return twobyte_strstr((void *)h, (void *)n);
164:           	if (!h[2]) return 0;
165:           	if (!n[3]) return threebyte_strstr((void *)h, (void *)n);
166:           	if (!h[3]) return 0;
167:           	if (!n[4]) return fourbyte_strstr((void *)h, (void *)n);
168:           
169:           	return twoway_strstr((void *)h, (void *)n);
170:           #endif
171:           }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strspn.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             #ifndef __XC8__
4:             #define BITOP(a,b,op) \
5:              ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
6:             #endif
7:             
8:             size_t strspn(const char *s, const char *c)
9:             {
10:            #ifdef __XC8__
11:            	register size_t	i;
12:            
13:            	i = 0;
6058  0E00     MOVLW 0x0
605A  6E20     MOVWF r, ACCESS
605C  0E00     MOVLW 0x0
605E  6E1F     MOVWF i, ACCESS
14:            	while(*s && strchr(c, *s)) {
6060  D004     BRA 0x606A
15:            		s++;
6062  4A1A     INFSNZ s, F, ACCESS
6064  2A1B     INCF c, F, ACCESS
16:            		i++;
6066  4A1F     INFSNZ i, F, ACCESS
6068  2A20     INCF r, F, ACCESS
17:            	}
606A  C01A     MOVFF s, FSR2
606C  FFD9     NOP
606E  C01B     MOVFF c, FSR2H
6070  FFDA     NOP
6072  50DF     MOVF INDF2, W, ACCESS
6074  B4D8     BTFSC STATUS, 2, ACCESS
6076  D013     BRA 0x609E
6078  C01C     MOVFF c, dividend
607A  F015     NOP
607C  C01D     MOVFF divisor, Message
607E  F016     NOP
6080  C01A     MOVFF s, FSR2
6082  FFD9     NOP
6084  C01B     MOVFF c, FSR2H
6086  FFDA     NOP
6088  50DF     MOVF INDF2, W, ACCESS
608A  6E1E     MOVWF l, ACCESS
608C  501E     MOVF l, W, ACCESS
608E  6E17     MOVWF _r, ACCESS
6090  6A18     CLRF 0x18, ACCESS
6092  EC81     CALL 0x6502, 0
6094  F032     NOP
6096  5015     MOVF dividend, W, ACCESS
6098  1016     IORWF Message, W, ACCESS
609A  A4D8     BTFSS STATUS, 2, ACCESS
609C  D7E2     BRA 0x6062
18:            	return i;
609E  C01F     MOVFF i, s
60A0  F01A     NOP
60A2  C020     MOVFF r, c
60A4  F01B     NOP
19:            #else
20:            	const char *a = s;
21:            	size_t byteset[32/sizeof(size_t)] = { 0 };
22:            
23:            	if (!c[0]) return 0;
24:            	if (!c[1]) {
25:            		for (; *s == *c; s++);
26:            		return s-a;
27:            	}
28:            
29:            	for (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);
30:            	for (; *s && BITOP(byteset, *(unsigned char *)s, &); s++);
31:            	return s-a;
32:            #endif
33:            }
60A6  0012     RETURN 0
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strncmp.c  -----------------------------------------
1:             #include <string.h>
2:             
3:             int strncmp(const char *_l, const char *_r, size_t n)
4:             {
5:             	const unsigned char *l=(void *)_l, *r=(void *)_r;
55AE  C015     MOVFF dividend, l
55B0  F01E     NOP
55B2  C016     MOVFF Message, i
55B4  F01F     NOP
55B6  C017     MOVFF _r, r
55B8  F020     NOP
55BA  C018     MOVFF 0x18, s
55BC  F021     NOP
6:             	if (!n--) return 0;
55BE  0619     DECF multiplicand, F, ACCESS
55C0  A0D8     BTFSS STATUS, 0, ACCESS
55C2  061A     DECF s, F, ACCESS
55C4  2819     INCF multiplicand, W, ACCESS
55C6  E10F     BNZ 0x55E6
55C8  281A     INCF s, W, ACCESS
55CA  A4D8     BTFSS STATUS, 2, ACCESS
55CC  D00C     BRA 0x55E6
55CE  0E00     MOVLW 0x0
55D0  6E16     MOVWF Message, ACCESS
55D2  0E00     MOVLW 0x0
55D4  6E15     MOVWF dividend, ACCESS
55D6  0012     RETURN 0
7:             	for (; *l && *r && n && *l == *r ; l++, r++, n--);
55D8  4A1E     INFSNZ l, F, ACCESS
55DA  2A1F     INCF i, F, ACCESS
55DC  4A20     INFSNZ r, F, ACCESS
55DE  2A21     INCF s, F, ACCESS
55E0  0619     DECF multiplicand, F, ACCESS
55E2  A0D8     BTFSS STATUS, 0, ACCESS
55E4  061A     DECF s, F, ACCESS
55E6  C01E     MOVFF l, TBLPTR
55E8  FFF6     NOP
55EA  C01F     MOVFF i, TBLPTRH
55EC  FFF7     NOP
55EE  6AF8     CLRF TBLPTRU, ACCESS
55F0  0E0E     MOVLW 0xE
55F2  64F7     CPFSGT TBLPTRH, ACCESS
55F4  D003     BRA 0x55FC
55F6  0008     TBLRD*
55F8  50F5     MOVF TABLAT, W, ACCESS
55FA  D005     BRA 0x5606
55FC  CFF6     MOVFF TBLPTR, FSR0
55FE  FFE9     NOP
5600  CFF7     MOVFF TBLPTRH, FSR0H
5602  FFEA     NOP
5604  50EF     MOVF INDF0, W, ACCESS
5606  0900     IORLW 0x0
5608  B4D8     BTFSC STATUS, 2, ACCESS
560A  D027     BRA 0x565A
560C  C020     MOVFF r, TBLPTR
560E  FFF6     NOP
5610  C021     MOVFF s, TBLPTRH
5612  FFF7     NOP
5614  0008     TBLRD*
5616  50F5     MOVF TABLAT, W, ACCESS
5618  0900     IORLW 0x0
561A  B4D8     BTFSC STATUS, 2, ACCESS
561C  D01E     BRA 0x565A
561E  5019     MOVF multiplicand, W, ACCESS
5620  101A     IORWF s, W, ACCESS
5622  B4D8     BTFSC STATUS, 2, ACCESS
5624  D01A     BRA 0x565A
5626  C020     MOVFF r, TBLPTR
5628  FFF6     NOP
562A  C021     MOVFF s, TBLPTRH
562C  FFF7     NOP
562E  0008     TBLRD*
5630  CFF5     MOVFF TABLAT, c
5632  F01B     NOP
5634  C01E     MOVFF l, TBLPTR
5636  FFF6     NOP
5638  C01F     MOVFF i, TBLPTRH
563A  FFF7     NOP
563C  6AF8     CLRF TBLPTRU, ACCESS
563E  0E0E     MOVLW 0xE
5640  64F7     CPFSGT TBLPTRH, ACCESS
5642  D003     BRA 0x564A
5644  0008     TBLRD*
5646  50F5     MOVF TABLAT, W, ACCESS
5648  D005     BRA 0x5654
564A  CFF6     MOVFF TBLPTR, FSR0
564C  FFE9     NOP
564E  CFF7     MOVFF TBLPTRH, FSR0H
5650  FFEA     NOP
5652  50EF     MOVF INDF0, W, ACCESS
5654  181B     XORWF c, W, ACCESS
5656  B4D8     BTFSC STATUS, 2, ACCESS
5658  D7BF     BRA 0x55D8
8:             	return *l - *r;
565A  C020     MOVFF r, TBLPTR
565C  FFF6     NOP
565E  C021     MOVFF s, TBLPTRH
5660  FFF7     NOP
5662  0008     TBLRD*
5664  50F5     MOVF TABLAT, W, ACCESS
5666  6E1B     MOVWF c, ACCESS
5668  6A1C     CLRF c, ACCESS
566A  1E1B     COMF c, F, ACCESS
566C  1E1C     COMF c, F, ACCESS
566E  4A1B     INFSNZ c, F, ACCESS
5670  2A1C     INCF c, F, ACCESS
5672  C01E     MOVFF l, TBLPTR
5674  FFF6     NOP
5676  C01F     MOVFF i, TBLPTRH
5678  FFF7     NOP
567A  6AF8     CLRF TBLPTRU, ACCESS
567C  0E0E     MOVLW 0xE
567E  64F7     CPFSGT TBLPTRH, ACCESS
5680  D003     BRA 0x5688
5682  0008     TBLRD*
5684  50F5     MOVF TABLAT, W, ACCESS
5686  D005     BRA 0x5692
5688  CFF6     MOVFF TBLPTR, FSR0
568A  FFE9     NOP
568C  CFF7     MOVFF TBLPTRH, FSR0H
568E  FFEA     NOP
5690  50EF     MOVF INDF0, W, ACCESS
5692  6E1D     MOVWF divisor, ACCESS
5694  501D     MOVF divisor, W, ACCESS
5696  241B     ADDWF c, W, ACCESS
5698  6E15     MOVWF dividend, ACCESS
569A  0E00     MOVLW 0x0
569C  201C     ADDWFC c, W, ACCESS
569E  6E16     MOVWF Message, ACCESS
56A0  0012     RETURN 0
9:             }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strlen.c  ------------------------------------------
1:             #include <string.h>
2:             #include <stdint.h>
3:             #include <limits.h>
4:             
5:             #ifndef __XC8__
6:             #define ALIGN (sizeof(size_t))
7:             #define ONES ((size_t)-1/UCHAR_MAX)
8:             #define HIGHS (ONES * (UCHAR_MAX/2+1))
9:             #define HASZERO(x) ((x)-ONES & ~(x) & HIGHS)
10:            #endif
11:            
12:            size_t strlen(const char *s)
13:            {
14:            	const char *a = s;
6006  C015     MOVFF dividend, multiplicand
6008  F019     NOP
600A  C016     MOVFF Message, s
600C  F01A     NOP
15:            #ifdef __XC8__
16:            	while(*s) {
600E  D002     BRA 0x6014
17:            		s++;
6010  4A15     INFSNZ dividend, F, ACCESS
6012  2A16     INCF Message, F, ACCESS
18:            	}
6014  C015     MOVFF dividend, TBLPTR
6016  FFF6     NOP
6018  C016     MOVFF Message, TBLPTRH
601A  FFF7     NOP
601C  6AF8     CLRF TBLPTRU, ACCESS
601E  0E0E     MOVLW 0xE
6020  64F7     CPFSGT TBLPTRH, ACCESS
6022  D003     BRA 0x602A
6024  0008     TBLRD*
6026  50F5     MOVF TABLAT, W, ACCESS
6028  D005     BRA 0x6034
602A  CFF6     MOVFF TBLPTR, FSR0
602C  FFE9     NOP
602E  CFF7     MOVFF TBLPTRH, FSR0H
6030  FFEA     NOP
6032  50EF     MOVF INDF0, W, ACCESS
6034  0900     IORLW 0x0
6036  A4D8     BTFSS STATUS, 2, ACCESS
6038  D7EB     BRA 0x6010
19:            #else
20:            	const size_t *w;
21:            	for (; (uintptr_t)s % ALIGN; s++) if (!*s) return s-a;
22:            	for (w = (const void *)s; !HASZERO(*w); w++);
23:            	for (s = (const void *)w; *s; s++);
24:            #endif
25:            	return s-a;
603A  C019     MOVFF multiplicand, _r
603C  F017     NOP
603E  C01A     MOVFF s, 0x18
6040  F018     NOP
6042  1E17     COMF _r, F, ACCESS
6044  1E18     COMF 0x18, F, ACCESS
6046  4A17     INFSNZ _r, F, ACCESS
6048  2A18     INCF 0x18, F, ACCESS
604A  5015     MOVF dividend, W, ACCESS
604C  2417     ADDWF _r, W, ACCESS
604E  6E15     MOVWF dividend, ACCESS
6050  5016     MOVF Message, W, ACCESS
6052  2018     ADDWFC 0x18, W, ACCESS
6054  6E16     MOVWF Message, ACCESS
6056  0012     RETURN 0
26:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strcspn.c  -----------------------------------------
1:             #include <string.h>
2:             
3:             #ifndef __XC8__
4:             #define BITOP(a,b,op) \
5:              ((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
6:             
7:             char *__strchrnul(const char *, int);
8:             #endif
9:             
10:            size_t strcspn(const char *s, const char *c)
11:            {
12:            #ifdef __XC8__
13:            	register size_t	i;
14:            
15:            	i = 0;
60A8  0E00     MOVLW 0x0
60AA  6E20     MOVWF r, ACCESS
60AC  0E00     MOVLW 0x0
60AE  6E1F     MOVWF i, ACCESS
16:            	while(*s && !strchr(c, *s)) {
60B0  D004     BRA 0x60BA
17:            		s++;
60B2  4A1A     INFSNZ s, F, ACCESS
60B4  2A1B     INCF c, F, ACCESS
18:            		i++;
60B6  4A1F     INFSNZ i, F, ACCESS
60B8  2A20     INCF r, F, ACCESS
19:            	}
60BA  C01A     MOVFF s, FSR2
60BC  FFD9     NOP
60BE  C01B     MOVFF c, FSR2H
60C0  FFDA     NOP
60C2  50DF     MOVF INDF2, W, ACCESS
60C4  B4D8     BTFSC STATUS, 2, ACCESS
60C6  D013     BRA 0x60EE
60C8  C01C     MOVFF c, dividend
60CA  F015     NOP
60CC  C01D     MOVFF divisor, Message
60CE  F016     NOP
60D0  C01A     MOVFF s, FSR2
60D2  FFD9     NOP
60D4  C01B     MOVFF c, FSR2H
60D6  FFDA     NOP
60D8  50DF     MOVF INDF2, W, ACCESS
60DA  6E1E     MOVWF l, ACCESS
60DC  501E     MOVF l, W, ACCESS
60DE  6E17     MOVWF _r, ACCESS
60E0  6A18     CLRF 0x18, ACCESS
60E2  EC81     CALL 0x6502, 0
60E4  F032     NOP
60E6  5015     MOVF dividend, W, ACCESS
60E8  1016     IORWF Message, W, ACCESS
60EA  B4D8     BTFSC STATUS, 2, ACCESS
60EC  D7E2     BRA 0x60B2
20:            	return i;
60EE  C01F     MOVFF i, s
60F0  F01A     NOP
60F2  C020     MOVFF r, c
60F4  F01B     NOP
21:            #else
22:            	const char *a = s;
23:            	size_t byteset[32/sizeof(size_t)];
24:            
25:            	if (!c[0] || !c[1]) return __strchrnul(s, *c)-a;
26:            
27:            	memset(byteset, 0, sizeof byteset);
28:            	for (; *c && BITOP(byteset, *(unsigned char *)c, |=); c++);
29:            	for (; *s && !BITOP(byteset, *(unsigned char *)s, &); s++);
30:            	return s-a;
31:            #endif
32:            }
60F6  0012     RETURN 0
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strcpy.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             #ifndef __XC8__
4:             char *__stpcpy(char *, const char *);
5:             #endif
6:             
7:             char *strcpy(char *restrict dest, const char *restrict src)
8:             {
9:             #ifndef __XC8__
10:            	__stpcpy(dest, src);
11:            	return dest;
12:            #else
13:            	const char *s = src;
6538  C017     MOVFF _r, multiplicand
653A  F019     NOP
653C  C018     MOVFF 0x18, s
653E  F01A     NOP
14:            	char *d = dest;
6540  C015     MOVFF dividend, c
6542  F01B     NOP
6544  C016     MOVFF Message, c
6546  F01C     NOP
15:            	while ((*d++ = *s++));
6548  C019     MOVFF multiplicand, FSR2
654A  FFD9     NOP
654C  C01A     MOVFF s, FSR2H
654E  FFDA     NOP
6550  4A19     INFSNZ multiplicand, F, ACCESS
6552  2A1A     INCF s, F, ACCESS
6554  C01B     MOVFF c, FSR1
6556  FFE1     NOP
6558  C01C     MOVFF c, FSR1H
655A  FFE2     NOP
655C  4A1B     INFSNZ c, F, ACCESS
655E  2A1C     INCF c, F, ACCESS
6560  CFDF     MOVFF INDF2, INDF1
6562  FFE7     NOP
6564  50E7     MOVF INDF1, W, ACCESS
6566  B4D8     BTFSC STATUS, 2, ACCESS
6568  0012     RETURN 0
656A  D7EE     BRA 0x6548
16:            	return dest;
17:            #endif
18:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/strchr.c  ------------------------------------------
1:             #include <string.h>
2:             
3:             #ifndef __XC8__
4:             char *__strchrnul(const char *, int);
5:             #endif
6:             
7:             char *strchr(const char *s, int c)
8:             {
9:             #ifndef __XC8__
10:            	char *r = __strchrnul(s, c);
11:            	return *(unsigned char *)r == (unsigned char)c ? r : 0;
12:            #else
13:            	do {
14:            		if(*s == (char)c) {
6502  C015     MOVFF dividend, FSR2
6504  FFD9     NOP
6506  C016     MOVFF Message, FSR2H
6508  FFDA     NOP
650A  5017     MOVF _r, W, ACCESS
650C  18DE     XORWF POSTINC2, W, ACCESS
650E  A4D8     BTFSS STATUS, 2, ACCESS
6510  D005     BRA 0x651C
15:            			return ( char *)s;
6512  C015     MOVFF dividend, dividend
6514  F015     NOP
6516  C016     MOVFF Message, Message
6518  F016     NOP
651A  0012     RETURN 0
16:            		}
17:            	} while(*s++);
651C  C015     MOVFF dividend, FSR2
651E  FFD9     NOP
6520  C016     MOVFF Message, FSR2H
6522  FFDA     NOP
6524  4A15     INFSNZ dividend, F, ACCESS
6526  2A16     INCF Message, F, ACCESS
6528  50DF     MOVF INDF2, W, ACCESS
652A  A4D8     BTFSS STATUS, 2, ACCESS
652C  D7EA     BRA strchr
18:            	return 0;
652E  0E00     MOVLW 0x0
6530  6E15     MOVWF dividend, ACCESS
6532  0E00     MOVLW 0x0
6534  6E16     MOVWF Message, ACCESS
6536  0012     RETURN 0
19:            #endif
20:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/sprcmul.c  -----------------------------------------
1:             /* SP relaxed compliance floating point multiply intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Multiply */
6:             /* single monolithic routine */
7:             SP
8:             SPMUL(SP b, SP a) {
9:             	unsigned char sign;	/* sign of result */
10:            	unsigned char bexp;	/* Dst exponent */
11:            	unsigned char aexp;	/* Src exponent */
12:            	uint32_t grs;		/* Guard, round, sticky */
13:            	SFP prod;
14:            	wordProduct temp;	/* intermediate mult results ; exponent of result */
15:            
16:            	/* Unpack and check operands */
17:            	sign = (*(SFP *) & b).fAsBytes.d & 0x80;
3856  5030     MOVF cp, W, ACCESS
3858  0B80     ANDLW 0x80
385A  0100     MOVLB 0x0
385C  6F64     MOVWF sign, BANKED
18:            	bexp = ((*(SFP *) & b).fAsBytes.d) << 1;
385E  5030     MOVF cp, W, ACCESS
3860  2430     ADDWF cp, W, ACCESS
3862  6F6A     MOVWF x, BANKED
19:            	if ((*(SFP *) & b).fAsBytes.c & 0x80) {
3864  BE2F     BTFSC 0x2F, 7, ACCESS
20:            		bexp |= 0x1;
3866  816A     BSF x, 0, BANKED
21:            	}
22:            
23:            	/* Destination normal ? */
24:            	if (bexp) {
3868  516A     MOVF x, W, BANKED
386A  B4D8     BTFSC STATUS, 2, ACCESS
386C  D00D     BRA 0x3888
25:            		/* Destination inf or NaN ? */
26:            		if (bexp == 0xFF) {
386E  296A     INCF x, W, BANKED
3870  A4D8     BTFSS STATUS, 2, ACCESS
3872  D008     BRA 0x3884
27:            			/* Make it inf */
28:            			b = 0;
3874  0E00     MOVLW 0x0
3876  6E2D     MOVWF counter, ACCESS
3878  0E00     MOVLW 0x0
387A  6E2E     MOVWF w, ACCESS
387C  0E00     MOVLW 0x0
387E  6E2F     MOVWF 0x2F, ACCESS
3880  0E00     MOVLW 0x0
3882  6E30     MOVWF cp, ACCESS
29:            		}
30:            		// and in the implied 1-bit to b's fraction
31:            		(*(SFP *) & b).i |= (int32_t) 1 << SPFRCB;
3884  8E2F     BSF 0x2F, 7, ACCESS
32:            
33:            	}
3886  D008     BRA 0x3898
34:            	else {
35:            		/* Make it zero */
36:            		b = 0;
3888  0E00     MOVLW 0x0
388A  6E2D     MOVWF counter, ACCESS
388C  0E00     MOVLW 0x0
388E  6E2E     MOVWF w, ACCESS
3890  0E00     MOVLW 0x0
3892  6E2F     MOVWF 0x2F, ACCESS
3894  0E00     MOVLW 0x0
3896  6E30     MOVWF cp, ACCESS
37:            	}
38:            
39:            	sign ^= (*(SFP *) & a).fAsBytes.d & 0x80;
3898  5034     MOVF l, W, ACCESS
389A  0B80     ANDLW 0x80
389C  1B64     XORWF sign, F, BANKED
40:            	aexp = ((*(SFP *) & a).fAsBytes.d) << 1;
389E  5034     MOVF l, W, ACCESS
38A0  2434     ADDWF l, W, ACCESS
38A2  6F65     MOVWF aexp, BANKED
41:            	if ((*(SFP *) & a).fAsBytes.c & 0x80) {
38A4  BE33     BTFSC 0x33, 7, ACCESS
42:            		aexp |= 0x1;
38A6  8165     BSF aexp, 0, BANKED
43:            	}
44:            	/* Destination normal ? */
45:            	if (aexp) {
38A8  5165     MOVF aexp, W, BANKED
38AA  B4D8     BTFSC STATUS, 2, ACCESS
38AC  D00D     BRA 0x38C8
46:            
47:            		/* Destination inf or NaN ? */
48:            		if (aexp == 0xFF) {
38AE  2965     INCF aexp, W, BANKED
38B0  A4D8     BTFSS STATUS, 2, ACCESS
38B2  D008     BRA 0x38C4
49:            			/* Make it inf */
50:            			a = 0;
38B4  0E00     MOVLW 0x0
38B6  6E31     MOVWF a, ACCESS
38B8  0E00     MOVLW 0x0
38BA  6E32     MOVWF p, ACCESS
38BC  0E00     MOVLW 0x0
38BE  6E33     MOVWF 0x33, ACCESS
38C0  0E00     MOVLW 0x0
38C2  6E34     MOVWF l, ACCESS
51:            		}
52:            		// and in the implied 1-bit to a's fraction
53:            		(*(SFP *) & a).i |= (int32_t) 1 << SPFRCB;
38C4  8E33     BSF 0x33, 7, ACCESS
54:            	}
38C6  D008     BRA 0x38D8
55:            	else {
56:            		/* Make it zero */
57:            		a = 0;
38C8  0E00     MOVLW 0x0
38CA  6E31     MOVWF a, ACCESS
38CC  0E00     MOVLW 0x0
38CE  6E32     MOVWF p, ACCESS
38D0  0E00     MOVLW 0x0
38D2  6E33     MOVWF 0x33, ACCESS
38D4  0E00     MOVLW 0x0
38D6  6E34     MOVWF l, ACCESS
58:            	}
59:            
60:            	/* Multiply */
61:            
62:            	/* Special operand check */
63:            
64:            	/* Source or destination zero ? Result zero */
65:            	if (aexp == 0 || bexp == 0) {
38D8  5165     MOVF aexp, W, BANKED
38DA  B4D8     BTFSC STATUS, 2, ACCESS
38DC  D003     BRA 0x38E4
38DE  516A     MOVF x, W, BANKED
38E0  A4D8     BTFSS STATUS, 2, ACCESS
38E2  D009     BRA 0x38F6
66:            		return 0.0;
38E4  0E00     MOVLW 0x0
38E6  6E2D     MOVWF counter, ACCESS
38E8  0E00     MOVLW 0x0
38EA  6E2E     MOVWF w, ACCESS
38EC  0E00     MOVLW 0x0
38EE  6E2F     MOVWF 0x2F, ACCESS
38F0  0E00     MOVLW 0x0
38F2  6E30     MOVWF cp, ACCESS
38F4  0012     RETURN 0
67:            	}
68:            
69:            //    we decompose a 24 bit multiply into 9 8 bit multiplies as follows:
70:            //
71:            //    b's fraction is b1|b2|b3 and a's fraction is a1|a2|a3
72:            //
73:            //    then ab is the (48 bit) sum of these 9 16 bit intermediate products shifted appropriately
74:            //
75:            //
76:            //                                     a3b3
77:            //                                   a2b3
78:            //                                   a3b2
79:            //                                 a1b3
80:            //                                 a2b2
81:            //                                 a3b1
82:            //                               a1b2
83:            //                               a2b1
84:            //                             a1b1
85:            //
86:            //   in this algorithm we compute the product to be the upper 24 bits of the sum and grs to be the lower 24 bits
87:            //   shifted 8 to the left     then we renormalize and round as usual.
88:            //
89:            
90:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
91:            #define MIDBYTE(x)  (*(((unsigned char *)(&x))+1))
92:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+2))
93:            
94:            #ifdef _PIC18
95:            	temp.n = HIGHBYTE(a) * LOWBYTE(b);
38F6  5033     MOVF 0x33, W, ACCESS
38F8  022D     MULWF counter, ACCESS
38FA  CFF3     MOVFF PROD, temp
38FC  F06F     NOP
38FE  CFF4     MOVFF PRODH, 0x70
3900  F070     NOP
96:            	grs = temp.nAsBytes.a;
3902  516F     MOVF temp, W, BANKED
3904  6F66     MOVWF grs, BANKED
3906  6B67     CLRF 0x67, BANKED
3908  6B68     CLRF 0x68, BANKED
390A  6B69     CLRF 0x69, BANKED
97:            	prod.i = temp.nAsBytes.b;
390C  5170     MOVF 0x70, W, BANKED
390E  6F6B     MOVWF prod, BANKED
3910  6B6C     CLRF 0x6C, BANKED
3912  6B6D     CLRF 0x6D, BANKED
3914  6B6E     CLRF 0x6E, BANKED
98:            	temp.n = MIDBYTE(a) * MIDBYTE(b);
3916  5032     MOVF p, W, ACCESS
3918  022E     MULWF w, ACCESS
391A  CFF3     MOVFF PROD, temp
391C  F06F     NOP
391E  CFF4     MOVFF PRODH, 0x70
3920  F070     NOP
99:            	grs += temp.nAsBytes.a;
3922  516F     MOVF temp, W, BANKED
3924  2766     ADDWF grs, F, BANKED
3926  0E00     MOVLW 0x0
3928  2367     ADDWFC 0x67, F, BANKED
392A  2368     ADDWFC 0x68, F, BANKED
392C  2369     ADDWFC 0x69, F, BANKED
100:           	prod.i += temp.nAsBytes.b;
392E  5170     MOVF 0x70, W, BANKED
3930  276B     ADDWF prod, F, BANKED
3932  0E00     MOVLW 0x0
3934  236C     ADDWFC 0x6C, F, BANKED
3936  236D     ADDWFC 0x6D, F, BANKED
3938  236E     ADDWFC 0x6E, F, BANKED
101:           	temp.n = LOWBYTE(a) * HIGHBYTE(b);
393A  5031     MOVF a, W, ACCESS
393C  022F     MULWF 0x2F, ACCESS
393E  CFF3     MOVFF PROD, temp
3940  F06F     NOP
3942  CFF4     MOVFF PRODH, 0x70
3944  F070     NOP
102:           	grs += temp.nAsBytes.a;
3946  516F     MOVF temp, W, BANKED
3948  2766     ADDWF grs, F, BANKED
394A  0E00     MOVLW 0x0
394C  2367     ADDWFC 0x67, F, BANKED
394E  2368     ADDWFC 0x68, F, BANKED
3950  2369     ADDWFC 0x69, F, BANKED
103:           	prod.i += temp.nAsBytes.b;
3952  5170     MOVF 0x70, W, BANKED
3954  276B     ADDWF prod, F, BANKED
3956  0E00     MOVLW 0x0
3958  236C     ADDWFC 0x6C, F, BANKED
395A  236D     ADDWFC 0x6D, F, BANKED
395C  236E     ADDWFC 0x6E, F, BANKED
104:           	grs <<= 8;
395E  C068     MOVFF 0x68, 0x69
3960  F069     NOP
3962  C067     MOVFF 0x67, 0x68
3964  F068     NOP
3966  C066     MOVFF grs, 0x67
3968  F067     NOP
396A  6B66     CLRF grs, BANKED
105:           	temp.n = LOWBYTE(a) * MIDBYTE(b);
396C  5031     MOVF a, W, ACCESS
396E  022E     MULWF w, ACCESS
3970  CFF3     MOVFF PROD, temp
3972  F06F     NOP
3974  CFF4     MOVFF PRODH, 0x70
3976  F070     NOP
106:           	grs += (unsigned long)temp.n;
3978  516F     MOVF temp, W, BANKED
397A  2766     ADDWF grs, F, BANKED
397C  5170     MOVF 0x70, W, BANKED
397E  2367     ADDWFC 0x67, F, BANKED
3980  0E00     MOVLW 0x0
3982  2368     ADDWFC 0x68, F, BANKED
3984  0E00     MOVLW 0x0
3986  2369     ADDWFC 0x69, F, BANKED
107:           	temp.n = MIDBYTE(a) * LOWBYTE(b);
3988  5032     MOVF p, W, ACCESS
398A  022D     MULWF counter, ACCESS
398C  CFF3     MOVFF PROD, temp
398E  F06F     NOP
3990  CFF4     MOVFF PRODH, 0x70
3992  F070     NOP
108:           	grs += (unsigned long)temp.n;
3994  516F     MOVF temp, W, BANKED
3996  2766     ADDWF grs, F, BANKED
3998  5170     MOVF 0x70, W, BANKED
399A  2367     ADDWFC 0x67, F, BANKED
399C  0E00     MOVLW 0x0
399E  2368     ADDWFC 0x68, F, BANKED
39A0  0E00     MOVLW 0x0
39A2  2369     ADDWFC 0x69, F, BANKED
109:           	grs <<= 8;
39A4  C068     MOVFF 0x68, 0x69
39A6  F069     NOP
39A8  C067     MOVFF 0x67, 0x68
39AA  F068     NOP
39AC  C066     MOVFF grs, 0x67
39AE  F067     NOP
39B0  6B66     CLRF grs, BANKED
110:           	temp.n = LOWBYTE(a) * LOWBYTE(b);
39B2  5031     MOVF a, W, ACCESS
39B4  022D     MULWF counter, ACCESS
39B6  CFF3     MOVFF PROD, temp
39B8  F06F     NOP
39BA  CFF4     MOVFF PRODH, 0x70
39BC  F070     NOP
111:           	grs += (unsigned long)temp.n;
39BE  516F     MOVF temp, W, BANKED
39C0  2766     ADDWF grs, F, BANKED
39C2  5170     MOVF 0x70, W, BANKED
39C4  2367     ADDWFC 0x67, F, BANKED
39C6  0E00     MOVLW 0x0
39C8  2368     ADDWFC 0x68, F, BANKED
39CA  0E00     MOVLW 0x0
39CC  2369     ADDWFC 0x69, F, BANKED
112:           	temp.n = HIGHBYTE(a) * MIDBYTE(b);
39CE  5033     MOVF 0x33, W, ACCESS
39D0  022E     MULWF w, ACCESS
39D2  CFF3     MOVFF PROD, temp
39D4  F06F     NOP
39D6  CFF4     MOVFF PRODH, 0x70
39D8  F070     NOP
113:           	prod.i += (unsigned long)temp.n;
39DA  516F     MOVF temp, W, BANKED
39DC  276B     ADDWF prod, F, BANKED
39DE  5170     MOVF 0x70, W, BANKED
39E0  236C     ADDWFC 0x6C, F, BANKED
39E2  0E00     MOVLW 0x0
39E4  236D     ADDWFC 0x6D, F, BANKED
39E6  0E00     MOVLW 0x0
39E8  236E     ADDWFC 0x6E, F, BANKED
114:           	temp.n = MIDBYTE(a) * HIGHBYTE(b);
39EA  5032     MOVF p, W, ACCESS
39EC  022F     MULWF 0x2F, ACCESS
39EE  CFF3     MOVFF PROD, temp
39F0  F06F     NOP
39F2  CFF4     MOVFF PRODH, 0x70
39F4  F070     NOP
115:           	prod.i += (unsigned long)temp.n;
39F6  516F     MOVF temp, W, BANKED
39F8  276B     ADDWF prod, F, BANKED
39FA  5170     MOVF 0x70, W, BANKED
39FC  236C     ADDWFC 0x6C, F, BANKED
39FE  0E00     MOVLW 0x0
3A00  236D     ADDWFC 0x6D, F, BANKED
3A02  0E00     MOVLW 0x0
3A04  236E     ADDWFC 0x6E, F, BANKED
116:           	temp.n = HIGHBYTE(a) * HIGHBYTE(b);
3A06  5033     MOVF 0x33, W, ACCESS
3A08  022F     MULWF 0x2F, ACCESS
3A0A  CFF3     MOVFF PROD, temp
3A0C  F06F     NOP
3A0E  CFF4     MOVFF PRODH, 0x70
3A10  F070     NOP
117:           	prod.i += (((unsigned long)temp.n) << 8);
3A12  516F     MOVF temp, W, BANKED
3A14  6F60     MOVWF __pcstackBANK0, BANKED
3A16  5170     MOVF 0x70, W, BANKED
3A18  6F61     MOVWF 0x61, BANKED
3A1A  6B62     CLRF d, BANKED
3A1C  6B63     CLRF 0x63, BANKED
3A1E  C062     MOVFF d, 0x63
3A20  F063     NOP
3A22  C061     MOVFF 0x61, d
3A24  F062     NOP
3A26  C060     MOVFF __pcstackBANK0, 0x61
3A28  F061     NOP
3A2A  6B60     CLRF __pcstackBANK0, BANKED
3A2C  5160     MOVF __pcstackBANK0, W, BANKED
3A2E  276B     ADDWF prod, F, BANKED
3A30  5161     MOVF 0x61, W, BANKED
3A32  236C     ADDWFC 0x6C, F, BANKED
3A34  5162     MOVF d, W, BANKED
3A36  236D     ADDWFC 0x6D, F, BANKED
3A38  5163     MOVF 0x63, W, BANKED
3A3A  236E     ADDWFC 0x6E, F, BANKED
118:           #else
119:           	temp.n = _Umul8_16(HIGHBYTE(a), LOWBYTE(b));
120:           	grs = temp.nAsBytes.a;
121:           	prod.i = temp.nAsBytes.b;
122:           	temp.n = _Umul8_16(MIDBYTE(a), MIDBYTE(b));
123:           	grs += temp.nAsBytes.a;
124:           	prod.i += temp.nAsBytes.b;
125:           	temp.n = _Umul8_16(LOWBYTE(a), HIGHBYTE(b));
126:           	grs += temp.nAsBytes.a;
127:           	prod.i += temp.nAsBytes.b;
128:           	grs <<= 8;
129:           	temp.n = _Umul8_16(LOWBYTE(a), MIDBYTE(b));
130:           	grs += (unsigned long)temp.n;
131:           	temp.n = _Umul8_16(MIDBYTE(a), LOWBYTE(b));
132:           	grs += (unsigned long)temp.n;
133:           	grs <<= 8;
134:           	temp.n = _Umul8_16(LOWBYTE(a), LOWBYTE(b));
135:           	grs += (unsigned long)temp.n;
136:           	temp.n = _Umul8_16(HIGHBYTE(a), MIDBYTE(b));
137:           	prod.i += (unsigned long)temp.n;
138:           	temp.n = _Umul8_16(MIDBYTE(a), HIGHBYTE(b));
139:           	prod.i += (unsigned long)temp.n;
140:           	temp.n = _Umul8_16(HIGHBYTE(a), HIGHBYTE(b));
141:           	prod.i += (((unsigned long)temp.n) << 8);
142:           #endif
143:           
144:           	// first add the overflow bit from the lower half to the upper half
145:           	prod.i += (grs >> 24);
3A3C  C066     MOVFF grs, __pcstackBANK0
3A3E  F060     NOP
3A40  C067     MOVFF 0x67, 0x61
3A42  F061     NOP
3A44  C068     MOVFF 0x68, d
3A46  F062     NOP
3A48  C069     MOVFF 0x69, 0x63
3A4A  F063     NOP
3A4C  0E19     MOVLW 0x19
3A4E  D005     BRA 0x3A5A
3A50  90D8     BCF STATUS, 0, ACCESS
3A52  3363     RRCF 0x63, F, BANKED
3A54  3362     RRCF d, F, BANKED
3A56  3361     RRCF 0x61, F, BANKED
3A58  3360     RRCF __pcstackBANK0, F, BANKED
3A5A  2EE8     DECFSZ WREG, F, ACCESS
3A5C  D7F9     BRA 0x3A50
3A5E  5160     MOVF __pcstackBANK0, W, BANKED
3A60  276B     ADDWF prod, F, BANKED
3A62  5161     MOVF 0x61, W, BANKED
3A64  236C     ADDWFC 0x6C, F, BANKED
3A66  5162     MOVF d, W, BANKED
3A68  236D     ADDWFC 0x6D, F, BANKED
3A6A  5163     MOVF 0x63, W, BANKED
3A6C  236E     ADDWFC 0x6E, F, BANKED
146:           	grs <<= 8;
3A6E  C068     MOVFF 0x68, 0x69
3A70  F069     NOP
3A72  C067     MOVFF 0x67, 0x68
3A74  F068     NOP
3A76  C066     MOVFF grs, 0x67
3A78  F067     NOP
3A7A  6B66     CLRF grs, BANKED
147:           
148:           	/* Add source exponent, minus (bias - 1) */
149:           	temp.i = bexp + aexp - 126;
3A7C  5165     MOVF aexp, W, BANKED
3A7E  C06A     MOVFF x, __pcstackBANK0
3A80  F060     NOP
3A82  6B61     CLRF 0x61, BANKED
3A84  2760     ADDWF __pcstackBANK0, F, BANKED
3A86  0E00     MOVLW 0x0
3A88  2361     ADDWFC 0x61, F, BANKED
3A8A  0E82     MOVLW 0x82
3A8C  2560     ADDWF __pcstackBANK0, W, BANKED
3A8E  6F6F     MOVWF temp, BANKED
3A90  0EFF     MOVLW 0xFF
3A92  2161     ADDWFC 0x61, W, BANKED
3A94  6F70     MOVWF 0x70, BANKED
150:           
151:           	/* Renormalize  */
152:           	while (!(prod.i & ((int32_t) 1 << SPFRCB))) {
3A96  D00F     BRA 0x3AB6
153:           		prod.i <<= 1;
3A98  90D8     BCF STATUS, 0, ACCESS
3A9A  376B     RLCF prod, F, BANKED
3A9C  376C     RLCF 0x6C, F, BANKED
3A9E  376D     RLCF 0x6D, F, BANKED
3AA0  376E     RLCF 0x6E, F, BANKED
154:           		if (grs & 0x80000000) {
3AA2  BF69     BTFSC 0x69, 7, BANKED
155:           			prod.i |= 0x1;
3AA4  816B     BSF prod, 0, BANKED
156:           		}
157:           		grs <<= 1;
3AA6  90D8     BCF STATUS, 0, ACCESS
3AA8  3766     RLCF grs, F, BANKED
3AAA  3767     RLCF 0x67, F, BANKED
3AAC  3768     RLCF 0x68, F, BANKED
3AAE  3769     RLCF 0x69, F, BANKED
158:           		--temp.i;
3AB0  076F     DECF temp, F, BANKED
3AB2  A0D8     BTFSS STATUS, 0, ACCESS
3AB4  0770     DECF 0x70, F, BANKED
159:           	}
3AB6  AF6D     BTFSS 0x6D, 7, BANKED
3AB8  D7EF     BRA 0x3A98
160:           
161:           	/* Round, check overflow, underflow */
162:           	// reuse aexp as round up flag
163:           	aexp = 0;
3ABA  0E00     MOVLW 0x0
3ABC  6F65     MOVWF aexp, BANKED
164:           	if (grs & 0x80000000) {
3ABE  AF69     BTFSS 0x69, 7, BANKED
3AC0  D016     BRA 0x3AEE
165:           		if (grs & 0x7FFFFFFF) {
3AC2  0EFF     MOVLW 0xFF
3AC4  1566     ANDWF grs, W, BANKED
3AC6  6F60     MOVWF __pcstackBANK0, BANKED
3AC8  0EFF     MOVLW 0xFF
3ACA  1567     ANDWF 0x67, W, BANKED
3ACC  6F61     MOVWF 0x61, BANKED
3ACE  0EFF     MOVLW 0xFF
3AD0  1568     ANDWF 0x68, W, BANKED
3AD2  6F62     MOVWF d, BANKED
3AD4  0E7F     MOVLW 0x7F
3AD6  1569     ANDWF 0x69, W, BANKED
3AD8  6F63     MOVWF 0x63, BANKED
3ADA  5160     MOVF __pcstackBANK0, W, BANKED
3ADC  1161     IORWF 0x61, W, BANKED
3ADE  1162     IORWF d, W, BANKED
3AE0  1163     IORWF 0x63, W, BANKED
3AE2  A4D8     BTFSS STATUS, 2, ACCESS
166:           			aexp = 1;
3AE4  D002     BRA 0x3AEA
167:           		}
168:           		else {
169:           			if (prod.i & 1) {
3AE6  A16B     BTFSS prod, 0, BANKED
3AE8  D002     BRA 0x3AEE
170:           				aexp = 1;
3AEA  0E01     MOVLW 0x1
3AEC  6F65     MOVWF aexp, BANKED
171:           			}
172:           		}
173:           	}
174:           	if (aexp) {
3AEE  5165     MOVF aexp, W, BANKED
3AF0  B4D8     BTFSC STATUS, 2, ACCESS
3AF2  D01F     BRA 0x3B32
175:           		++prod.i;
3AF4  0E01     MOVLW 0x1
3AF6  276B     ADDWF prod, F, BANKED
3AF8  0E00     MOVLW 0x0
3AFA  236C     ADDWFC 0x6C, F, BANKED
3AFC  236D     ADDWFC 0x6D, F, BANKED
3AFE  236E     ADDWFC 0x6E, F, BANKED
176:           		if (prod.i & ((int32_t) 1 << (SPFRCB + 1))) {
3B00  A16E     BTFSS 0x6E, 0, BANKED
3B02  D017     BRA 0x3B32
177:           			prod.i = prod.i >> 1;
3B04  C06B     MOVFF prod, __pcstackBANK0
3B06  F060     NOP
3B08  C06C     MOVFF 0x6C, 0x61
3B0A  F061     NOP
3B0C  C06D     MOVFF 0x6D, d
3B0E  F062     NOP
3B10  C06E     MOVFF 0x6E, 0x63
3B12  F063     NOP
3B14  3563     RLCF 0x63, W, BANKED
3B16  3363     RRCF 0x63, F, BANKED
3B18  3362     RRCF d, F, BANKED
3B1A  3361     RRCF 0x61, F, BANKED
3B1C  3360     RRCF __pcstackBANK0, F, BANKED
3B1E  C060     MOVFF __pcstackBANK0, prod
3B20  F06B     NOP
3B22  C061     MOVFF 0x61, 0x6C
3B24  F06C     NOP
3B26  C062     MOVFF d, 0x6D
3B28  F06D     NOP
3B2A  C063     MOVFF 0x63, 0x6E
3B2C  F06E     NOP
178:           			++temp.i;
3B2E  4B6F     INFSNZ temp, F, BANKED
3B30  2B70     INCF 0x70, F, BANKED
179:           		}
180:           	}
181:           
182:           	/* Overflow ? Return infinity */
183:           	if (!(temp.i < SPEXPM)) {
3B32  BF70     BTFSC 0x70, 7, BANKED
3B34  D00D     BRA 0x3B50
3B36  5170     MOVF 0x70, W, BANKED
3B38  E103     BNZ 0x3B40
3B3A  296F     INCF temp, W, BANKED
3B3C  A0D8     BTFSS STATUS, 0, ACCESS
3B3E  D008     BRA 0x3B50
184:           		prod.i = 0x7F800000;
3B40  0E00     MOVLW 0x0
3B42  6F6B     MOVWF prod, BANKED
3B44  0E00     MOVLW 0x0
3B46  6F6C     MOVWF 0x6C, BANKED
3B48  0E80     MOVLW 0x80
3B4A  6F6D     MOVWF 0x6D, BANKED
3B4C  0E7F     MOVLW 0x7F
3B4E  D020     BRA 0x3B90
185:           	}
186:           	/* Underflow ? Flush to zero */
187:           	else if (!(0 < temp.i)) {
3B50  BF70     BTFSC 0x70, 7, BANKED
3B52  D005     BRA 0x3B5E
3B54  5170     MOVF 0x70, W, BANKED
3B56  E10E     BNZ 0x3B74
3B58  056F     DECF temp, W, BANKED
3B5A  B0D8     BTFSC STATUS, 0, ACCESS
3B5C  D00B     BRA 0x3B74
188:           		prod.i = 0;
3B5E  0E00     MOVLW 0x0
3B60  6F6B     MOVWF prod, BANKED
3B62  0E00     MOVLW 0x0
3B64  6F6C     MOVWF 0x6C, BANKED
3B66  0E00     MOVLW 0x0
3B68  6F6D     MOVWF 0x6D, BANKED
3B6A  0E00     MOVLW 0x0
3B6C  6F6E     MOVWF 0x6E, BANKED
189:                           // no negative 0 for now
190:                           sign=0;
3B6E  0E00     MOVLW 0x0
3B70  6F64     MOVWF sign, BANKED
191:           	}
3B72  D00F     BRA 0x3B92
192:           	else {
193:           		/* Pack and return result */
194:           		bexp = temp.i;	// it fits in 8 bits !
3B74  C06F     MOVFF temp, x
3B76  F06A     NOP
195:           		prod.i &= SPFRCM;	// trim away the leading 1
3B78  0EFF     MOVLW 0xFF
3B7A  176B     ANDWF prod, F, BANKED
3B7C  0EFF     MOVLW 0xFF
3B7E  176C     ANDWF 0x6C, F, BANKED
3B80  0E7F     MOVLW 0x7F
3B82  176D     ANDWF 0x6D, F, BANKED
3B84  0E00     MOVLW 0x0
3B86  176E     ANDWF 0x6E, F, BANKED
196:           		if (bexp & 0x1) {
3B88  B16A     BTFSC x, 0, BANKED
197:           			prod.fAsBytes.c |= 0x80;
3B8A  8F6D     BSF 0x6D, 7, BANKED
198:           		}
199:           		prod.fAsBytes.d = bexp >> 1;
3B8C  90D8     BCF STATUS, 0, ACCESS
3B8E  316A     RRCF x, W, BANKED
3B90  6F6E     MOVWF 0x6E, BANKED
200:           	}
201:           	prod.fAsBytes.d |= sign;
3B92  5164     MOVF sign, W, BANKED
3B94  136E     IORWF 0x6E, F, BANKED
202:           
203:           	return prod.f;
3B96  C06B     MOVFF prod, counter
3B98  F02D     NOP
3B9A  C06C     MOVFF 0x6C, w
3B9C  F02E     NOP
3B9E  C06D     MOVFF 0x6D, 0x2F
3BA0  F02F     NOP
3BA2  C06E     MOVFF 0x6E, cp
3BA4  F030     NOP
3BA6  0012     RETURN 0
204:           
205:           }
206:           
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/sprcdiv.c  -----------------------------------------
1:             /* SP relaxed compliance floating point divide intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             /* SP Divide */
6:             #ifdef __PICC__
7:             SP
8:             SPDIV(SP a, SP b)
9:             #else
10:            SP
11:            SPDIV(SP b, SP a)
12:            #endif
13:            {
14:            #define A_FRACTION    (*(SFP *)&a)
15:            #define B_FRACTION    (*(SFP *)&b)
16:            	unsigned char sign;	/* sign of result */
17:            
18:            	unsigned char bexp;	/* Dst exponent */
19:            	unsigned char aexp;	/* Src exponent */
20:            	int16_t new_exp;
21:            	uint32_t grs;		/* Guard, round, sticky */
22:            	uint32_t rem;
23:            
24:            	/* Unpack and check operands */
25:            	// put b's sign as the result sign ...
26:            	sign = B_FRACTION.fAsBytes.d & 0x80;
3EE2  0100     MOVLB 0x0
3EE4  5174     MOVF w, W, BANKED
3EE6  0B80     ANDLW 0x80
3EE8  6F81     MOVWF sign, BANKED
27:            	bexp = B_FRACTION.fAsBytes.d << 1;
3EEA  5174     MOVF w, W, BANKED
3EEC  2574     ADDWF w, W, BANKED
3EEE  6F88     MOVWF bexp, BANKED
28:            	if (B_FRACTION.fAsBytes.c & 0x80) {
3EF0  BF73     BTFSC 0x73, 7, BANKED
29:            		bexp |= 0x1;
3EF2  8188     BSF bexp, 0, BANKED
30:            	}
31:            
32:            	/* Destination normal ? */
33:            	if (bexp) {
3EF4  5188     MOVF bexp, W, BANKED
3EF6  B4D8     BTFSC STATUS, 2, ACCESS
3EF8  D00D     BRA 0x3F14
34:            		/* Destination inf or NaN ? */
35:            		if (bexp == 0xFF) {
3EFA  2988     INCF bexp, W, BANKED
3EFC  A4D8     BTFSS STATUS, 2, ACCESS
3EFE  D008     BRA 0x3F10
36:            			/* Make it inf */
37:            			b = 0;
3F00  0E00     MOVLW 0x0
3F02  6F71     MOVWF b, BANKED
3F04  0E00     MOVLW 0x0
3F06  6F72     MOVWF p, BANKED
3F08  0E00     MOVLW 0x0
3F0A  6F73     MOVWF 0x73, BANKED
3F0C  0E00     MOVLW 0x0
3F0E  6F74     MOVWF w, BANKED
38:            		}
39:            		// OR in the hidden 1-bit to b's fraction
40:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
3F10  8F73     BSF 0x73, 7, BANKED
41:            		// and zero out the upper byte so we can safely shift
42:            		B_FRACTION.fAsBytes.d = 0;
3F12  D006     BRA 0x3F20
43:            	}
44:            	else {
45:            		/* Make it zero */
46:            		b = 0;
3F14  0E00     MOVLW 0x0
3F16  6F71     MOVWF b, BANKED
3F18  0E00     MOVLW 0x0
3F1A  6F72     MOVWF p, BANKED
3F1C  0E00     MOVLW 0x0
3F1E  6F73     MOVWF 0x73, BANKED
3F20  0E00     MOVLW 0x0
3F22  6F74     MOVWF w, BANKED
47:            	}
48:            	// xor a's sign into the result sign
49:            	sign ^= A_FRACTION.fAsBytes.d & 0x80;
3F24  5178     MOVF n, W, BANKED
3F26  0B80     ANDLW 0x80
3F28  1B81     XORWF sign, F, BANKED
50:            	aexp = A_FRACTION.fAsBytes.d << 1;
3F2A  5178     MOVF n, W, BANKED
3F2C  2578     ADDWF n, W, BANKED
3F2E  6F89     MOVWF fmt, BANKED
51:            	if (A_FRACTION.fAsBytes.c & 0x80) {
3F30  BF77     BTFSC p, 7, BANKED
52:            		aexp |= 0x1;
3F32  8189     BSF fmt, 0, BANKED
53:            	}
54:            
55:            	/* Destination normal ? */
56:            	if (aexp) {
3F34  5189     MOVF fmt, W, BANKED
3F36  B4D8     BTFSC STATUS, 2, ACCESS
3F38  D00D     BRA 0x3F54
57:            		/* Destination inf or NaN ? */
58:            		if (aexp == 0xFF) {
3F3A  2989     INCF fmt, W, BANKED
3F3C  A4D8     BTFSS STATUS, 2, ACCESS
3F3E  D008     BRA 0x3F50
59:            			/* Make it inf */
60:            			a = 0;
3F40  0E00     MOVLW 0x0
3F42  6F75     MOVWF a, BANKED
3F44  0E00     MOVLW 0x0
3F46  6F76     MOVWF n, BANKED
3F48  0E00     MOVLW 0x0
3F4A  6F77     MOVWF p, BANKED
3F4C  0E00     MOVLW 0x0
3F4E  6F78     MOVWF n, BANKED
61:            		}
62:            		// OR in the hidden 1-bit to a's fraction
63:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
3F50  8F77     BSF p, 7, BANKED
64:            		// and zero out the upper bits so we can safely shift
65:            		A_FRACTION.fAsBytes.d = 0;
3F52  D006     BRA 0x3F60
66:            	}
67:            	else {
68:            		/* Make it zero */
69:            		a = 0;
3F54  0E00     MOVLW 0x0
3F56  6F75     MOVWF a, BANKED
3F58  0E00     MOVLW 0x0
3F5A  6F76     MOVWF n, BANKED
3F5C  0E00     MOVLW 0x0
3F5E  6F77     MOVWF p, BANKED
3F60  0E00     MOVLW 0x0
3F62  6F78     MOVWF n, BANKED
70:            	}
71:            
72:            	/* Special operand check */
73:            
74:            	/* Denominator zero ? Result infinity */
75:            	if (A_FRACTION.i == 0) {
3F64  5175     MOVF a, W, BANKED
3F66  1176     IORWF n, W, BANKED
3F68  1177     IORWF p, W, BANKED
3F6A  1178     IORWF n, W, BANKED
3F6C  A4D8     BTFSS STATUS, 2, ACCESS
3F6E  D017     BRA 0x3F9E
76:            		B_FRACTION.i = 0;
3F70  0E00     MOVLW 0x0
3F72  6F71     MOVWF b, BANKED
3F74  0E00     MOVLW 0x0
3F76  6F72     MOVWF p, BANKED
3F78  0E00     MOVLW 0x0
3F7A  6F73     MOVWF 0x73, BANKED
3F7C  0E00     MOVLW 0x0
3F7E  6F74     MOVWF w, BANKED
77:            		B_FRACTION.fAsWords.wordB |= (SPEXPM << 7);
3F80  0E80     MOVLW 0x80
3F82  1373     IORWF 0x73, F, BANKED
3F84  0E7F     MOVLW 0x7F
3F86  1374     IORWF w, F, BANKED
78:            		B_FRACTION.fAsBytes.d |= sign;
3F88  5181     MOVF sign, W, BANKED
3F8A  1374     IORWF w, F, BANKED
79:            		return b;
3F8C  C071     MOVFF b, b
3F8E  F071     NOP
3F90  C072     MOVFF p, p
3F92  F072     NOP
3F94  C073     MOVFF 0x73, 0x73
3F96  F073     NOP
3F98  C074     MOVFF w, w
3F9A  F074     NOP
3F9C  0012     RETURN 0
80:            	}
81:            
82:            	/* Numerator zero ? Result zero */
83:            	if (!bexp) {
3F9E  5188     MOVF bexp, W, BANKED
3FA0  A4D8     BTFSS STATUS, 2, ACCESS
3FA2  D011     BRA 0x3FC6
84:            		B_FRACTION.i = 0;
3FA4  0E00     MOVLW 0x0
3FA6  6F71     MOVWF b, BANKED
3FA8  0E00     MOVLW 0x0
3FAA  6F72     MOVWF p, BANKED
3FAC  0E00     MOVLW 0x0
3FAE  6F73     MOVWF 0x73, BANKED
3FB0  0E00     MOVLW 0x0
3FB2  6F74     MOVWF w, BANKED
85:            		return b;
3FB4  C071     MOVFF b, b
3FB6  F071     NOP
3FB8  C072     MOVFF p, p
3FBA  F072     NOP
3FBC  C073     MOVFF 0x73, 0x73
3FBE  F073     NOP
3FC0  C074     MOVFF w, w
3FC2  F074     NOP
3FC4  0012     RETURN 0
86:            	}
87:            
88:            	/* Subtract denominator exponent, minus bias */
89:            	new_exp = bexp - aexp + 127;
3FC6  5189     MOVF fmt, W, BANKED
3FC8  6F79     MOVWF w, BANKED
3FCA  6B7A     CLRF n, BANKED
3FCC  1F79     COMF w, F, BANKED
3FCE  1F7A     COMF n, F, BANKED
3FD0  4B79     INFSNZ w, F, BANKED
3FD2  2B7A     INCF n, F, BANKED
3FD4  5188     MOVF bexp, W, BANKED
3FD6  6F7B     MOVWF n, BANKED
3FD8  6B7C     CLRF 0x7C, BANKED
3FDA  5179     MOVF w, W, BANKED
3FDC  277B     ADDWF n, F, BANKED
3FDE  517A     MOVF n, W, BANKED
3FE0  237C     ADDWFC 0x7C, F, BANKED
3FE2  0E7F     MOVLW 0x7F
3FE4  257B     ADDWF n, W, BANKED
3FE6  6F82     MOVWF i, BANKED
3FE8  0E00     MOVLW 0x0
3FEA  217C     ADDWFC 0x7C, W, BANKED
3FEC  6F83     MOVWF i, BANKED
90:            
91:            	/* Divide loop */
92:            	rem = B_FRACTION.i;
3FEE  C071     MOVFF b, rem
3FF0  F07D     NOP
3FF2  C072     MOVFF p, i
3FF4  F07E     NOP
3FF6  C073     MOVFF 0x73, 0x7F
3FF8  F07F     NOP
3FFA  C074     MOVFF w, i
3FFC  F080     NOP
93:            	B_FRACTION.i = 0;
3FFE  0E00     MOVLW 0x0
4000  6F71     MOVWF b, BANKED
4002  0E00     MOVLW 0x0
4004  6F72     MOVWF p, BANKED
4006  0E00     MOVLW 0x0
4008  6F73     MOVWF 0x73, BANKED
400A  0E00     MOVLW 0x0
400C  6F74     MOVWF w, BANKED
94:            	grs = 0;
400E  0E00     MOVLW 0x0
4010  6F84     MOVWF grs, BANKED
4012  0E00     MOVLW 0x0
4014  6F85     MOVWF c, BANKED
4016  0E00     MOVLW 0x0
4018  6F86     MOVWF 0x86, BANKED
401A  0E00     MOVLW 0x0
401C  6F87     MOVWF fp, BANKED
95:            	// reuse aexp as the loop counter ...
96:            	aexp = 0;
401E  0E00     MOVLW 0x0
4020  6F89     MOVWF fmt, BANKED
97:            	while (aexp < 26) {
4022  D028     BRA 0x4074
98:            
99:            		/* Shift remainder, quotient left */
100:           		if (aexp) {
4024  5189     MOVF fmt, W, BANKED
4026  B4D8     BTFSC STATUS, 2, ACCESS
4028  D011     BRA 0x404C
101:           			rem <<= 1;
402A  90D8     BCF STATUS, 0, ACCESS
402C  377D     RLCF rem, F, BANKED
402E  377E     RLCF i, F, BANKED
4030  377F     RLCF 0x7F, F, BANKED
4032  3780     RLCF i, F, BANKED
102:           			B_FRACTION.i <<= 1;
4034  90D8     BCF STATUS, 0, ACCESS
4036  3771     RLCF b, F, BANKED
4038  3772     RLCF p, F, BANKED
403A  3773     RLCF 0x73, F, BANKED
403C  3774     RLCF w, F, BANKED
103:           			if (grs & 0x80000000) {
403E  BF87     BTFSC fp, 7, BANKED
104:           				B_FRACTION.i |= 0x1;
4040  8171     BSF b, 0, BANKED
105:           			}
106:           			grs <<= 1;
4042  90D8     BCF STATUS, 0, ACCESS
4044  3784     RLCF grs, F, BANKED
4046  3785     RLCF c, F, BANKED
4048  3786     RLCF 0x86, F, BANKED
404A  3787     RLCF fp, F, BANKED
107:           		}
108:           
109:           		/* Restoring divide */
110:           
111:           		/* Remainder not less than divisor ? */
112:           		if (!(rem < A_FRACTION.i)) {
404C  5175     MOVF a, W, BANKED
404E  5D7D     SUBWF rem, W, BANKED
4050  5176     MOVF n, W, BANKED
4052  597E     SUBWFB i, W, BANKED
4054  5177     MOVF p, W, BANKED
4056  597F     SUBWFB 0x7F, W, BANKED
4058  5178     MOVF n, W, BANKED
405A  5980     SUBWFB i, W, BANKED
405C  A0D8     BTFSS STATUS, 0, ACCESS
405E  D009     BRA 0x4072
113:           
114:           			/* Set quotient bit, subtract divisor */
115:           			grs |= 0x40000000;
4060  8D87     BSF fp, 6, BANKED
116:           			rem -= A_FRACTION.i;
4062  5175     MOVF a, W, BANKED
4064  5F7D     SUBWF rem, F, BANKED
4066  5176     MOVF n, W, BANKED
4068  5B7E     SUBWFB i, F, BANKED
406A  5177     MOVF p, W, BANKED
406C  5B7F     SUBWFB 0x7F, F, BANKED
406E  5178     MOVF n, W, BANKED
4070  5B80     SUBWFB i, F, BANKED
117:           		}
118:           		++aexp;
4072  2B89     INCF fmt, F, BANKED
119:           	}
4074  0E19     MOVLW 0x19
4076  6589     CPFSGT fmt, BANKED
4078  D7D5     BRA 0x4024
120:           
121:           	/* Sticky bit is nonzero remainder */
122:           	if (rem) {
407A  517D     MOVF rem, W, BANKED
407C  117E     IORWF i, W, BANKED
407E  117F     IORWF 0x7F, W, BANKED
4080  1180     IORWF i, W, BANKED
4082  B4D8     BTFSC STATUS, 2, ACCESS
4084  D011     BRA 0x40A8
123:           		grs |= 1;
4086  8184     BSF grs, 0, BANKED
124:           	}
125:           
126:           	/* Renormalize */
127:           	while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
4088  D00F     BRA 0x40A8
128:           		B_FRACTION.i <<= 1;
408A  90D8     BCF STATUS, 0, ACCESS
408C  3771     RLCF b, F, BANKED
408E  3772     RLCF p, F, BANKED
4090  3773     RLCF 0x73, F, BANKED
4092  3774     RLCF w, F, BANKED
129:           		if (grs & 0x80000000) {
4094  BF87     BTFSC fp, 7, BANKED
130:           			B_FRACTION.i |= 0x1;
4096  8171     BSF b, 0, BANKED
131:           		}
132:           		grs <<= 1;
4098  90D8     BCF STATUS, 0, ACCESS
409A  3784     RLCF grs, F, BANKED
409C  3785     RLCF c, F, BANKED
409E  3786     RLCF 0x86, F, BANKED
40A0  3787     RLCF fp, F, BANKED
133:           		--new_exp;
40A2  0782     DECF i, F, BANKED
40A4  A0D8     BTFSS STATUS, 0, ACCESS
40A6  0783     DECF i, F, BANKED
134:           	}
40A8  AF73     BTFSS 0x73, 7, BANKED
40AA  D7EF     BRA 0x408A
135:           
136:           	/* Round result and check overflow, underflow */
137:           	/* Round */
138:           	// reuse aexp again as the round-up flag ...
139:           	aexp = 0;
40AC  0E00     MOVLW 0x0
40AE  6F89     MOVWF fmt, BANKED
140:           	if (grs & ((uint32_t) 1 << 31)) {
40B0  AF87     BTFSS fp, 7, BANKED
40B2  D016     BRA 0x40E0
141:           		if (grs & (((uint32_t) 1 << 31) - 1)) {
40B4  0EFF     MOVLW 0xFF
40B6  1584     ANDWF grs, W, BANKED
40B8  6F79     MOVWF w, BANKED
40BA  0EFF     MOVLW 0xFF
40BC  1585     ANDWF c, W, BANKED
40BE  6F7A     MOVWF n, BANKED
40C0  0EFF     MOVLW 0xFF
40C2  1586     ANDWF 0x86, W, BANKED
40C4  6F7B     MOVWF n, BANKED
40C6  0E7F     MOVLW 0x7F
40C8  1587     ANDWF fp, W, BANKED
40CA  6F7C     MOVWF 0x7C, BANKED
40CC  5179     MOVF w, W, BANKED
40CE  117A     IORWF n, W, BANKED
40D0  117B     IORWF n, W, BANKED
40D2  117C     IORWF 0x7C, W, BANKED
40D4  A4D8     BTFSS STATUS, 2, ACCESS
142:           			aexp = 1;
40D6  D002     BRA 0x40DC
143:           		}
144:           		else {
145:           			if (B_FRACTION.i & 1) {
40D8  A171     BTFSS b, 0, BANKED
40DA  D002     BRA 0x40E0
146:           				aexp = 1;
40DC  0E01     MOVLW 0x1
40DE  6F89     MOVWF fmt, BANKED
147:           			}
148:           		}
149:           	}
150:           	if (aexp) {
40E0  5189     MOVF fmt, W, BANKED
40E2  B4D8     BTFSC STATUS, 2, ACCESS
40E4  D01F     BRA 0x4124
151:           		++B_FRACTION.i;
40E6  0E01     MOVLW 0x1
40E8  2771     ADDWF b, F, BANKED
40EA  0E00     MOVLW 0x0
40EC  2372     ADDWFC p, F, BANKED
40EE  2373     ADDWFC 0x73, F, BANKED
40F0  2374     ADDWFC w, F, BANKED
152:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
40F2  A174     BTFSS w, 0, BANKED
40F4  D017     BRA 0x4124
153:           			B_FRACTION.i = B_FRACTION.i >> 1;
40F6  C071     MOVFF b, w
40F8  F079     NOP
40FA  C072     MOVFF p, n
40FC  F07A     NOP
40FE  C073     MOVFF 0x73, n
4100  F07B     NOP
4102  C074     MOVFF w, 0x7C
4104  F07C     NOP
4106  357C     RLCF 0x7C, W, BANKED
4108  337C     RRCF 0x7C, F, BANKED
410A  337B     RRCF n, F, BANKED
410C  337A     RRCF n, F, BANKED
410E  3379     RRCF w, F, BANKED
4110  C079     MOVFF w, b
4112  F071     NOP
4114  C07A     MOVFF n, p
4116  F072     NOP
4118  C07B     MOVFF n, 0x73
411A  F073     NOP
411C  C07C     MOVFF 0x7C, w
411E  F074     NOP
154:           			++new_exp;
4120  4B82     INFSNZ i, F, BANKED
4122  2B83     INCF i, F, BANKED
155:           		}
156:           	}
157:           
158:           	/* Overflow ? Return infinity */
159:           	if (!(new_exp < SPEXPM)) {
4124  BF83     BTFSC i, 7, BANKED
4126  D010     BRA 0x4148
4128  5183     MOVF i, W, BANKED
412A  E103     BNZ 0x4132
412C  2982     INCF i, W, BANKED
412E  A0D8     BTFSS STATUS, 0, ACCESS
4130  D00B     BRA 0x4148
160:           		new_exp = SPEXPM;
4132  0E00     MOVLW 0x0
4134  6F83     MOVWF i, BANKED
4136  6982     SETF i, BANKED
161:           		B_FRACTION.i = 0;
4138  0E00     MOVLW 0x0
413A  6F71     MOVWF b, BANKED
413C  0E00     MOVLW 0x0
413E  6F72     MOVWF p, BANKED
4140  0E00     MOVLW 0x0
4142  6F73     MOVWF 0x73, BANKED
4144  0E00     MOVLW 0x0
4146  6F74     MOVWF w, BANKED
162:           	}
163:           
164:           	/* Underflow ? Flush to zero */
165:           	if (!(0 < new_exp)) {
4148  BF83     BTFSC i, 7, BANKED
414A  D005     BRA 0x4156
414C  5183     MOVF i, W, BANKED
414E  E111     BNZ 0x4172
4150  0582     DECF i, W, BANKED
4152  B0D8     BTFSC STATUS, 0, ACCESS
4154  D00E     BRA 0x4172
166:           		new_exp = 0;
4156  0E00     MOVLW 0x0
4158  6F83     MOVWF i, BANKED
415A  0E00     MOVLW 0x0
415C  6F82     MOVWF i, BANKED
167:           		B_FRACTION.i = 0;
415E  0E00     MOVLW 0x0
4160  6F71     MOVWF b, BANKED
4162  0E00     MOVLW 0x0
4164  6F72     MOVWF p, BANKED
4166  0E00     MOVLW 0x0
4168  6F73     MOVWF 0x73, BANKED
416A  0E00     MOVLW 0x0
416C  6F74     MOVWF w, BANKED
168:                           // no negative fp 0 for now
169:                           sign = 0;
416E  0E00     MOVLW 0x0
4170  6F81     MOVWF sign, BANKED
170:           	}
171:           
172:           	/* Pack and return result */
173:           	bexp = new_exp;
4172  C082     MOVFF i, bexp
4174  F088     NOP
174:           	// set the low bit of the exponent ...
175:           	if (bexp & 0x1) {
4176  A188     BTFSS bexp, 0, BANKED
4178  D002     BRA 0x417E
176:           		B_FRACTION.fAsBytes.c |= 0x80;
417A  8F73     BSF 0x73, 7, BANKED
177:           	}
417C  D001     BRA 0x4180
178:           	// AND out the leading 1
179:           	else {
180:           		B_FRACTION.fAsBytes.c &= 0x7F;
417E  9F73     BCF 0x73, 7, BANKED
181:           	}
182:           	B_FRACTION.fAsBytes.d = bexp >> 1;
4180  90D8     BCF STATUS, 0, ACCESS
4182  3188     RRCF bexp, W, BANKED
4184  6F74     MOVWF w, BANKED
183:           	B_FRACTION.fAsBytes.d |= sign;
4186  5181     MOVF sign, W, BANKED
4188  1374     IORWF w, F, BANKED
184:           	return b;
418A  C071     MOVFF b, b
418C  F071     NOP
418E  C072     MOVFF p, p
4190  F072     NOP
4192  C073     MOVFF 0x73, 0x73
4194  F073     NOP
4196  C074     MOVFF w, w
4198  F074     NOP
419A  0012     RETURN 0
185:           }
186:           
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/sprcadd.c  -----------------------------------------
1:             /* SP relaxed compliance floating point add intrinsic function */
2:             #include <stdint.h>
3:             #include "fpform.h"
4:             
5:             
6:             // single monlithic add function
7:             
8:             /* SP Add */
9:             SP
10:            SPADD(SP b, SP a) {
11:            #define A_FRACTION    (*(SFP *)&a)
12:            #define B_FRACTION    (*(SFP *)&b)
13:            	unsigned char signs;	/* leftmost bit stores sign of b, next bit stores
14:            				   0 if and only if a and b have the same sign  */
15:            	unsigned char bexp;	/* Dst exponent */
16:            	unsigned char aexp;	/* Src exponent */
17:            	unsigned char grs;	/* Guard, round, sticky */
18:            
19:            
20:            	/* Unpack and check operands */
21:            	signs = B_FRACTION.fAsBytes.d & 0x80;
3BA8  501C     MOVF c, W, ACCESS
3BAA  0B80     ANDLW 0x80
3BAC  6E29     MOVWF buf, ACCESS
22:            	bexp = B_FRACTION.fAsBytes.d << 1;
3BAE  501C     MOVF c, W, ACCESS
3BB0  241C     ADDWF c, W, ACCESS
3BB2  6E2B     MOVWF p, ACCESS
23:            	if (B_FRACTION.fAsBytes.c & 0x80) {
3BB4  BE1B     BTFSC c, 7, ACCESS
24:            		bexp |= 0x1;
3BB6  802B     BSF p, 0, ACCESS
25:            	}
26:            
27:            	/* Destination normal ? */
28:            	if (bexp) {
3BB8  502B     MOVF p, W, ACCESS
3BBA  B4D8     BTFSC STATUS, 2, ACCESS
3BBC  D00D     BRA 0x3BD8
29:            		/* Destination inf or NaN ? */
30:            		if (bexp == 0xFF) {
3BBE  282B     INCF p, W, ACCESS
3BC0  A4D8     BTFSS STATUS, 2, ACCESS
3BC2  D008     BRA 0x3BD4
31:            			/* Make it inf */
32:            			b = 0;
3BC4  0E00     MOVLW 0x0
3BC6  6E19     MOVWF multiplicand, ACCESS
3BC8  0E00     MOVLW 0x0
3BCA  6E1A     MOVWF s, ACCESS
3BCC  0E00     MOVLW 0x0
3BCE  6E1B     MOVWF c, ACCESS
3BD0  0E00     MOVLW 0x0
3BD2  6E1C     MOVWF c, ACCESS
33:            		}
34:            		// OR in the hidden 1-bit to b's fraction
35:            		B_FRACTION.i |= (int32_t) 1 << SPFRCB;
3BD4  8E1B     BSF c, 7, ACCESS
36:            		// and zero out the upper byte so we can safely shift
37:            		B_FRACTION.fAsBytes.d = 0;
3BD6  D006     BRA 0x3BE4
38:            	}
39:            	else {
40:            		/* Make it zero */
41:            		b = 0;
3BD8  0E00     MOVLW 0x0
3BDA  6E19     MOVWF multiplicand, ACCESS
3BDC  0E00     MOVLW 0x0
3BDE  6E1A     MOVWF s, ACCESS
3BE0  0E00     MOVLW 0x0
3BE2  6E1B     MOVWF c, ACCESS
3BE4  0E00     MOVLW 0x0
3BE6  6E1C     MOVWF c, ACCESS
42:            	}
43:            
44:            	aexp = A_FRACTION.fAsBytes.d & 0x80;
3BE8  5020     MOVF r, W, ACCESS
3BEA  0B80     ANDLW 0x80
3BEC  6E2A     MOVWF aexp, ACCESS
45:            	// sign of a different from sign of b?
46:            	if (aexp != signs) {
3BEE  5029     MOVF buf, W, ACCESS
3BF0  182A     XORWF aexp, W, ACCESS
3BF2  A4D8     BTFSS STATUS, 2, ACCESS
47:            		signs |= 0x40;
3BF4  8C29     BSF buf, 6, ACCESS
48:            	}
49:            	aexp = A_FRACTION.fAsBytes.d << 1;
3BF6  5020     MOVF r, W, ACCESS
3BF8  2420     ADDWF r, W, ACCESS
3BFA  6E2A     MOVWF aexp, ACCESS
50:            	if (A_FRACTION.fAsBytes.c & 0x80) {
3BFC  BE1F     BTFSC i, 7, ACCESS
51:            		aexp |= 0x1;
3BFE  802A     BSF aexp, 0, ACCESS
52:            	}
53:            
54:            	/* Destination normal ? */
55:            	if (aexp) {
3C00  502A     MOVF aexp, W, ACCESS
3C02  B4D8     BTFSC STATUS, 2, ACCESS
3C04  D00D     BRA 0x3C20
56:            		/* Destination inf or NaN ? */
57:            		if (aexp == 0xFF) {
3C06  282A     INCF aexp, W, ACCESS
3C08  A4D8     BTFSS STATUS, 2, ACCESS
3C0A  D008     BRA 0x3C1C
58:            			/* Make it inf */
59:            			a = 0;
3C0C  0E00     MOVLW 0x0
3C0E  6E1D     MOVWF divisor, ACCESS
3C10  0E00     MOVLW 0x0
3C12  6E1E     MOVWF l, ACCESS
3C14  0E00     MOVLW 0x0
3C16  6E1F     MOVWF i, ACCESS
3C18  0E00     MOVLW 0x0
3C1A  6E20     MOVWF r, ACCESS
60:            		}
61:            		// OR in the hidden 1-bit to a's fraction
62:            		A_FRACTION.i |= (int32_t) 1 << SPFRCB;
3C1C  8E1F     BSF i, 7, ACCESS
63:            		// and zero out the upper bits so we can safely shift
64:            		A_FRACTION.fAsBytes.d = 0;
3C1E  D006     BRA 0x3C2C
65:            	}
66:            	else {
67:            		/* Make it zero */
68:            		a = 0;
3C20  0E00     MOVLW 0x0
3C22  6E1D     MOVWF divisor, ACCESS
3C24  0E00     MOVLW 0x0
3C26  6E1E     MOVWF l, ACCESS
3C28  0E00     MOVLW 0x0
3C2A  6E1F     MOVWF i, ACCESS
3C2C  0E00     MOVLW 0x0
3C2E  6E20     MOVWF r, ACCESS
69:            	}
70:            
71:            	/* Add */
72:            
73:            	/* Get smaller operand in b */
74:            
75:            	if (aexp < bexp) {
3C30  502B     MOVF p, W, ACCESS
3C32  5C2A     SUBWF aexp, W, ACCESS
3C34  B0D8     BTFSC STATUS, 0, ACCESS
3C36  D022     BRA 0x3C7C
76:            		// do I need to reverse the sign?
77:            		if (signs & 0x40) {
3C38  AC29     BTFSS buf, 6, ACCESS
3C3A  D002     BRA 0x3C40
78:            			signs ^= 0x80;
3C3C  0E80     MOVLW 0x80
3C3E  1A29     XORWF buf, F, ACCESS
79:            		}
80:            		// use  grs as swap space
81:            		grs = bexp;
3C40  C02B     MOVFF p, i
3C42  F02C     NOP
82:            		bexp = aexp;
3C44  C02A     MOVFF aexp, p
3C46  F02B     NOP
83:            		aexp = grs;
3C48  C02C     MOVFF i, aexp
3C4A  F02A     NOP
84:            		grs = B_FRACTION.fAsBytes.a;
3C4C  C019     MOVFF multiplicand, i
3C4E  F02C     NOP
85:            		B_FRACTION.fAsBytes.a = A_FRACTION.fAsBytes.a;
3C50  C01D     MOVFF divisor, multiplicand
3C52  F019     NOP
86:            		A_FRACTION.fAsBytes.a = grs;
3C54  C02C     MOVFF i, divisor
3C56  F01D     NOP
87:            		grs = B_FRACTION.fAsBytes.b;
3C58  C01A     MOVFF s, i
3C5A  F02C     NOP
88:            		B_FRACTION.fAsBytes.b = A_FRACTION.fAsBytes.b;
3C5C  C01E     MOVFF l, s
3C5E  F01A     NOP
89:            		A_FRACTION.fAsBytes.b = grs;
3C60  C02C     MOVFF i, l
3C62  F01E     NOP
90:            		grs = B_FRACTION.fAsBytes.c;
3C64  C01B     MOVFF c, i
3C66  F02C     NOP
91:            		B_FRACTION.fAsBytes.c = A_FRACTION.fAsBytes.c;
3C68  C01F     MOVFF i, c
3C6A  F01B     NOP
92:            		A_FRACTION.fAsBytes.c = grs;
3C6C  C02C     MOVFF i, i
3C6E  F01F     NOP
93:            		grs = B_FRACTION.fAsBytes.d;
3C70  C01C     MOVFF c, i
3C72  F02C     NOP
94:            		B_FRACTION.fAsBytes.d = A_FRACTION.fAsBytes.d;
3C74  C020     MOVFF r, c
3C76  F01C     NOP
95:            		A_FRACTION.fAsBytes.d = grs;
3C78  C02C     MOVFF i, r
3C7A  F020     NOP
96:            	}
97:            
98:            	grs = 0;
3C7C  0E00     MOVLW 0x0
3C7E  6E2C     MOVWF i, ACCESS
99:            	/* If all ones will shift through G,R, then S = significand nonzero */
100:           	if ((aexp - bexp) > (SPFRCB + 2)) {
3C80  502B     MOVF p, W, ACCESS
3C82  6E21     MOVWF s, ACCESS
3C84  6A22     CLRF s, ACCESS
3C86  1E21     COMF s, F, ACCESS
3C88  1E22     COMF s, F, ACCESS
3C8A  4A21     INFSNZ s, F, ACCESS
3C8C  2A22     INCF s, F, ACCESS
3C8E  502A     MOVF aexp, W, ACCESS
3C90  6E23     MOVWF sep, ACCESS
3C92  6A24     CLRF n, ACCESS
3C94  5021     MOVF s, W, ACCESS
3C96  2623     ADDWF sep, F, ACCESS
3C98  5022     MOVF s, W, ACCESS
3C9A  2224     ADDWFC n, F, ACCESS
3C9C  BE24     BTFSC n, 7, ACCESS
3C9E  D02C     BRA 0x3CF8
3CA0  5024     MOVF n, W, ACCESS
3CA2  E104     BNZ 0x3CAC
3CA4  0E1A     MOVLW 0x1A
3CA6  5C23     SUBWF sep, W, ACCESS
3CA8  A0D8     BTFSS STATUS, 0, ACCESS
3CAA  D026     BRA 0x3CF8
101:           		grs = B_FRACTION.i ? 1 : 0;
3CAC  5019     MOVF multiplicand, W, ACCESS
3CAE  101A     IORWF s, W, ACCESS
3CB0  101B     IORWF c, W, ACCESS
3CB2  101C     IORWF c, W, ACCESS
3CB4  B4D8     BTFSC STATUS, 2, ACCESS
3CB6  D002     BRA 0x3CBC
3CB8  0E01     MOVLW 0x1
3CBA  D001     BRA 0x3CBE
3CBC  0E00     MOVLW 0x0
3CBE  6E2C     MOVWF i, ACCESS
102:           		B_FRACTION.i = 0;
3CC0  0E00     MOVLW 0x0
3CC2  6E19     MOVWF multiplicand, ACCESS
3CC4  0E00     MOVLW 0x0
3CC6  6E1A     MOVWF s, ACCESS
3CC8  0E00     MOVLW 0x0
3CCA  6E1B     MOVWF c, ACCESS
3CCC  0E00     MOVLW 0x0
3CCE  6E1C     MOVWF c, ACCESS
103:           		bexp = aexp;
3CD0  C02A     MOVFF aexp, p
3CD2  F02B     NOP
104:           	}
3CD4  D015     BRA 0x3D00
105:           	else {
106:           		while (bexp < aexp) {
107:           			/* Shift smaller operand right until exponents equal */
108:           			/* save the bits shifted out in grs    */
109:           			if (grs & 1) {
3CD6  A02C     BTFSS i, 0, ACCESS
3CD8  D005     BRA 0x3CE4
110:           				grs = (grs >> 1) | 0x1;
3CDA  90D8     BCF STATUS, 0, ACCESS
3CDC  302C     RRCF i, W, ACCESS
3CDE  0901     IORLW 0x1
3CE0  6E2C     MOVWF i, ACCESS
111:           			}
3CE2  D002     BRA 0x3CE8
112:           			else {
113:           				grs >>= 1;
3CE4  90D8     BCF STATUS, 0, ACCESS
3CE6  322C     RRCF i, F, ACCESS
114:           			}
115:           			if (B_FRACTION.i & 0x1) {
3CE8  B019     BTFSC multiplicand, 0, ACCESS
116:           				grs |= 0x80;
3CEA  8E2C     BSF i, 7, ACCESS
117:           			}
118:           			B_FRACTION.i >>= 1;
3CEC  341C     RLCF c, W, ACCESS
3CEE  321C     RRCF c, F, ACCESS
3CF0  321B     RRCF c, F, ACCESS
3CF2  321A     RRCF s, F, ACCESS
3CF4  3219     RRCF multiplicand, F, ACCESS
119:           			bexp++;
3CF6  2A2B     INCF p, F, ACCESS
120:           		}
3CF8  502A     MOVF aexp, W, ACCESS
3CFA  5C2B     SUBWF p, W, ACCESS
3CFC  A0D8     BTFSS STATUS, 0, ACCESS
3CFE  D7EB     BRA 0x3CD6
121:           	}
122:           
123:           	/* Add or subtract magnitude ? */
124:           	if (!(signs & 0x40)) {
3D00  BC29     BTFSC buf, 6, ACCESS
3D02  D028     BRA 0x3D54
125:           
126:           		/* Quick exit for 0 + 0, same sign */
127:           		if (!bexp) {
3D04  502B     MOVF p, W, ACCESS
3D06  A4D8     BTFSS STATUS, 2, ACCESS
3D08  D009     BRA 0x3D1C
128:           			return 0.0;
3D0A  0E00     MOVLW 0x0
3D0C  6E19     MOVWF multiplicand, ACCESS
3D0E  0E00     MOVLW 0x0
3D10  6E1A     MOVWF s, ACCESS
3D12  0E00     MOVLW 0x0
3D14  6E1B     MOVWF c, ACCESS
3D16  0E00     MOVLW 0x0
3D18  6E1C     MOVWF c, ACCESS
3D1A  0012     RETURN 0
129:           		}
130:           
131:           		/* Add magnitude */
132:           		B_FRACTION.i += A_FRACTION.i;
3D1C  501D     MOVF divisor, W, ACCESS
3D1E  2619     ADDWF multiplicand, F, ACCESS
3D20  501E     MOVF l, W, ACCESS
3D22  221A     ADDWFC s, F, ACCESS
3D24  501F     MOVF i, W, ACCESS
3D26  221B     ADDWFC c, F, ACCESS
3D28  5020     MOVF r, W, ACCESS
3D2A  221C     ADDWFC c, F, ACCESS
133:           		// did it overflow?
134:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
3D2C  A01C     BTFSS c, 0, ACCESS
3D2E  D082     BRA 0x3E34
135:           			if (grs & 1) {
3D30  A02C     BTFSS i, 0, ACCESS
3D32  D005     BRA 0x3D3E
136:           				grs = (grs >> 1) | 0x1;
3D34  90D8     BCF STATUS, 0, ACCESS
3D36  302C     RRCF i, W, ACCESS
3D38  0901     IORLW 0x1
3D3A  6E2C     MOVWF i, ACCESS
137:           			}
3D3C  D002     BRA 0x3D42
138:           			else {
139:           				grs >>= 1;
3D3E  90D8     BCF STATUS, 0, ACCESS
3D40  322C     RRCF i, F, ACCESS
140:           			}
141:           			if (B_FRACTION.i & 1) {
3D42  B019     BTFSC multiplicand, 0, ACCESS
142:           				grs |= 0x80;
3D44  8E2C     BSF i, 7, ACCESS
143:           			}
144:           			B_FRACTION.i >>= 1;
3D46  341C     RLCF c, W, ACCESS
3D48  321C     RRCF c, F, ACCESS
3D4A  321B     RRCF c, F, ACCESS
3D4C  321A     RRCF s, F, ACCESS
3D4E  3219     RRCF multiplicand, F, ACCESS
145:           			++bexp;
3D50  2A2B     INCF p, F, ACCESS
146:           		}
147:           
148:           	}
3D52  D070     BRA 0x3E34
149:           	else {
150:           
151:           		/* Subtract magnitude */
152:           
153:           		if (B_FRACTION.i < A_FRACTION.i) {
3D54  501D     MOVF divisor, W, ACCESS
3D56  5C19     SUBWF multiplicand, W, ACCESS
3D58  501E     MOVF l, W, ACCESS
3D5A  581A     SUBWFB s, W, ACCESS
3D5C  501F     MOVF i, W, ACCESS
3D5E  581B     SUBWFB c, W, ACCESS
3D60  501C     MOVF c, W, ACCESS
3D62  0A80     XORLW 0x80
3D64  6E21     MOVWF s, ACCESS
3D66  5020     MOVF r, W, ACCESS
3D68  0A80     XORLW 0x80
3D6A  5821     SUBWFB s, W, ACCESS
3D6C  B0D8     BTFSC STATUS, 0, ACCESS
3D6E  D036     BRA 0x3DDC
154:           			B_FRACTION.i = A_FRACTION.i - B_FRACTION.i - 1;
3D70  C019     MOVFF multiplicand, s
3D72  F021     NOP
3D74  C01A     MOVFF s, s
3D76  F022     NOP
3D78  C01B     MOVFF c, sep
3D7A  F023     NOP
3D7C  C01C     MOVFF c, n
3D7E  F024     NOP
3D80  1E21     COMF s, F, ACCESS
3D82  1E22     COMF s, F, ACCESS
3D84  1E23     COMF sep, F, ACCESS
3D86  1E24     COMF n, F, ACCESS
3D88  2A21     INCF s, F, ACCESS
3D8A  0E00     MOVLW 0x0
3D8C  2222     ADDWFC s, F, ACCESS
3D8E  2223     ADDWFC sep, F, ACCESS
3D90  2224     ADDWFC n, F, ACCESS
3D92  501D     MOVF divisor, W, ACCESS
3D94  2421     ADDWF s, W, ACCESS
3D96  6E25     MOVWF quotient, ACCESS
3D98  501E     MOVF l, W, ACCESS
3D9A  2022     ADDWFC s, W, ACCESS
3D9C  6E26     MOVWF sign, ACCESS
3D9E  501F     MOVF i, W, ACCESS
3DA0  2023     ADDWFC sep, W, ACCESS
3DA2  6E27     MOVWF quotient, ACCESS
3DA4  5020     MOVF r, W, ACCESS
3DA6  2024     ADDWFC n, W, ACCESS
3DA8  6E28     MOVWF 0x28, ACCESS
3DAA  0EFF     MOVLW 0xFF
3DAC  2425     ADDWF quotient, W, ACCESS
3DAE  6E19     MOVWF multiplicand, ACCESS
3DB0  0EFF     MOVLW 0xFF
3DB2  2026     ADDWFC sign, W, ACCESS
3DB4  6E1A     MOVWF s, ACCESS
3DB6  0EFF     MOVLW 0xFF
3DB8  2027     ADDWFC quotient, W, ACCESS
3DBA  6E1B     MOVWF c, ACCESS
3DBC  0EFF     MOVLW 0xFF
3DBE  2028     ADDWFC 0x28, W, ACCESS
3DC0  6E1C     MOVWF c, ACCESS
155:           			signs ^= 0x80;
3DC2  0E80     MOVLW 0x80
3DC4  1A29     XORWF buf, F, ACCESS
156:           			grs = ~grs + 1;
3DC6  6C2C     NEGF i, ACCESS
157:           			if (!grs) {
3DC8  502C     MOVF i, W, ACCESS
3DCA  A4D8     BTFSS STATUS, 2, ACCESS
3DCC  D00F     BRA 0x3DEC
158:           				++B_FRACTION.i;
3DCE  0E01     MOVLW 0x1
3DD0  2619     ADDWF multiplicand, F, ACCESS
3DD2  0E00     MOVLW 0x0
3DD4  221A     ADDWFC s, F, ACCESS
3DD6  221B     ADDWFC c, F, ACCESS
3DD8  221C     ADDWFC c, F, ACCESS
159:           			}
160:           		}
3DDA  D008     BRA 0x3DEC
161:           		else {
162:           			B_FRACTION.i -= A_FRACTION.i;
3DDC  501D     MOVF divisor, W, ACCESS
3DDE  5E19     SUBWF multiplicand, F, ACCESS
3DE0  501E     MOVF l, W, ACCESS
3DE2  5A1A     SUBWFB s, F, ACCESS
3DE4  501F     MOVF i, W, ACCESS
3DE6  5A1B     SUBWFB c, F, ACCESS
3DE8  5020     MOVF r, W, ACCESS
3DEA  5A1C     SUBWFB c, F, ACCESS
163:           		}
164:           
165:           		/* True zero ? */
166:           		if (!B_FRACTION.i && !grs) {
3DEC  5019     MOVF multiplicand, W, ACCESS
3DEE  101A     IORWF s, W, ACCESS
3DF0  101B     IORWF c, W, ACCESS
3DF2  101C     IORWF c, W, ACCESS
3DF4  A4D8     BTFSS STATUS, 2, ACCESS
3DF6  D01C     BRA 0x3E30
3DF8  502C     MOVF i, W, ACCESS
3DFA  A4D8     BTFSS STATUS, 2, ACCESS
3DFC  D019     BRA 0x3E30
167:           			return 0.0;
3DFE  0E00     MOVLW 0x0
3E00  6E19     MOVWF multiplicand, ACCESS
3E02  0E00     MOVLW 0x0
3E04  6E1A     MOVWF s, ACCESS
3E06  0E00     MOVLW 0x0
3E08  6E1B     MOVWF c, ACCESS
3E0A  0E00     MOVLW 0x0
3E0C  6E1C     MOVWF c, ACCESS
3E0E  0012     RETURN 0
168:           		}
169:           
170:           		/* Renormalize */
171:           		while (!(B_FRACTION.i & ((int32_t) 1 << SPFRCB))) {
172:           			B_FRACTION.i <<= 1;
3E10  90D8     BCF STATUS, 0, ACCESS
3E12  3619     RLCF multiplicand, F, ACCESS
3E14  361A     RLCF s, F, ACCESS
3E16  361B     RLCF c, F, ACCESS
3E18  361C     RLCF c, F, ACCESS
173:           			if (grs & 0x80) {
3E1A  BE2C     BTFSC i, 7, ACCESS
174:           				B_FRACTION.i |= 0x1;
3E1C  8019     BSF multiplicand, 0, ACCESS
175:           			}
176:           			if (grs & 1) {
3E1E  A02C     BTFSS i, 0, ACCESS
3E20  D002     BRA 0x3E26
177:           				grs = (grs << 1) | 0x1;
3E22  80D8     BSF STATUS, 0, ACCESS
3E24  D001     BRA 0x3E28
178:           			}
179:           			else {
180:           				grs <<= 1;
3E26  90D8     BCF STATUS, 0, ACCESS
3E28  362C     RLCF i, F, ACCESS
181:           			}
182:           			if (bexp) {
3E2A  502B     MOVF p, W, ACCESS
3E2C  A4D8     BTFSS STATUS, 2, ACCESS
183:           				--bexp;
3E2E  062B     DECF p, F, ACCESS
184:           			}
3E30  AE1B     BTFSS c, 7, ACCESS
3E32  D7EE     BRA 0x3E10
185:           		}
186:           	}
187:           
188:           	/* Round, check overflow, underflow */
189:           
190:           	/* Round */
191:           	// reuse aexp as the rounding flag ...
192:           	aexp = 0;
3E34  0E00     MOVLW 0x0
3E36  6E2A     MOVWF aexp, ACCESS
193:           	if (grs & 0x80) {
3E38  AE2C     BTFSS i, 7, ACCESS
3E3A  D00A     BRA 0x3E50
194:           		if (grs & 0x7f) {
3E3C  C02C     MOVFF i, s
3E3E  F021     NOP
3E40  0E7F     MOVLW 0x7F
3E42  1621     ANDWF s, F, ACCESS
3E44  A4D8     BTFSS STATUS, 2, ACCESS
195:           			aexp = 1;
3E46  D002     BRA 0x3E4C
196:           		}
197:           		else {
198:           			if (B_FRACTION.i & 1) {
3E48  A019     BTFSS multiplicand, 0, ACCESS
3E4A  D002     BRA 0x3E50
199:           				aexp = 1;
3E4C  0E01     MOVLW 0x1
3E4E  6E2A     MOVWF aexp, ACCESS
200:           			}
201:           		}
202:           	}
203:           	if (aexp) {
3E50  502A     MOVF aexp, W, ACCESS
3E52  B4D8     BTFSC STATUS, 2, ACCESS
3E54  D020     BRA 0x3E96
204:           		++B_FRACTION.i;
3E56  0E01     MOVLW 0x1
3E58  2619     ADDWF multiplicand, F, ACCESS
3E5A  0E00     MOVLW 0x0
3E5C  221A     ADDWFC s, F, ACCESS
3E5E  221B     ADDWFC c, F, ACCESS
3E60  221C     ADDWFC c, F, ACCESS
205:           		if (B_FRACTION.i & ((int32_t) 1 << (SPFRCB + 1))) {
3E62  A01C     BTFSS c, 0, ACCESS
3E64  D018     BRA 0x3E96
206:           			B_FRACTION.i = B_FRACTION.i >> 1;
3E66  C019     MOVFF multiplicand, s
3E68  F021     NOP
3E6A  C01A     MOVFF s, s
3E6C  F022     NOP
3E6E  C01B     MOVFF c, sep
3E70  F023     NOP
3E72  C01C     MOVFF c, n
3E74  F024     NOP
3E76  3424     RLCF n, W, ACCESS
3E78  3224     RRCF n, F, ACCESS
3E7A  3223     RRCF sep, F, ACCESS
3E7C  3222     RRCF s, F, ACCESS
3E7E  3221     RRCF s, F, ACCESS
3E80  C021     MOVFF s, multiplicand
3E82  F019     NOP
3E84  C022     MOVFF s, s
3E86  F01A     NOP
3E88  C023     MOVFF sep, c
3E8A  F01B     NOP
3E8C  C024     MOVFF n, c
3E8E  F01C     NOP
207:           			if (!(bexp == 0xFF)) {
3E90  282B     INCF p, W, ACCESS
3E92  A4D8     BTFSS STATUS, 2, ACCESS
208:           				++bexp;
3E94  2A2B     INCF p, F, ACCESS
209:           			}
210:           		}
211:           	}
212:           
213:           	/* Overflow ? Return infinity */
214:           	/* Underflow ? Flush to zero */
215:           	if (bexp == 0xFF || bexp == 0) {
3E96  282B     INCF p, W, ACCESS
3E98  B4D8     BTFSC STATUS, 2, ACCESS
3E9A  D003     BRA 0x3EA2
3E9C  502B     MOVF p, W, ACCESS
3E9E  A4D8     BTFSS STATUS, 2, ACCESS
3EA0  D00D     BRA 0x3EBC
216:           		B_FRACTION.i = 0;
3EA2  0E00     MOVLW 0x0
3EA4  6E19     MOVWF multiplicand, ACCESS
3EA6  0E00     MOVLW 0x0
3EA8  6E1A     MOVWF s, ACCESS
3EAA  0E00     MOVLW 0x0
3EAC  6E1B     MOVWF c, ACCESS
3EAE  0E00     MOVLW 0x0
3EB0  6E1C     MOVWF c, ACCESS
217:                           // no negative 0 for now
218:                           if (bexp == 0) {
3EB2  502B     MOVF p, W, ACCESS
3EB4  A4D8     BTFSS STATUS, 2, ACCESS
3EB6  D002     BRA 0x3EBC
219:           		        signs=0;
3EB8  0E00     MOVLW 0x0
3EBA  6E29     MOVWF buf, ACCESS
220:                           }
221:           	}
222:           
223:           	/* Pack and return result */
224:           	// set the low bit of the exponent ...
225:           	if (bexp & 0x1) {
3EBC  A02B     BTFSS p, 0, ACCESS
3EBE  D002     BRA 0x3EC4
226:           		B_FRACTION.fAsBytes.c |= 0x80;
3EC0  8E1B     BSF c, 7, ACCESS
227:           	}
3EC2  D001     BRA 0x3EC6
228:           	// AND out the leading 1
229:           	else {
230:           		B_FRACTION.fAsBytes.c &= 0x7F;
3EC4  9E1B     BCF c, 7, ACCESS
231:           	}
232:           	B_FRACTION.fAsBytes.d = bexp >> 1;
3EC6  90D8     BCF STATUS, 0, ACCESS
3EC8  302B     RRCF p, W, ACCESS
3ECA  6E1C     MOVWF c, ACCESS
233:           	if (signs & 0x80) {
3ECC  BE29     BTFSC buf, 7, ACCESS
234:           		B_FRACTION.fAsBytes.d |= 0x80;
3ECE  8E1C     BSF c, 7, ACCESS
235:           	}
236:           	return b;
3ED0  C019     MOVFF multiplicand, multiplicand
3ED2  F019     NOP
3ED4  C01A     MOVFF s, s
3ED6  F01A     NOP
3ED8  C01B     MOVFF c, c
3EDA  F01B     NOP
3EDC  C01C     MOVFF c, c
3EDE  F01C     NOP
3EE0  0012     RETURN 0
237:           }
238:           
239:           /* SP Subtract */
240:           #ifdef __PICC__
241:           SP
242:           SPSUB(SP a, SP b)
243:           #else
244:           SP
245:           SPSUB(SP b, SP a)
246:           #endif
247:           {
248:           	(*(SFP *) & a).i ^= 0x80000000; 
249:           	return __fladd(b, a);
250:           }
251:           
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/roundf.c  ------------------------------------------
1:             #include "libm.h"
2:             
3:             #if FLT_EVAL_METHOD==0
4:             #define EPS FLT_EPSILON
5:             #elif FLT_EVAL_METHOD==1
6:             #define EPS DBL_EPSILON
7:             #elif FLT_EVAL_METHOD==2
8:             #define EPS LDBL_EPSILON
9:             #endif
10:            static const float_t toint = 1/EPS;
11:            
12:            float roundf(float x)
13:            {
14:            	union {float f; uint32_t i;} u = {x};
34CE  C11A     MOVFF F521, i
34D0  F083     NOP
34D2  C11B     MOVFF 0x11B, grs
34D4  F084     NOP
34D6  C11C     MOVFF 0x11C, c
34D8  F085     NOP
34DA  C11D     MOVFF 0x11D, 0x86
34DC  F086     NOP
34DE  C071     MOVFF b, i
34E0  F083     NOP
34E2  C072     MOVFF p, grs
34E4  F084     NOP
34E6  C073     MOVFF 0x73, c
34E8  F085     NOP
34EA  C074     MOVFF w, 0x86
34EC  F086     NOP
15:            	int e = u.i >> 23 & 0xff;
34EE  C083     MOVFF i, a
34F0  F075     NOP
34F2  C084     MOVFF grs, n
34F4  F076     NOP
34F6  C085     MOVFF c, p
34F8  F077     NOP
34FA  C086     MOVFF 0x86, n
34FC  F078     NOP
34FE  0E18     MOVLW 0x18
3500  D006     BRA 0x350E
3502  0100     MOVLB 0x0
3504  90D8     BCF STATUS, 0, ACCESS
3506  3378     RRCF n, F, BANKED
3508  3377     RRCF p, F, BANKED
350A  3376     RRCF n, F, BANKED
350C  3375     RRCF a, F, BANKED
350E  2EE8     DECFSZ WREG, F, ACCESS
3510  D7F8     BRA 0x3502
3512  5175     MOVF a, W, BANKED
3514  6F7D     MOVWF rem, BANKED
3516  6B7E     CLRF i, BANKED
16:            	float_t y;
17:            
18:            	if (e >= 0x7f+23)
3518  BF7E     BTFSC i, 7, BANKED
351A  D00F     BRA 0x353A
351C  517E     MOVF i, W, BANKED
351E  E104     BNZ 0x3528
3520  0E96     MOVLW 0x96
3522  5D7D     SUBWF rem, W, BANKED
3524  A0D8     BTFSS STATUS, 0, ACCESS
3526  D009     BRA 0x353A
19:            		return x;
3528  C071     MOVFF b, b
352A  F071     NOP
352C  C072     MOVFF p, p
352E  F072     NOP
3530  C073     MOVFF 0x73, 0x73
3532  F073     NOP
3534  C074     MOVFF w, w
3536  F074     NOP
3538  0012     RETURN 0
20:            	if (u.i >> 31)
353A  C083     MOVFF i, a
353C  F075     NOP
353E  C084     MOVFF grs, n
3540  F076     NOP
3542  C085     MOVFF c, p
3544  F077     NOP
3546  C086     MOVFF 0x86, n
3548  F078     NOP
354A  0E20     MOVLW 0x20
354C  D005     BRA 0x3558
354E  90D8     BCF STATUS, 0, ACCESS
3550  3378     RRCF n, F, BANKED
3552  3377     RRCF p, F, BANKED
3554  3376     RRCF n, F, BANKED
3556  3375     RRCF a, F, BANKED
3558  2EE8     DECFSZ WREG, F, ACCESS
355A  D7F9     BRA 0x354E
355C  5175     MOVF a, W, BANKED
355E  1176     IORWF n, W, BANKED
3560  1177     IORWF p, W, BANKED
3562  1178     IORWF n, W, BANKED
3564  B4D8     BTFSC STATUS, 2, ACCESS
3566  D012     BRA 0x358C
21:            		x = -x;
3568  C071     MOVFF b, dividend
356A  F015     NOP
356C  C072     MOVFF p, Message
356E  F016     NOP
3570  C073     MOVFF 0x73, _r
3572  F017     NOP
3574  C074     MOVFF w, 0x18
3576  F018     NOP
3578  ECC3     CALL 0x6786, 0
357A  F033     NOP
357C  C015     MOVFF dividend, b
357E  F071     NOP
3580  C016     MOVFF Message, p
3582  F072     NOP
3584  C017     MOVFF _r, 0x73
3586  F073     NOP
3588  C018     MOVFF 0x18, w
358A  F074     NOP
22:            	if (e < 0x7f-1) {
358C  0100     MOVLB 0x0
358E  BF7E     BTFSC i, 7, BANKED
3590  D006     BRA 0x359E
3592  517E     MOVF i, W, BANKED
3594  E11F     BNZ 0x35D4
3596  0E7E     MOVLW 0x7E
3598  5D7D     SUBWF rem, W, BANKED
359A  B0D8     BTFSC STATUS, 0, ACCESS
359C  D01B     BRA 0x35D4
23:            		FORCE_EVAL(x + toint);
24:            		return 0*u.f;
359E  C083     MOVFF i, counter
35A0  F02D     NOP
35A2  C084     MOVFF grs, w
35A4  F02E     NOP
35A6  C085     MOVFF c, 0x2F
35A8  F02F     NOP
35AA  C086     MOVFF 0x86, cp
35AC  F030     NOP
35AE  0E00     MOVLW 0x0
35B0  6E31     MOVWF a, ACCESS
35B2  0E00     MOVLW 0x0
35B4  6E32     MOVWF p, ACCESS
35B6  0E00     MOVLW 0x0
35B8  6E33     MOVWF 0x33, ACCESS
35BA  0E00     MOVLW 0x0
35BC  6E34     MOVWF l, ACCESS
35BE  EC2B     CALL 0x3856, 0
35C0  F01C     NOP
35C2  C02D     MOVFF counter, b
35C4  F071     NOP
35C6  C02E     MOVFF w, p
35C8  F072     NOP
35CA  C02F     MOVFF 0x2F, 0x73
35CC  F073     NOP
35CE  C030     MOVFF cp, w
35D0  F074     NOP
35D2  0012     RETURN 0
25:            	}
26:            	y = x + toint - toint - x;
35D4  0E0C     MOVLW 0xC
35D6  6EF6     MOVWF TBLPTR, ACCESS
35D8  0E7D     MOVLW 0x7D
35DA  6EF7     MOVWF TBLPTRH, ACCESS
35DC  0009     TBLRD*+
35DE  CFF5     MOVFF TABLAT, divisor
35E0  F01D     NOP
35E2  0009     TBLRD*+
35E4  CFF5     MOVFF TABLAT, l
35E6  F01E     NOP
35E8  0009     TBLRD*+
35EA  CFF5     MOVFF TABLAT, i
35EC  F01F     NOP
35EE  000A     TBLRD*-
35F0  CFF5     MOVFF TABLAT, r
35F2  F020     NOP
35F4  C071     MOVFF b, multiplicand
35F6  F019     NOP
35F8  C072     MOVFF p, s
35FA  F01A     NOP
35FC  C073     MOVFF 0x73, c
35FE  F01B     NOP
3600  C074     MOVFF w, c
3602  F01C     NOP
3604  ECD4     CALL 0x3BA8, 0
3606  F01D     NOP
3608  C019     MOVFF multiplicand, 0x7F
360A  F07F     NOP
360C  C01A     MOVFF s, i
360E  F080     NOP
3610  C01B     MOVFF c, sign
3612  F081     NOP
3614  C01C     MOVFF c, i
3616  F082     NOP
3618  0E0C     MOVLW 0xC
361A  6EF6     MOVWF TBLPTR, ACCESS
361C  0E7D     MOVLW 0x7D
361E  6EF7     MOVWF TBLPTRH, ACCESS
3620  0009     TBLRD*+
3622  CFF5     MOVFF TABLAT, dividend
3624  F015     NOP
3626  0009     TBLRD*+
3628  CFF5     MOVFF TABLAT, Message
362A  F016     NOP
362C  0009     TBLRD*+
362E  CFF5     MOVFF TABLAT, _r
3630  F017     NOP
3632  000A     TBLRD*-
3634  CFF5     MOVFF TABLAT, 0x18
3636  F018     NOP
3638  ECC3     CALL 0x6786, 0
363A  F033     NOP
363C  C015     MOVFF dividend, divisor
363E  F01D     NOP
3640  C016     MOVFF Message, l
3642  F01E     NOP
3644  C017     MOVFF _r, i
3646  F01F     NOP
3648  C018     MOVFF 0x18, r
364A  F020     NOP
364C  C07F     MOVFF 0x7F, multiplicand
364E  F019     NOP
3650  C080     MOVFF i, s
3652  F01A     NOP
3654  C081     MOVFF sign, c
3656  F01B     NOP
3658  C082     MOVFF i, c
365A  F01C     NOP
365C  ECD4     CALL 0x3BA8, 0
365E  F01D     NOP
3660  C019     MOVFF multiplicand, w
3662  F079     NOP
3664  C01A     MOVFF s, n
3666  F07A     NOP
3668  C01B     MOVFF c, n
366A  F07B     NOP
366C  C01C     MOVFF c, 0x7C
366E  F07C     NOP
3670  C079     MOVFF w, multiplicand
3672  F019     NOP
3674  C07A     MOVFF n, s
3676  F01A     NOP
3678  C07B     MOVFF n, c
367A  F01B     NOP
367C  C07C     MOVFF 0x7C, c
367E  F01C     NOP
3680  C071     MOVFF b, dividend
3682  F015     NOP
3684  C072     MOVFF p, Message
3686  F016     NOP
3688  C073     MOVFF 0x73, _r
368A  F017     NOP
368C  C074     MOVFF w, 0x18
368E  F018     NOP
3690  ECC3     CALL 0x6786, 0
3692  F033     NOP
3694  C015     MOVFF dividend, divisor
3696  F01D     NOP
3698  C016     MOVFF Message, l
369A  F01E     NOP
369C  C017     MOVFF _r, i
369E  F01F     NOP
36A0  C018     MOVFF 0x18, r
36A2  F020     NOP
36A4  ECD4     CALL 0x3BA8, 0
36A6  F01D     NOP
36A8  C019     MOVFF multiplicand, fp
36AA  F087     NOP
36AC  C01A     MOVFF s, bexp
36AE  F088     NOP
36B0  C01B     MOVFF c, fmt
36B2  F089     NOP
36B4  C01C     MOVFF c, s
36B6  F08A     NOP
27:            	if (y > 0.5f)
36B8  0E00     MOVLW 0x0
36BA  6E15     MOVWF dividend, ACCESS
36BC  0E00     MOVLW 0x0
36BE  6E16     MOVWF Message, ACCESS
36C0  0E00     MOVLW 0x0
36C2  6E17     MOVWF _r, ACCESS
36C4  0E3F     MOVLW 0x3F
36C6  6E18     MOVWF 0x18, ACCESS
36C8  C087     MOVFF fp, multiplicand
36CA  F019     NOP
36CC  C088     MOVFF bexp, s
36CE  F01A     NOP
36D0  C089     MOVFF fmt, c
36D2  F01B     NOP
36D4  C08A     MOVFF s, c
36D6  F01C     NOP
36D8  EC44     CALL 0x5288, 0
36DA  F029     NOP
36DC  B0D8     BTFSC STATUS, 0, ACCESS
36DE  D02D     BRA 0x373A
28:            		y = y + x - 1;
36E0  C071     MOVFF b, divisor
36E2  F01D     NOP
36E4  C072     MOVFF p, l
36E6  F01E     NOP
36E8  C073     MOVFF 0x73, i
36EA  F01F     NOP
36EC  C074     MOVFF w, r
36EE  F020     NOP
36F0  C087     MOVFF fp, multiplicand
36F2  F019     NOP
36F4  C088     MOVFF bexp, s
36F6  F01A     NOP
36F8  C089     MOVFF fmt, c
36FA  F01B     NOP
36FC  C08A     MOVFF s, c
36FE  F01C     NOP
3700  ECD4     CALL 0x3BA8, 0
3702  F01D     NOP
3704  C019     MOVFF multiplicand, 0x7F
3706  F07F     NOP
3708  C01A     MOVFF s, i
370A  F080     NOP
370C  C01B     MOVFF c, sign
370E  F081     NOP
3710  C01C     MOVFF c, i
3712  F082     NOP
3714  C07F     MOVFF 0x7F, multiplicand
3716  F019     NOP
3718  C080     MOVFF i, s
371A  F01A     NOP
371C  C081     MOVFF sign, c
371E  F01B     NOP
3720  C082     MOVFF i, c
3722  F01C     NOP
3724  0E00     MOVLW 0x0
3726  6E1D     MOVWF divisor, ACCESS
3728  0E00     MOVLW 0x0
372A  6E1E     MOVWF l, ACCESS
372C  0E80     MOVLW 0x80
372E  6E1F     MOVWF i, ACCESS
3730  0EBF     MOVLW 0xBF
3732  6E20     MOVWF r, ACCESS
3734  ECD4     CALL 0x3BA8, 0
3736  F01D     NOP
3738  D053     BRA 0x37E0
29:            	else if (y <= -0.5f)
373A  0E00     MOVLW 0x0
373C  6E15     MOVWF dividend, ACCESS
373E  0E00     MOVLW 0x0
3740  6E16     MOVWF Message, ACCESS
3742  0E00     MOVLW 0x0
3744  6E17     MOVWF _r, ACCESS
3746  0EBF     MOVLW 0xBF
3748  6E18     MOVWF 0x18, ACCESS
374A  C087     MOVFF fp, multiplicand
374C  F019     NOP
374E  C088     MOVFF bexp, s
3750  F01A     NOP
3752  C089     MOVFF fmt, c
3754  F01B     NOP
3756  C08A     MOVFF s, c
3758  F01C     NOP
375A  EC44     CALL 0x5288, 0
375C  F029     NOP
375E  A0D8     BTFSS STATUS, 0, ACCESS
3760  D02D     BRA 0x37BC
30:            		y = y + x + 1;
3762  C071     MOVFF b, divisor
3764  F01D     NOP
3766  C072     MOVFF p, l
3768  F01E     NOP
376A  C073     MOVFF 0x73, i
376C  F01F     NOP
376E  C074     MOVFF w, r
3770  F020     NOP
3772  C087     MOVFF fp, multiplicand
3774  F019     NOP
3776  C088     MOVFF bexp, s
3778  F01A     NOP
377A  C089     MOVFF fmt, c
377C  F01B     NOP
377E  C08A     MOVFF s, c
3780  F01C     NOP
3782  ECD4     CALL 0x3BA8, 0
3784  F01D     NOP
3786  C019     MOVFF multiplicand, 0x7F
3788  F07F     NOP
378A  C01A     MOVFF s, i
378C  F080     NOP
378E  C01B     MOVFF c, sign
3790  F081     NOP
3792  C01C     MOVFF c, i
3794  F082     NOP
3796  C07F     MOVFF 0x7F, multiplicand
3798  F019     NOP
379A  C080     MOVFF i, s
379C  F01A     NOP
379E  C081     MOVFF sign, c
37A0  F01B     NOP
37A2  C082     MOVFF i, c
37A4  F01C     NOP
37A6  0E00     MOVLW 0x0
37A8  6E1D     MOVWF divisor, ACCESS
37AA  0E00     MOVLW 0x0
37AC  6E1E     MOVWF l, ACCESS
37AE  0E80     MOVLW 0x80
37B0  6E1F     MOVWF i, ACCESS
37B2  0E3F     MOVLW 0x3F
37B4  6E20     MOVWF r, ACCESS
37B6  ECD4     CALL 0x3BA8, 0
37B8  F01D     NOP
37BA  D012     BRA 0x37E0
31:            	else
32:            		y = y + x;
37BC  C087     MOVFF fp, multiplicand
37BE  F019     NOP
37C0  C088     MOVFF bexp, s
37C2  F01A     NOP
37C4  C089     MOVFF fmt, c
37C6  F01B     NOP
37C8  C08A     MOVFF s, c
37CA  F01C     NOP
37CC  C071     MOVFF b, divisor
37CE  F01D     NOP
37D0  C072     MOVFF p, l
37D2  F01E     NOP
37D4  C073     MOVFF 0x73, i
37D6  F01F     NOP
37D8  C074     MOVFF w, r
37DA  F020     NOP
37DC  ECD4     CALL 0x3BA8, 0
37DE  F01D     NOP
37E0  C019     MOVFF multiplicand, fp
37E2  F087     NOP
37E4  C01A     MOVFF s, bexp
37E6  F088     NOP
37E8  C01B     MOVFF c, fmt
37EA  F089     NOP
37EC  C01C     MOVFF c, s
37EE  F08A     NOP
33:            	if (u.i >> 31)
37F0  C083     MOVFF i, a
37F2  F075     NOP
37F4  C084     MOVFF grs, n
37F6  F076     NOP
37F8  C085     MOVFF c, p
37FA  F077     NOP
37FC  C086     MOVFF 0x86, n
37FE  F078     NOP
3800  0E20     MOVLW 0x20
3802  D006     BRA 0x3810
3804  0100     MOVLB 0x0
3806  90D8     BCF STATUS, 0, ACCESS
3808  3378     RRCF n, F, BANKED
380A  3377     RRCF p, F, BANKED
380C  3376     RRCF n, F, BANKED
380E  3375     RRCF a, F, BANKED
3810  2EE8     DECFSZ WREG, F, ACCESS
3812  D7F8     BRA 0x3804
3814  5175     MOVF a, W, BANKED
3816  1176     IORWF n, W, BANKED
3818  1177     IORWF p, W, BANKED
381A  1178     IORWF n, W, BANKED
381C  B4D8     BTFSC STATUS, 2, ACCESS
381E  D012     BRA 0x3844
34:            		y = -y;
3820  C087     MOVFF fp, dividend
3822  F015     NOP
3824  C088     MOVFF bexp, Message
3826  F016     NOP
3828  C089     MOVFF fmt, _r
382A  F017     NOP
382C  C08A     MOVFF s, 0x18
382E  F018     NOP
3830  ECC3     CALL 0x6786, 0
3832  F033     NOP
3834  C015     MOVFF dividend, fp
3836  F087     NOP
3838  C016     MOVFF Message, bexp
383A  F088     NOP
383C  C017     MOVFF _r, fmt
383E  F089     NOP
3840  C018     MOVFF 0x18, s
3842  F08A     NOP
35:            	return y;
3844  C087     MOVFF fp, b
3846  F071     NOP
3848  C088     MOVFF bexp, p
384A  F072     NOP
384C  C089     MOVFF fmt, 0x73
384E  F073     NOP
3850  C08A     MOVFF s, w
3852  F074     NOP
3854  0012     RETURN 0
36:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/printf.c  ------------------------------------------
1:             #include <stdio.h>
2:             #include <stdarg.h>
3:             #include "stdio_impl.h"
4:             
5:             int printf(const char *restrict fmt, ...)
6:             {
7:             	int ret;
8:             	va_list ap;
9:             	va_start(ap, fmt);
6606  0EB6     MOVLW 0xB6
6608  0100     MOVLB 0x0
660A  6FBA     MOVWF ap, BANKED
660C  0E00     MOVLW 0x0
660E  6FBB     MOVWF 0xBB, BANKED
10:            	ret = vfprintf(stdout, fmt, ap);
6610  0E00     MOVLW 0x0
6612  6FAC     MOVWF fp, BANKED
6614  0E00     MOVLW 0x0
6616  6FAD     MOVWF 0xAD, BANKED
6618  C0B4     MOVFF s, fmt
661A  F0AE     NOP
661C  C0B5     MOVFF 0xB5, i
661E  F0AF     NOP
6620  0EBA     MOVLW 0xBA
6622  6FB0     MOVWF ap, BANKED
6624  0E00     MOVLW 0x0
6626  6FB1     MOVWF 0xB1, BANKED
6628  ECD8     CALL 0x5FB0, 0
662A  F02F     NOP
662C  C0AC     MOVFF fp, ret
662E  F0B8     NOP
6630  C0AD     MOVFF 0xAD, 0xB9
6632  F0B9     NOP
6634  0012     RETURN 0
11:            	va_end(ap);
12:            	return ret;
13:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/nf_sprintf.c  --------------------------------------
1:             #include <stdarg.h>
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             /* "No file system" sprintf */
8:             
9:             int sprintf(char *restrict s, const char *restrict fmt, ...)
10:            {
11:            	int ret;
12:            	va_list ap;
13:            	FILE f;
14:            
15:            	va_start(ap, fmt);
5E4E  0EB8     MOVLW 0xB8
5E50  0100     MOVLB 0x0
5E52  6FC4     MOVWF ap, BANKED
5E54  0E00     MOVLW 0x0
5E56  6FC5     MOVWF 0xC5, BANKED
16:            	f.buffer = s;
5E58  C0B4     MOVFF s, f
5E5A  F0BE     NOP
5E5C  C0B5     MOVFF 0xB5, 0xBF
5E5E  F0BF     NOP
17:            	f.count = 0;
5E60  0E00     MOVLW 0x0
5E62  6FC1     MOVWF 0xC1, BANKED
5E64  0E00     MOVLW 0x0
5E66  6FC0     MOVWF 0xC0, BANKED
18:            	f.limit = 0;
5E68  0E00     MOVLW 0x0
5E6A  6FC3     MOVWF 0xC3, BANKED
5E6C  0E00     MOVLW 0x0
5E6E  6FC2     MOVWF 0xC2, BANKED
19:            	ret = vfprintf(&f, fmt, ap);
5E70  0EBE     MOVLW 0xBE
5E72  6FAC     MOVWF fp, BANKED
5E74  0E00     MOVLW 0x0
5E76  6FAD     MOVWF 0xAD, BANKED
5E78  C0B6     MOVFF fmt, fmt
5E7A  F0AE     NOP
5E7C  C0B7     MOVFF 0xB7, i
5E7E  F0AF     NOP
5E80  0EC4     MOVLW 0xC4
5E82  6FB0     MOVWF ap, BANKED
5E84  0E00     MOVLW 0x0
5E86  6FB1     MOVWF 0xB1, BANKED
5E88  ECD8     CALL 0x5FB0, 0
5E8A  F02F     NOP
5E8C  C0AC     MOVFF fp, ret
5E8E  F0BC     NOP
5E90  C0AD     MOVFF 0xAD, 0xBD
5E92  F0BD     NOP
20:            	s[f.count] = '\0';
5E94  0100     MOVLB 0x0
5E96  51C0     MOVF 0xC0, W, BANKED
5E98  25B4     ADDWF s, W, BANKED
5E9A  6ED9     MOVWF FSR2, ACCESS
5E9C  51C1     MOVF 0xC1, W, BANKED
5E9E  21B5     ADDWFC 0xB5, W, BANKED
5EA0  6EDA     MOVWF FSR2H, ACCESS
5EA2  0E00     MOVLW 0x0
5EA4  6EDF     MOVWF INDF2, ACCESS
5EA6  0012     RETURN 0
21:            	va_end(ap);
22:            	return ret;
23:            }
24:            
25:            #endif
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/nf_fputs.c  ----------------------------------------
1:             /* "No file system" fputs */
2:             #include <stdio.h>
3:             
4:             #include "stdio_impl.h"
5:             
6:             #ifdef STDIO_NO_FILE_IO
7:             
8:             int fputs(const char *s, FILE *fp)
9:             {
10:                char c;
11:                int i;
12:            
13:                i = 0;
6492  0E00     MOVLW 0x0
6494  6E26     MOVWF sign, ACCESS
6496  0E00     MOVLW 0x0
6498  6E25     MOVWF quotient, ACCESS
14:                while ((c = *(s + i))) {
649A  D00B     BRA 0x64B2
15:            	fputc(c,fp);
649C  C024     MOVFF n, _r
649E  F017     NOP
64A0  6A18     CLRF 0x18, ACCESS
64A2  C022     MOVFF s, multiplicand
64A4  F019     NOP
64A6  C023     MOVFF sep, s
64A8  F01A     NOP
64AA  EC49     CALL 0x5A92, 0
64AC  F02D     NOP
16:                    ++i;
64AE  4A25     INFSNZ quotient, F, ACCESS
64B0  2A26     INCF sign, F, ACCESS
17:                }
64B2  5025     MOVF quotient, W, ACCESS
64B4  2420     ADDWF r, W, ACCESS
64B6  6ED9     MOVWF FSR2, ACCESS
64B8  5026     MOVF sign, W, ACCESS
64BA  2021     ADDWFC s, W, ACCESS
64BC  6EDA     MOVWF FSR2H, ACCESS
64BE  50DF     MOVF INDF2, W, ACCESS
64C0  6E24     MOVWF n, ACCESS
64C2  5024     MOVF n, W, ACCESS
64C4  B4D8     BTFSC STATUS, 2, ACCESS
64C6  0012     RETURN 0
64C8  D7E9     BRA 0x649C
18:                return i;
19:            }
20:            
21:            #endif
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/nf_fputc.c  ----------------------------------------
1:             #include <stdio.h>
2:             
3:             #include "stdio_impl.h"
4:             
5:             #ifdef STDIO_NO_FILE_IO
6:             /* "No file system" fputc */
7:             
8:             int fputc(int c, FILE *fp)
9:             {
10:                extern void putch(char);
11:            
12:                if ((fp == stdout) || (fp == stderr)) {
5A92  5019     MOVF multiplicand, W, ACCESS
5A94  101A     IORWF s, W, ACCESS
5A96  B4D8     BTFSC STATUS, 2, ACCESS
5A98  D004     BRA 0x5AA2
5A9A  5019     MOVF multiplicand, W, ACCESS
5A9C  101A     IORWF s, W, ACCESS
5A9E  A4D8     BTFSS STATUS, 2, ACCESS
5AA0  D004     BRA 0x5AAA
13:                    putch(c);
5AA2  5017     MOVF _r, W, ACCESS
5AA4  ECBF     CALL 0x6B7E, 0
5AA6  F035     NOP
14:                } else {
5AA8  0012     RETURN 0
15:            	if((fp->limit == 0) || (fp->count < fp->limit)) {
5AAA  EE20     LFSR 2, 0x4
5AAC  F004     NOP
5AAE  5019     MOVF multiplicand, W, ACCESS
5AB0  26D9     ADDWF FSR2, F, ACCESS
5AB2  501A     MOVF s, W, ACCESS
5AB4  22DA     ADDWFC FSR2H, F, ACCESS
5AB6  50DE     MOVF POSTINC2, W, ACCESS
5AB8  10DE     IORWF POSTINC2, W, ACCESS
5ABA  B4D8     BTFSC STATUS, 2, ACCESS
5ABC  D016     BRA 0x5AEA
5ABE  EE20     LFSR 2, 0x4
5AC0  F004     NOP
5AC2  5019     MOVF multiplicand, W, ACCESS
5AC4  26D9     ADDWF FSR2, F, ACCESS
5AC6  501A     MOVF s, W, ACCESS
5AC8  22DA     ADDWFC FSR2H, F, ACCESS
5ACA  EE10     LFSR 1, 0x2
5ACC  F002     NOP
5ACE  5019     MOVF multiplicand, W, ACCESS
5AD0  26E1     ADDWF FSR1, F, ACCESS
5AD2  501A     MOVF s, W, ACCESS
5AD4  22E2     ADDWFC FSR1H, F, ACCESS
5AD6  50DE     MOVF POSTINC2, W, ACCESS
5AD8  5CE6     SUBWF POSTINC1, W, ACCESS
5ADA  50E6     MOVF POSTINC1, W, ACCESS
5ADC  0A80     XORLW 0x80
5ADE  6E1F     MOVWF i, ACCESS
5AE0  50DE     MOVF POSTINC2, W, ACCESS
5AE2  0A80     XORLW 0x80
5AE4  581F     SUBWFB i, W, ACCESS
5AE6  B0D8     BTFSC STATUS, 0, ACCESS
5AE8  0012     RETURN 0
16:            	        fp->buffer[fp->count] = (char)c;
5AEA  EE20     LFSR 2, 0x2
5AEC  F002     NOP
5AEE  5019     MOVF multiplicand, W, ACCESS
5AF0  26D9     ADDWF FSR2, F, ACCESS
5AF2  501A     MOVF s, W, ACCESS
5AF4  22DA     ADDWFC FSR2H, F, ACCESS
5AF6  CFDE     MOVFF POSTINC2, c
5AF8  F01B     NOP
5AFA  CFDD     MOVFF POSTDEC2, c
5AFC  F01C     NOP
5AFE  C019     MOVFF multiplicand, FSR2
5B00  FFD9     NOP
5B02  C01A     MOVFF s, FSR2H
5B04  FFDA     NOP
5B06  CFDE     MOVFF POSTINC2, divisor
5B08  F01D     NOP
5B0A  CFDD     MOVFF POSTDEC2, l
5B0C  F01E     NOP
5B0E  501B     MOVF c, W, ACCESS
5B10  241D     ADDWF divisor, W, ACCESS
5B12  6ED9     MOVWF FSR2, ACCESS
5B14  501C     MOVF c, W, ACCESS
5B16  201E     ADDWFC l, W, ACCESS
5B18  6EDA     MOVWF FSR2H, ACCESS
5B1A  C017     MOVFF _r, INDF2
5B1C  FFDF     NOP
17:            		++fp->count;
5B1E  EE20     LFSR 2, 0x2
5B20  F002     NOP
5B22  5019     MOVF multiplicand, W, ACCESS
5B24  26D9     ADDWF FSR2, F, ACCESS
5B26  501A     MOVF s, W, ACCESS
5B28  22DA     ADDWFC FSR2H, F, ACCESS
5B2A  2ADE     INCF POSTINC2, F, ACCESS
5B2C  0E00     MOVLW 0x0
5B2E  22DD     ADDWFC POSTDEC2, F, ACCESS
18:            	}
19:                }
5B30  0012     RETURN 0
20:                return (unsigned char)c;
21:            }
22:            
23:            #endif
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/nanf.c  --------------------------------------------
1:             #include <math.h>
2:             #include <stdint.h>
3:             
4:             float nanf(const char *s)
5:             {
6:             #ifdef __XC8__
7:             	union {float f; uint32_t i;} u;
8:             	u.i = 0x7FFFFFFF;
6964  0EFF     MOVLW 0xFF
6966  6E19     MOVWF multiplicand, ACCESS
6968  0EFF     MOVLW 0xFF
696A  6E1A     MOVWF s, ACCESS
696C  0EFF     MOVLW 0xFF
696E  6E1B     MOVWF c, ACCESS
6970  0E7F     MOVLW 0x7F
6972  6E1C     MOVWF c, ACCESS
9:             	return u.f;
6974  C019     MOVFF multiplicand, dividend
6976  F015     NOP
6978  C01A     MOVFF s, Message
697A  F016     NOP
697C  C01B     MOVFF c, _r
697E  F017     NOP
6980  C01C     MOVFF c, 0x18
6982  F018     NOP
6984  0012     RETURN 0
10:            #else
11:            	return NAN;
12:            #endif
13:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/lomod.c  -------------------------------------------
1:             // long long unsigned unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lomod(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lomod(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter;
13:            
14:            	if(divisor != 0) {
59E4  501D     MOVF divisor, W, ACCESS
59E6  101E     IORWF l, W, ACCESS
59E8  101F     IORWF i, W, ACCESS
59EA  1020     IORWF r, W, ACCESS
59EC  1021     IORWF s, W, ACCESS
59EE  1022     IORWF s, W, ACCESS
59F0  1023     IORWF sep, W, ACCESS
59F2  1024     IORWF n, W, ACCESS
59F4  B4D8     BTFSC STATUS, 2, ACCESS
59F6  D03C     BRA 0x5A70
15:            		counter = 1;
59F8  0E01     MOVLW 0x1
59FA  6E25     MOVWF quotient, ACCESS
16:            		while((divisor & 0x8000000000000000ULL) == 0) {
59FC  D00A     BRA 0x5A12
17:            			divisor <<= 1;
59FE  90D8     BCF STATUS, 0, ACCESS
5A00  361D     RLCF divisor, F, ACCESS
5A02  361E     RLCF l, F, ACCESS
5A04  361F     RLCF i, F, ACCESS
5A06  3620     RLCF r, F, ACCESS
5A08  3621     RLCF s, F, ACCESS
5A0A  3622     RLCF s, F, ACCESS
5A0C  3623     RLCF sep, F, ACCESS
5A0E  3624     RLCF n, F, ACCESS
18:            			counter++;
5A10  2A25     INCF quotient, F, ACCESS
19:            		}
5A12  AE24     BTFSS n, 7, ACCESS
5A14  D7F4     BRA 0x59FE
20:            		do {
21:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
5A16  501D     MOVF divisor, W, ACCESS
5A18  5C15     SUBWF dividend, W, ACCESS
5A1A  501E     MOVF l, W, ACCESS
5A1C  5816     SUBWFB Message, W, ACCESS
5A1E  501F     MOVF i, W, ACCESS
5A20  5817     SUBWFB _r, W, ACCESS
5A22  5020     MOVF r, W, ACCESS
5A24  5818     SUBWFB 0x18, W, ACCESS
5A26  5021     MOVF s, W, ACCESS
5A28  5819     SUBWFB multiplicand, W, ACCESS
5A2A  5022     MOVF s, W, ACCESS
5A2C  581A     SUBWFB s, W, ACCESS
5A2E  5023     MOVF sep, W, ACCESS
5A30  581B     SUBWFB c, W, ACCESS
5A32  5024     MOVF n, W, ACCESS
5A34  581C     SUBWFB c, W, ACCESS
5A36  A0D8     BTFSS STATUS, 0, ACCESS
5A38  D010     BRA 0x5A5A
22:            				dividend -= divisor;
5A3A  501D     MOVF divisor, W, ACCESS
5A3C  5E15     SUBWF dividend, F, ACCESS
5A3E  501E     MOVF l, W, ACCESS
5A40  5A16     SUBWFB Message, F, ACCESS
5A42  501F     MOVF i, W, ACCESS
5A44  5A17     SUBWFB _r, F, ACCESS
5A46  5020     MOVF r, W, ACCESS
5A48  5A18     SUBWFB 0x18, F, ACCESS
5A4A  5021     MOVF s, W, ACCESS
5A4C  5A19     SUBWFB multiplicand, F, ACCESS
5A4E  5022     MOVF s, W, ACCESS
5A50  5A1A     SUBWFB s, F, ACCESS
5A52  5023     MOVF sep, W, ACCESS
5A54  5A1B     SUBWFB c, F, ACCESS
5A56  5024     MOVF n, W, ACCESS
5A58  5A1C     SUBWFB c, F, ACCESS
23:            			*(unsigned long long int *)&divisor >>= 1;
5A5A  90D8     BCF STATUS, 0, ACCESS
5A5C  3224     RRCF n, F, ACCESS
5A5E  3223     RRCF sep, F, ACCESS
5A60  3222     RRCF s, F, ACCESS
5A62  3221     RRCF s, F, ACCESS
5A64  3220     RRCF r, F, ACCESS
5A66  321F     RRCF i, F, ACCESS
5A68  321E     RRCF l, F, ACCESS
5A6A  321D     RRCF divisor, F, ACCESS
24:            		} while(--counter != 0);
5A6C  2E25     DECFSZ quotient, F, ACCESS
5A6E  D7D3     BRA 0x5A16
25:            	}
26:            	return dividend;
5A70  C015     MOVFF dividend, dividend
5A72  F015     NOP
5A74  C016     MOVFF Message, Message
5A76  F016     NOP
5A78  C017     MOVFF _r, _r
5A7A  F017     NOP
5A7C  C018     MOVFF 0x18, 0x18
5A7E  F018     NOP
5A80  C019     MOVFF multiplicand, multiplicand
5A82  F019     NOP
5A84  C01A     MOVFF s, s
5A86  F01A     NOP
5A88  C01B     MOVFF c, c
5A8A  F01B     NOP
5A8C  C01C     MOVFF c, c
5A8E  F01C     NOP
27:            }
5A90  0012     RETURN 0
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/lodiv.c  -------------------------------------------
1:             // long long unsigned unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             unsigned long long int
6:             #ifdef __PICC__
7:             __lodiv(unsigned long long int divisor, unsigned long long int dividend)
8:             #else
9:             __lodiv(unsigned long long int dividend, unsigned long long int divisor)
10:            #endif
11:            {
12:            	unsigned long long int	quotient;
13:            	unsigned char	counter;
14:            
15:            	quotient = 0;
5862  EE20     LFSR 2, 0x25
5864  F025     NOP
5866  0E07     MOVLW 0x7
5868  6ADE     CLRF POSTINC2, ACCESS
586A  06E8     DECF WREG, F, ACCESS
586C  E2FD     BC 0x5868
16:            	if(divisor != 0) {
586E  501D     MOVF divisor, W, ACCESS
5870  101E     IORWF l, W, ACCESS
5872  101F     IORWF i, W, ACCESS
5874  1020     IORWF r, W, ACCESS
5876  1021     IORWF s, W, ACCESS
5878  1022     IORWF s, W, ACCESS
587A  1023     IORWF sep, W, ACCESS
587C  1024     IORWF n, W, ACCESS
587E  B4D8     BTFSC STATUS, 2, ACCESS
5880  D046     BRA 0x590E
17:            		counter = 1;
5882  0E01     MOVLW 0x1
5884  6E2D     MOVWF counter, ACCESS
18:            		while((divisor & 0x8000000000000000ULL) == 0) {
5886  D00A     BRA 0x589C
19:            			divisor <<= 1;
5888  90D8     BCF STATUS, 0, ACCESS
588A  361D     RLCF divisor, F, ACCESS
588C  361E     RLCF l, F, ACCESS
588E  361F     RLCF i, F, ACCESS
5890  3620     RLCF r, F, ACCESS
5892  3621     RLCF s, F, ACCESS
5894  3622     RLCF s, F, ACCESS
5896  3623     RLCF sep, F, ACCESS
5898  3624     RLCF n, F, ACCESS
20:            			counter++;
589A  2A2D     INCF counter, F, ACCESS
21:            		}
589C  AE24     BTFSS n, 7, ACCESS
589E  D7F4     BRA 0x5888
22:            		do {
23:            			quotient <<= 1;
58A0  90D8     BCF STATUS, 0, ACCESS
58A2  3625     RLCF quotient, F, ACCESS
58A4  3626     RLCF sign, F, ACCESS
58A6  3627     RLCF quotient, F, ACCESS
58A8  3628     RLCF 0x28, F, ACCESS
58AA  3629     RLCF buf, F, ACCESS
58AC  362A     RLCF aexp, F, ACCESS
58AE  362B     RLCF p, F, ACCESS
58B0  362C     RLCF i, F, ACCESS
24:            			if(divisor <= dividend) {
58B2  501D     MOVF divisor, W, ACCESS
58B4  5C15     SUBWF dividend, W, ACCESS
58B6  501E     MOVF l, W, ACCESS
58B8  5816     SUBWFB Message, W, ACCESS
58BA  501F     MOVF i, W, ACCESS
58BC  5817     SUBWFB _r, W, ACCESS
58BE  5020     MOVF r, W, ACCESS
58C0  5818     SUBWFB 0x18, W, ACCESS
58C2  5021     MOVF s, W, ACCESS
58C4  5819     SUBWFB multiplicand, W, ACCESS
58C6  5022     MOVF s, W, ACCESS
58C8  581A     SUBWFB s, W, ACCESS
58CA  5023     MOVF sep, W, ACCESS
58CC  581B     SUBWFB c, W, ACCESS
58CE  5024     MOVF n, W, ACCESS
58D0  581C     SUBWFB c, W, ACCESS
58D2  A0D8     BTFSS STATUS, 0, ACCESS
58D4  D011     BRA 0x58F8
25:            				dividend -= divisor;
58D6  501D     MOVF divisor, W, ACCESS
58D8  5E15     SUBWF dividend, F, ACCESS
58DA  501E     MOVF l, W, ACCESS
58DC  5A16     SUBWFB Message, F, ACCESS
58DE  501F     MOVF i, W, ACCESS
58E0  5A17     SUBWFB _r, F, ACCESS
58E2  5020     MOVF r, W, ACCESS
58E4  5A18     SUBWFB 0x18, F, ACCESS
58E6  5021     MOVF s, W, ACCESS
58E8  5A19     SUBWFB multiplicand, F, ACCESS
58EA  5022     MOVF s, W, ACCESS
58EC  5A1A     SUBWFB s, F, ACCESS
58EE  5023     MOVF sep, W, ACCESS
58F0  5A1B     SUBWFB c, F, ACCESS
58F2  5024     MOVF n, W, ACCESS
58F4  5A1C     SUBWFB c, F, ACCESS
26:            				quotient |= 1;
58F6  8025     BSF quotient, 0, ACCESS
27:            			}
28:            			divisor >>= 1;
58F8  90D8     BCF STATUS, 0, ACCESS
58FA  3224     RRCF n, F, ACCESS
58FC  3223     RRCF sep, F, ACCESS
58FE  3222     RRCF s, F, ACCESS
5900  3221     RRCF s, F, ACCESS
5902  3220     RRCF r, F, ACCESS
5904  321F     RRCF i, F, ACCESS
5906  321E     RRCF l, F, ACCESS
5908  321D     RRCF divisor, F, ACCESS
29:            		} while(--counter != 0);
590A  2E2D     DECFSZ counter, F, ACCESS
590C  D7C9     BRA 0x58A0
30:            	}
31:            	return quotient;
590E  C025     MOVFF quotient, dividend
5910  F015     NOP
5912  C026     MOVFF sign, Message
5914  F016     NOP
5916  C027     MOVFF quotient, _r
5918  F017     NOP
591A  C028     MOVFF 0x28, 0x18
591C  F018     NOP
591E  C029     MOVFF buf, multiplicand
5920  F019     NOP
5922  C02A     MOVFF aexp, s
5924  F01A     NOP
5926  C02B     MOVFF p, c
5928  F01B     NOP
592A  C02C     MOVFF i, c
592C  F01C     NOP
32:            }
592E  0012     RETURN 0
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/isxdigit.c  ----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             
4:             int isxdigit(int c)
5:             {
6:             	return isdigit(c) || ((unsigned)c|32)-'a' < 6;
5DF2  0E01     MOVLW 0x1
5DF4  6E1B     MOVWF c, ACCESS
5DF6  0ED0     MOVLW 0xD0
5DF8  6E17     MOVWF _r, ACCESS
5DFA  0EFF     MOVLW 0xFF
5DFC  6E18     MOVWF 0x18, ACCESS
5DFE  C015     MOVFF dividend, multiplicand
5E00  F019     NOP
5E02  C016     MOVFF Message, s
5E04  F01A     NOP
5E06  5017     MOVF _r, W, ACCESS
5E08  2619     ADDWF multiplicand, F, ACCESS
5E0A  5018     MOVF 0x18, W, ACCESS
5E0C  221A     ADDWFC s, F, ACCESS
5E0E  501A     MOVF s, W, ACCESS
5E10  E104     BNZ 0x5E1A
5E12  0E0A     MOVLW 0xA
5E14  5C19     SUBWF multiplicand, W, ACCESS
5E16  A0D8     BTFSS STATUS, 0, ACCESS
5E18  D016     BRA 0x5E46
5E1A  0E9F     MOVLW 0x9F
5E1C  6E17     MOVWF _r, ACCESS
5E1E  0EFF     MOVLW 0xFF
5E20  6E18     MOVWF 0x18, ACCESS
5E22  0E20     MOVLW 0x20
5E24  1015     IORWF dividend, W, ACCESS
5E26  6E19     MOVWF multiplicand, ACCESS
5E28  0E00     MOVLW 0x0
5E2A  1016     IORWF Message, W, ACCESS
5E2C  6E1A     MOVWF s, ACCESS
5E2E  5017     MOVF _r, W, ACCESS
5E30  2619     ADDWF multiplicand, F, ACCESS
5E32  5018     MOVF 0x18, W, ACCESS
5E34  221A     ADDWFC s, F, ACCESS
5E36  501A     MOVF s, W, ACCESS
5E38  E104     BNZ 0x5E42
5E3A  0E06     MOVLW 0x6
5E3C  5C19     SUBWF multiplicand, W, ACCESS
5E3E  A0D8     BTFSS STATUS, 0, ACCESS
5E40  D002     BRA 0x5E46
5E42  0E00     MOVLW 0x0
5E44  6E1B     MOVWF c, ACCESS
5E46  C01B     MOVFF c, dividend
5E48  F015     NOP
5E4A  6A16     CLRF Message, ACCESS
5E4C  0012     RETURN 0
7:             }
8:             
9:             int __isxdigit_l(int c, locale_t l)
10:            {
11:            	return isxdigit(c);
12:            }
13:            
14:            weak_alias(__isxdigit_l, isxdigit_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/isupper.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isupper
4:             
5:             int isupper(int c)
6:             {
7:             	return (unsigned)c-'A' < 26;
6666  0EBF     MOVLW 0xBF
6668  6E17     MOVWF _r, ACCESS
666A  0EFF     MOVLW 0xFF
666C  6E18     MOVWF 0x18, ACCESS
666E  C015     MOVFF dividend, multiplicand
6670  F019     NOP
6672  C016     MOVFF Message, s
6674  F01A     NOP
6676  5017     MOVF _r, W, ACCESS
6678  2619     ADDWF multiplicand, F, ACCESS
667A  5018     MOVF 0x18, W, ACCESS
667C  221A     ADDWFC s, F, ACCESS
667E  501A     MOVF s, W, ACCESS
6680  E106     BNZ 0x668E
6682  0E1A     MOVLW 0x1A
6684  5C19     SUBWF multiplicand, W, ACCESS
6686  B0D8     BTFSC STATUS, 0, ACCESS
6688  D002     BRA 0x668E
668A  0E01     MOVLW 0x1
668C  D001     BRA 0x6690
668E  0E00     MOVLW 0x0
6690  6E15     MOVWF dividend, ACCESS
6692  6A16     CLRF Message, ACCESS
6694  0012     RETURN 0
8:             }
9:             
10:            int __isupper_l(int c, locale_t l)
11:            {
12:            	return isupper(c);
13:            }
14:            
15:            weak_alias(__isupper_l, isupper_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/isspace.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isspace
4:             
5:             int isspace(int c)
6:             {
7:             	return c == ' ' || (unsigned)c-'\t' < 5;
62F4  0E01     MOVLW 0x1
62F6  6E1B     MOVWF c, ACCESS
62F8  0E20     MOVLW 0x20
62FA  1815     XORWF dividend, W, ACCESS
62FC  1016     IORWF Message, W, ACCESS
62FE  B4D8     BTFSC STATUS, 2, ACCESS
6300  D014     BRA 0x632A
6302  0EF7     MOVLW 0xF7
6304  6E17     MOVWF _r, ACCESS
6306  0EFF     MOVLW 0xFF
6308  6E18     MOVWF 0x18, ACCESS
630A  C015     MOVFF dividend, multiplicand
630C  F019     NOP
630E  C016     MOVFF Message, s
6310  F01A     NOP
6312  5017     MOVF _r, W, ACCESS
6314  2619     ADDWF multiplicand, F, ACCESS
6316  5018     MOVF 0x18, W, ACCESS
6318  221A     ADDWFC s, F, ACCESS
631A  501A     MOVF s, W, ACCESS
631C  E104     BNZ 0x6326
631E  0E05     MOVLW 0x5
6320  5C19     SUBWF multiplicand, W, ACCESS
6322  A0D8     BTFSS STATUS, 0, ACCESS
6324  D002     BRA 0x632A
6326  0E00     MOVLW 0x0
6328  6E1B     MOVWF c, ACCESS
632A  C01B     MOVFF c, dividend
632C  F015     NOP
632E  6A16     CLRF Message, ACCESS
6330  0012     RETURN 0
8:             }
9:             
10:            int __isspace_l(int c, locale_t l)
11:            {
12:            	return isspace(c);
13:            }
14:            
15:            weak_alias(__isspace_l, isspace_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/islower.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef islower
4:             
5:             int islower(int c)
6:             {
7:             	return (unsigned)c-'a' < 26;
6636  0E9F     MOVLW 0x9F
6638  6E17     MOVWF _r, ACCESS
663A  0EFF     MOVLW 0xFF
663C  6E18     MOVWF 0x18, ACCESS
663E  C015     MOVFF dividend, multiplicand
6640  F019     NOP
6642  C016     MOVFF Message, s
6644  F01A     NOP
6646  5017     MOVF _r, W, ACCESS
6648  2619     ADDWF multiplicand, F, ACCESS
664A  5018     MOVF 0x18, W, ACCESS
664C  221A     ADDWFC s, F, ACCESS
664E  501A     MOVF s, W, ACCESS
6650  E106     BNZ 0x665E
6652  0E1A     MOVLW 0x1A
6654  5C19     SUBWF multiplicand, W, ACCESS
6656  B0D8     BTFSC STATUS, 0, ACCESS
6658  D002     BRA 0x665E
665A  0E01     MOVLW 0x1
665C  D001     BRA 0x6660
665E  0E00     MOVLW 0x0
6660  6E15     MOVWF dividend, ACCESS
6662  6A16     CLRF Message, ACCESS
6664  0012     RETURN 0
8:             }
9:             
10:            int __islower_l(int c, locale_t l)
11:            {
12:            	return islower(c);
13:            }
14:            
15:            weak_alias(__islower_l, islower_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/isdigit.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isdigit
4:             
5:             int isdigit(int c)
6:             {
7:             	return (unsigned)c-'0' < 10;
6696  0ED0     MOVLW 0xD0
6698  6E17     MOVWF _r, ACCESS
669A  0EFF     MOVLW 0xFF
669C  6E18     MOVWF 0x18, ACCESS
669E  C015     MOVFF dividend, multiplicand
66A0  F019     NOP
66A2  C016     MOVFF Message, s
66A4  F01A     NOP
66A6  5017     MOVF _r, W, ACCESS
66A8  2619     ADDWF multiplicand, F, ACCESS
66AA  5018     MOVF 0x18, W, ACCESS
66AC  221A     ADDWFC s, F, ACCESS
66AE  501A     MOVF s, W, ACCESS
66B0  E106     BNZ 0x66BE
66B2  0E0A     MOVLW 0xA
66B4  5C19     SUBWF multiplicand, W, ACCESS
66B6  B0D8     BTFSC STATUS, 0, ACCESS
66B8  D002     BRA 0x66BE
66BA  0E01     MOVLW 0x1
66BC  D001     BRA 0x66C0
66BE  0E00     MOVLW 0x0
66C0  6E15     MOVWF dividend, ACCESS
66C2  6A16     CLRF Message, ACCESS
66C4  0012     RETURN 0
8:             }
9:             
10:            int __isdigit_l(int c, locale_t l)
11:            {
12:            	return isdigit(c);
13:            }
14:            
15:            weak_alias(__isdigit_l, isdigit_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/isalpha.c  -----------------------------------------
1:             #include <ctype.h>
2:             #include "libc.h"
3:             #undef isalpha
4:             
5:             int isalpha(int c)
6:             {
7:             	return ((unsigned)c|32)-'a' < 26;
656C  0E9F     MOVLW 0x9F
656E  6E17     MOVWF _r, ACCESS
6570  0EFF     MOVLW 0xFF
6572  6E18     MOVWF 0x18, ACCESS
6574  0E20     MOVLW 0x20
6576  1015     IORWF dividend, W, ACCESS
6578  6E19     MOVWF multiplicand, ACCESS
657A  0E00     MOVLW 0x0
657C  1016     IORWF Message, W, ACCESS
657E  6E1A     MOVWF s, ACCESS
6580  5017     MOVF _r, W, ACCESS
6582  2619     ADDWF multiplicand, F, ACCESS
6584  5018     MOVF 0x18, W, ACCESS
6586  221A     ADDWFC s, F, ACCESS
6588  501A     MOVF s, W, ACCESS
658A  E106     BNZ 0x6598
658C  0E1A     MOVLW 0x1A
658E  5C19     SUBWF multiplicand, W, ACCESS
6590  B0D8     BTFSC STATUS, 0, ACCESS
6592  D002     BRA 0x6598
6594  0E01     MOVLW 0x1
6596  D001     BRA 0x659A
6598  0E00     MOVLW 0x0
659A  6E15     MOVWF dividend, ACCESS
659C  6A16     CLRF Message, ACCESS
659E  0012     RETURN 0
8:             }
9:             
10:            int __isalpha_l(int c, locale_t l)
11:            {
12:            	return isalpha(c);
13:            }
14:            
15:            weak_alias(__isalpha_l, isalpha_l);
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/fltol.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"flarith.h"
9:             
10:            #define	f1_as_mant1	(*(unsigned long *)&f1)
11:            
12:            // Convert float to long
13:            #ifdef _OLDLIB
14:            long
15:            __fltol(double f1)
16:            {
17:            	unsigned char	sign1, exp1;
18:            	unsigned long	lval;
19:            
20:            	sign1 = __flunpack(&f1_as_mant1, &exp1);
21:            	lval = f1_as_mant1;
22:            	exp1 -= 127+23;
23:            	if((signed char)exp1 < 0) {
24:            		if((signed char)exp1 < -23)
25:            			return 0;
26:            		do
27:            			lval >>= 1;
28:            		while(++exp1 != 0);
29:            	} else {
30:            		if(exp1 >= 32)
31:            			return 00;
32:            		while(exp1 != 0) {
33:            			lval <<= 1;
34:            			exp1--;
35:            		}
36:            	}
37:            	if(sign1)
38:            		lval = -lval;
39:            	return lval;
40:            }
41:            #else
42:            long
43:            __fltol(double f1)
44:            {
45:            	unsigned char	sign1, exp1;
46:            
47:            	if((exp1 = f1_as_mant1 >> 23) == 0)
5784  0100     MOVLB 0x0
5786  358D     RLCF 0x8D, W, BANKED
5788  358E     RLCF 0x8E, W, BANKED
578A  6E36     MOVWF exp1, ACCESS
578C  5036     MOVF exp1, W, ACCESS
578E  A4D8     BTFSS STATUS, 2, ACCESS
5790  D009     BRA 0x57A4
48:            		return 0;
5792  0E00     MOVLW 0x0
5794  6F8B     MOVWF ap, BANKED
5796  0E00     MOVLW 0x0
5798  6F8C     MOVWF res, BANKED
579A  0E00     MOVLW 0x0
579C  6F8D     MOVWF 0x8D, BANKED
579E  0E00     MOVLW 0x0
57A0  6F8E     MOVWF 0x8E, BANKED
57A2  0012     RETURN 0
49:            	sign1 = f1_as_mant1 >> 31;
57A4  C08B     MOVFF ap, 0x8F
57A6  F08F     NOP
57A8  C08C     MOVFF res, 0x90
57AA  F090     NOP
57AC  C08D     MOVFF 0x8D, cp
57AE  F091     NOP
57B0  C08E     MOVFF 0x8E, 0x92
57B2  F092     NOP
57B4  0E20     MOVLW 0x20
57B6  D005     BRA 0x57C2
57B8  90D8     BCF STATUS, 0, ACCESS
57BA  3392     RRCF 0x92, F, BANKED
57BC  3391     RRCF cp, F, BANKED
57BE  3390     RRCF 0x90, F, BANKED
57C0  338F     RRCF 0x8F, F, BANKED
57C2  2EE8     DECFSZ WREG, F, ACCESS
57C4  D7F9     BRA 0x57B8
57C6  518F     MOVF 0x8F, W, BANKED
57C8  6E35     MOVWF w, ACCESS
50:            	f1_as_mant1 |= 0x800000UL;
57CA  8F8D     BSF 0x8D, 7, BANKED
51:            	f1_as_mant1 &= 0xFFFFFFUL;
57CC  0EFF     MOVLW 0xFF
57CE  178B     ANDWF ap, F, BANKED
57D0  0EFF     MOVLW 0xFF
57D2  178C     ANDWF res, F, BANKED
57D4  0EFF     MOVLW 0xFF
57D6  178D     ANDWF 0x8D, F, BANKED
57D8  0E00     MOVLW 0x0
57DA  178E     ANDWF 0x8E, F, BANKED
52:            	exp1 -= 127+23;
57DC  0E96     MOVLW 0x96
57DE  5E36     SUBWF exp1, F, ACCESS
53:            	if((signed char)exp1 < 0) {
57E0  AE36     BTFSS exp1, 7, ACCESS
57E2  D016     BRA 0x5810
54:            		if((signed char)exp1 < -23)
57E4  5036     MOVF exp1, W, ACCESS
57E6  0A80     XORLW 0x80
57E8  0F97     ADDLW 0x97
57EA  B0D8     BTFSC STATUS, 0, ACCESS
57EC  D009     BRA 0x5800
55:            			return 0;
57EE  0E00     MOVLW 0x0
57F0  6F8B     MOVWF ap, BANKED
57F2  0E00     MOVLW 0x0
57F4  6F8C     MOVWF res, BANKED
57F6  0E00     MOVLW 0x0
57F8  6F8D     MOVWF 0x8D, BANKED
57FA  0E00     MOVLW 0x0
57FC  6F8E     MOVWF 0x8E, BANKED
57FE  0012     RETURN 0
56:            		do
57:            			f1_as_mant1 >>= 1;
5800  90D8     BCF STATUS, 0, ACCESS
5802  338E     RRCF 0x8E, F, BANKED
5804  338D     RRCF 0x8D, F, BANKED
5806  338C     RRCF res, F, BANKED
5808  338B     RRCF ap, F, BANKED
580A  3E36     INCFSZ exp1, F, ACCESS
580C  D7F9     BRA 0x5800
58:            		while(++exp1 != 0);
59:            	} else {
580E  D015     BRA 0x583A
60:            		if(exp1 >= 32)
5810  0E1F     MOVLW 0x1F
5812  6436     CPFSGT exp1, ACCESS
5814  D00F     BRA 0x5834
61:            			return 00;
5816  0E00     MOVLW 0x0
5818  6F8B     MOVWF ap, BANKED
581A  0E00     MOVLW 0x0
581C  6F8C     MOVWF res, BANKED
581E  0E00     MOVLW 0x0
5820  6F8D     MOVWF 0x8D, BANKED
5822  0E00     MOVLW 0x0
5824  6F8E     MOVWF 0x8E, BANKED
5826  0012     RETURN 0
62:            		while(exp1 != 0) {
63:            			f1_as_mant1 <<= 1;
5828  90D8     BCF STATUS, 0, ACCESS
582A  378B     RLCF ap, F, BANKED
582C  378C     RLCF res, F, BANKED
582E  378D     RLCF 0x8D, F, BANKED
5830  378E     RLCF 0x8E, F, BANKED
64:            			exp1--;
5832  0636     DECF exp1, F, ACCESS
65:            		}
5834  5036     MOVF exp1, W, ACCESS
5836  A4D8     BTFSS STATUS, 2, ACCESS
5838  D7F7     BRA 0x5828
66:            	}
67:            	if(sign1)
583A  5035     MOVF w, W, ACCESS
583C  B4D8     BTFSC STATUS, 2, ACCESS
583E  D008     BRA 0x5850
68:            		f1_as_mant1 = -f1_as_mant1;
5840  1F8E     COMF 0x8E, F, BANKED
5842  1F8D     COMF 0x8D, F, BANKED
5844  1F8C     COMF res, F, BANKED
5846  6D8B     NEGF ap, BANKED
5848  0E00     MOVLW 0x0
584A  238C     ADDWFC res, F, BANKED
584C  238D     ADDWFC 0x8D, F, BANKED
584E  238E     ADDWFC 0x8E, F, BANKED
69:            	return f1_as_mant1;
5850  C08B     MOVFF ap, ap
5852  F08B     NOP
5854  C08C     MOVFF res, res
5856  F08C     NOP
5858  C08D     MOVFF 0x8D, 0x8D
585A  F08D     NOP
585C  C08E     MOVFF 0x8E, 0x8E
585E  F08E     NOP
5860  0012     RETURN 0
70:            }
71:            #endif
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/flneg.c  -------------------------------------------
1:             /*	Floating point routines.
2:             
3:             	Copyright (c) 2012 Microchip Technology Inc. All rights reserved.
4:             */
5:             
6:             // this is bigendian code right now. Need to parameterise it.
7:             
8:             #include	"ftarith.h"
9:             
10:            #define	mant1	(*(unsigned long *)&f1)
11:            
12:            // Negate a float
13:            
14:            double
15:            __flneg(double f1)
16:            {
17:            	if(mant1 != 0x0)
6786  5015     MOVF dividend, W, ACCESS
6788  1016     IORWF Message, W, ACCESS
678A  1017     IORWF _r, W, ACCESS
678C  1018     IORWF 0x18, W, ACCESS
678E  B4D8     BTFSC STATUS, 2, ACCESS
6790  D008     BRA 0x67A2
18:            		mant1 ^= 0x80000000UL;
6792  0E00     MOVLW 0x0
6794  1A15     XORWF dividend, F, ACCESS
6796  0E00     MOVLW 0x0
6798  1A16     XORWF Message, F, ACCESS
679A  0E00     MOVLW 0x0
679C  1A17     XORWF _r, F, ACCESS
679E  0E80     MOVLW 0x80
67A0  1A18     XORWF 0x18, F, ACCESS
19:            	return f1;
67A2  C015     MOVFF dividend, dividend
67A4  F015     NOP
67A6  C016     MOVFF Message, Message
67A8  F016     NOP
67AA  C017     MOVFF _r, _r
67AC  F017     NOP
67AE  C018     MOVFF 0x18, 0x18
67B0  F018     NOP
67B2  0012     RETURN 0
20:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/flge.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __flge(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
5288  0E00     MOVLW 0x0
528A  1415     ANDWF dividend, W, ACCESS
528C  6E1D     MOVWF divisor, ACCESS
528E  0E00     MOVLW 0x0
5290  1416     ANDWF Message, W, ACCESS
5292  6E1E     MOVWF l, ACCESS
5294  0E80     MOVLW 0x80
5296  1417     ANDWF _r, W, ACCESS
5298  6E1F     MOVWF i, ACCESS
529A  0E7F     MOVLW 0x7F
529C  1418     ANDWF 0x18, W, ACCESS
529E  6E20     MOVWF r, ACCESS
52A0  501D     MOVF divisor, W, ACCESS
52A2  101E     IORWF l, W, ACCESS
52A4  101F     IORWF i, W, ACCESS
52A6  1020     IORWF r, W, ACCESS
52A8  A4D8     BTFSS STATUS, 2, ACCESS
52AA  D008     BRA 0x52BC
8:             		f1 = 0x00000000UL;
52AC  0E00     MOVLW 0x0
52AE  6E15     MOVWF dividend, ACCESS
52B0  0E00     MOVLW 0x0
52B2  6E16     MOVWF Message, ACCESS
52B4  0E00     MOVLW 0x0
52B6  6E17     MOVWF _r, ACCESS
52B8  0E00     MOVLW 0x0
52BA  6E18     MOVWF 0x18, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
52BC  0E00     MOVLW 0x0
52BE  1419     ANDWF multiplicand, W, ACCESS
52C0  6E1D     MOVWF divisor, ACCESS
52C2  0E00     MOVLW 0x0
52C4  141A     ANDWF s, W, ACCESS
52C6  6E1E     MOVWF l, ACCESS
52C8  0E80     MOVLW 0x80
52CA  141B     ANDWF c, W, ACCESS
52CC  6E1F     MOVWF i, ACCESS
52CE  0E7F     MOVLW 0x7F
52D0  141C     ANDWF c, W, ACCESS
52D2  6E20     MOVWF r, ACCESS
52D4  501D     MOVF divisor, W, ACCESS
52D6  101E     IORWF l, W, ACCESS
52D8  101F     IORWF i, W, ACCESS
52DA  1020     IORWF r, W, ACCESS
52DC  A4D8     BTFSS STATUS, 2, ACCESS
52DE  D008     BRA 0x52F0
10:            	        f2 = 0x00000000UL;
52E0  0E00     MOVLW 0x0
52E2  6E19     MOVWF multiplicand, ACCESS
52E4  0E00     MOVLW 0x0
52E6  6E1A     MOVWF s, ACCESS
52E8  0E00     MOVLW 0x0
52EA  6E1B     MOVWF c, ACCESS
52EC  0E00     MOVLW 0x0
52EE  6E1C     MOVWF c, ACCESS
11:            	// compute >= a clever way
12:            	if(f1 &  0x80000000UL)
52F0  AE18     BTFSS 0x18, 7, ACCESS
52F2  D01D     BRA 0x532E
13:            		f1 = 0x80000000UL - f1;
52F4  C015     MOVFF dividend, divisor
52F6  F01D     NOP
52F8  C016     MOVFF Message, l
52FA  F01E     NOP
52FC  C017     MOVFF _r, i
52FE  F01F     NOP
5300  C018     MOVFF 0x18, r
5302  F020     NOP
5304  1E1D     COMF divisor, F, ACCESS
5306  1E1E     COMF l, F, ACCESS
5308  1E1F     COMF i, F, ACCESS
530A  1E20     COMF r, F, ACCESS
530C  2A1D     INCF divisor, F, ACCESS
530E  0E00     MOVLW 0x0
5310  221E     ADDWFC l, F, ACCESS
5312  221F     ADDWFC i, F, ACCESS
5314  2220     ADDWFC r, F, ACCESS
5316  0E00     MOVLW 0x0
5318  241D     ADDWF divisor, W, ACCESS
531A  6E15     MOVWF dividend, ACCESS
531C  0E00     MOVLW 0x0
531E  201E     ADDWFC l, W, ACCESS
5320  6E16     MOVWF Message, ACCESS
5322  0E00     MOVLW 0x0
5324  201F     ADDWFC i, W, ACCESS
5326  6E17     MOVWF _r, ACCESS
5328  0E80     MOVLW 0x80
532A  2020     ADDWFC r, W, ACCESS
532C  6E18     MOVWF 0x18, ACCESS
14:            	if(f2 &  0x80000000UL)
532E  AE1C     BTFSS c, 7, ACCESS
5330  D01D     BRA 0x536C
15:            		f2 = 0x80000000UL - f2;
5332  C019     MOVFF multiplicand, divisor
5334  F01D     NOP
5336  C01A     MOVFF s, l
5338  F01E     NOP
533A  C01B     MOVFF c, i
533C  F01F     NOP
533E  C01C     MOVFF c, r
5340  F020     NOP
5342  1E1D     COMF divisor, F, ACCESS
5344  1E1E     COMF l, F, ACCESS
5346  1E1F     COMF i, F, ACCESS
5348  1E20     COMF r, F, ACCESS
534A  2A1D     INCF divisor, F, ACCESS
534C  0E00     MOVLW 0x0
534E  221E     ADDWFC l, F, ACCESS
5350  221F     ADDWFC i, F, ACCESS
5352  2220     ADDWFC r, F, ACCESS
5354  0E00     MOVLW 0x0
5356  241D     ADDWF divisor, W, ACCESS
5358  6E19     MOVWF multiplicand, ACCESS
535A  0E00     MOVLW 0x0
535C  201E     ADDWFC l, W, ACCESS
535E  6E1A     MOVWF s, ACCESS
5360  0E00     MOVLW 0x0
5362  201F     ADDWFC i, W, ACCESS
5364  6E1B     MOVWF c, ACCESS
5366  0E80     MOVLW 0x80
5368  2020     ADDWFC r, W, ACCESS
536A  6E1C     MOVWF c, ACCESS
16:            	f1 ^= 0x80000000UL;
536C  0E00     MOVLW 0x0
536E  1A15     XORWF dividend, F, ACCESS
5370  0E00     MOVLW 0x0
5372  1A16     XORWF Message, F, ACCESS
5374  0E00     MOVLW 0x0
5376  1A17     XORWF _r, F, ACCESS
5378  0E80     MOVLW 0x80
537A  1A18     XORWF 0x18, F, ACCESS
17:            	f2 ^= 0x80000000UL;
537C  0E00     MOVLW 0x0
537E  1A19     XORWF multiplicand, F, ACCESS
5380  0E00     MOVLW 0x0
5382  1A1A     XORWF s, F, ACCESS
5384  0E00     MOVLW 0x0
5386  1A1B     XORWF c, F, ACCESS
5388  0E80     MOVLW 0x80
538A  1A1C     XORWF c, F, ACCESS
18:            	return f1 >= f2;
538C  5019     MOVF multiplicand, W, ACCESS
538E  5C15     SUBWF dividend, W, ACCESS
5390  501A     MOVF s, W, ACCESS
5392  5816     SUBWFB Message, W, ACCESS
5394  501B     MOVF c, W, ACCESS
5396  5817     SUBWFB _r, W, ACCESS
5398  501C     MOVF c, W, ACCESS
539A  5818     SUBWFB 0x18, W, ACCESS
539C  B0D8     BTFSC STATUS, 0, ACCESS
539E  D002     BRA 0x53A4
53A0  90D8     BCF STATUS, 0, ACCESS
53A2  0012     RETURN 0
53A4  80D8     BSF STATUS, 0, ACCESS
53A6  0012     RETURN 0
19:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/fleq.c  --------------------------------------------
1:             #define	f1	(*(unsigned long *)&ff1)
2:             #define	f2	(*(unsigned long *)&ff2)
3:             __bit
4:             __fleq(double ff1, double ff2)
5:             {
6:                     // flush denorms and zeroes to +ve 0.0
7:                     if((f1 &  0x7F800000UL)== 0)
5CEC  0E00     MOVLW 0x0
5CEE  1415     ANDWF dividend, W, ACCESS
5CF0  6E1D     MOVWF divisor, ACCESS
5CF2  0E00     MOVLW 0x0
5CF4  1416     ANDWF Message, W, ACCESS
5CF6  6E1E     MOVWF l, ACCESS
5CF8  0E80     MOVLW 0x80
5CFA  1417     ANDWF _r, W, ACCESS
5CFC  6E1F     MOVWF i, ACCESS
5CFE  0E7F     MOVLW 0x7F
5D00  1418     ANDWF 0x18, W, ACCESS
5D02  6E20     MOVWF r, ACCESS
5D04  501D     MOVF divisor, W, ACCESS
5D06  101E     IORWF l, W, ACCESS
5D08  101F     IORWF i, W, ACCESS
5D0A  1020     IORWF r, W, ACCESS
5D0C  A4D8     BTFSS STATUS, 2, ACCESS
5D0E  D008     BRA 0x5D20
8:             		f1 = 0x00000000UL;
5D10  0E00     MOVLW 0x0
5D12  6E15     MOVWF dividend, ACCESS
5D14  0E00     MOVLW 0x0
5D16  6E16     MOVWF Message, ACCESS
5D18  0E00     MOVLW 0x0
5D1A  6E17     MOVWF _r, ACCESS
5D1C  0E00     MOVLW 0x0
5D1E  6E18     MOVWF 0x18, ACCESS
9:             	if((f2 &  0x7F800000UL)== 0)
5D20  0E00     MOVLW 0x0
5D22  1419     ANDWF multiplicand, W, ACCESS
5D24  6E1D     MOVWF divisor, ACCESS
5D26  0E00     MOVLW 0x0
5D28  141A     ANDWF s, W, ACCESS
5D2A  6E1E     MOVWF l, ACCESS
5D2C  0E80     MOVLW 0x80
5D2E  141B     ANDWF c, W, ACCESS
5D30  6E1F     MOVWF i, ACCESS
5D32  0E7F     MOVLW 0x7F
5D34  141C     ANDWF c, W, ACCESS
5D36  6E20     MOVWF r, ACCESS
5D38  501D     MOVF divisor, W, ACCESS
5D3A  101E     IORWF l, W, ACCESS
5D3C  101F     IORWF i, W, ACCESS
5D3E  1020     IORWF r, W, ACCESS
5D40  A4D8     BTFSS STATUS, 2, ACCESS
5D42  D008     BRA 0x5D54
10:            	        f2 = 0x00000000UL;
5D44  0E00     MOVLW 0x0
5D46  6E19     MOVWF multiplicand, ACCESS
5D48  0E00     MOVLW 0x0
5D4A  6E1A     MOVWF s, ACCESS
5D4C  0E00     MOVLW 0x0
5D4E  6E1B     MOVWF c, ACCESS
5D50  0E00     MOVLW 0x0
5D52  6E1C     MOVWF c, ACCESS
11:            	return f1 == f2;
5D54  5019     MOVF multiplicand, W, ACCESS
5D56  1815     XORWF dividend, W, ACCESS
5D58  E10A     BNZ 0x5D6E
5D5A  501A     MOVF s, W, ACCESS
5D5C  1816     XORWF Message, W, ACCESS
5D5E  E107     BNZ 0x5D6E
5D60  501B     MOVF c, W, ACCESS
5D62  1817     XORWF _r, W, ACCESS
5D64  E104     BNZ 0x5D6E
5D66  501C     MOVF c, W, ACCESS
5D68  1818     XORWF 0x18, W, ACCESS
5D6A  B4D8     BTFSC STATUS, 2, ACCESS
5D6C  D002     BRA 0x5D72
5D6E  90D8     BCF STATUS, 0, ACCESS
5D70  0012     RETURN 0
5D72  80D8     BSF STATUS, 0, ACCESS
5D74  0012     RETURN 0
12:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/doprnt.c  ------------------------------------------
1:             /* vfprintf with configurable support for format conversions */
2:             /* This code is specifically for XC8 */
3:             #include <ctype.h>
4:             #include <math.h>
5:             #include <stdarg.h>
6:             #include <stddef.h>
7:             #include <stdint.h>
8:             #include <stdio.h>
9:             #include <stdlib.h>
10:            #include <string.h>
11:            #include <inline.h>
12:            
13:            /* Configuration options */
14:            #ifdef _VFPF_ALL
15:            #define _VFPF_CONVERT
16:            #define _VFPF_FLAGS
17:            #define _VFPF_WIDTH
18:            #define _VFPF_PRECISION
19:            
20:            #define _VFPF_HH
21:            #define _VFPF_H
22:            #define _VFPF_L
23:            #define _VFPF_LL
24:            #define _VFPF_J
25:            #define _VFPF_T
26:            #define _VFPF_Z
27:            
28:            #define _VFPF_A
29:            #define _VFPF_C
30:            #define _VFPF_D
31:            #define _VFPF_E
32:            #define _VFPF_F
33:            #define _VFPF_G
34:            #define _VFPF_O
35:            #define _VFPF_N
36:            #define _VFPF_P
37:            #define _VFPF_S
38:            #define _VFPF_U
39:            #define _VFPF_X
40:            #endif
41:            
42:            #ifndef ARRAYSIZE
43:            #define ARRAYSIZE(a)	(sizeof(a)/sizeof(a[0]))
44:            #endif
45:            #ifndef CSTRLEN
46:            #define CSTRLEN(s)	(ARRAYSIZE(s)-1)
47:            #endif
48:            
49:            /* Flags, precision, width */
50:            #define MINUS_FLAG (1 << 0)
51:            #define ZERO_FLAG (1 << 1)
52:            #define PLUS_FLAG (1 << 2)
53:            #define SPACE_FLAG (1 << 3)
54:            #define POUND_FLAG (1 << 4)
55:            static int flags, prec, width;
56:            
57:            #ifdef _VFPF_CONVERT
58:            /* This buffer must be at least 32 bytes long for this code to be safe */
59:            /* Output that would exceed buffer capacity is truncated */
60:            #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
61:            #define DBLEN 80
62:            #define EXPLEN 5
63:            #else
64:            #define DBLEN 32
65:            #endif
66:            static char dbuf[DBLEN];
67:            
68:            /* Character count */
69:            static int nout;
70:            
71:            /* Output the string in dbuf, padded on the left or right */
72:            static _INLINE int pad(FILE *fp, char *buf, int p)
73:            {
74:                int i, w;
75:            
76:                /* Left justify ? Put out string */
77:                if (flags & MINUS_FLAG) {
5B32  A03B     BTFSS flags, 0, ACCESS
78:                    fputs((const char *)buf, fp);
5B36  C029     MOVFF buf, r
5B38  F020     NOP
5B3A  C02A     MOVFF aexp, s
5B3C  F021     NOP
5B3E  C027     MOVFF quotient, s
5B40  F022     NOP
5B42  C028     MOVFF 0x28, sep
5B44  F023     NOP
5B46  EC49     CALL 0x6492, 0
5B48  F032     NOP
79:                }
80:            
81:                /* Put out padding */
82:                w = (p < 0) ? 0 : p;
5B4A  BE2C     BTFSC i, 7, ACCESS
5B4C  D005     BRA 0x5B58
5B4E  C02B     MOVFF p, cp
5B50  F030     NOP
5B52  C02C     MOVFF i, a
5B54  F031     NOP
5B56  D004     BRA 0x5B60
5B58  0E00     MOVLW 0x0
5B5A  6E31     MOVWF a, ACCESS
5B5C  0E00     MOVLW 0x0
5B5E  6E30     MOVWF cp, ACCESS
83:                i = 0;
5B60  0E00     MOVLW 0x0
5B62  6E2F     MOVWF 0x2F, ACCESS
5B64  0E00     MOVLW 0x0
5B66  6E2E     MOVWF w, ACCESS
84:                while (i < w) {
5B68  D00C     BRA 0x5B82
85:                    fputc(' ', fp);
5B6A  0E00     MOVLW 0x0
5B6C  6E18     MOVWF 0x18, ACCESS
5B6E  0E20     MOVLW 0x20
5B70  6E17     MOVWF _r, ACCESS
5B72  C027     MOVFF quotient, multiplicand
5B74  F019     NOP
5B76  C028     MOVFF 0x28, s
5B78  F01A     NOP
5B7A  EC49     CALL 0x5A92, 0
5B7C  F02D     NOP
86:                    ++i;
5B7E  4A2E     INFSNZ w, F, ACCESS
5B80  2A2F     INCF 0x2F, F, ACCESS
87:                }
5B82  5030     MOVF cp, W, ACCESS
5B84  5C2E     SUBWF w, W, ACCESS
5B86  502F     MOVF 0x2F, W, ACCESS
5B88  0A80     XORLW 0x80
5B8A  6E2D     MOVWF counter, ACCESS
5B8C  5031     MOVF a, W, ACCESS
5B8E  0A80     XORLW 0x80
5B90  582D     SUBWFB counter, W, ACCESS
5B92  A0D8     BTFSS STATUS, 0, ACCESS
5B94  D7EA     BRA 0x5B6A
88:            
89:                /* Right justify ? Put out string */
90:                if (!(flags & MINUS_FLAG)) {
5B96  B03B     BTFSC flags, 0, ACCESS
5B98  D00A     BRA 0x5BAE
91:                    fputs((const char *)buf, fp);
5B9A  C029     MOVFF buf, r
5B9C  F020     NOP
5B9E  C02A     MOVFF aexp, s
5BA0  F021     NOP
5BA2  C027     MOVFF quotient, s
5BA4  F022     NOP
5BA6  C028     MOVFF 0x28, sep
5BA8  F023     NOP
5BAA  EC49     CALL 0x6492, 0
5BAC  F032     NOP
92:                }
93:            
94:                return strlen(buf) + w;
5BAE  C029     MOVFF buf, dividend
5BB0  F015     NOP
5BB2  C02A     MOVFF aexp, Message
5BB4  F016     NOP
5BB6  EC03     CALL 0x6006, 0
5BB8  F030     NOP
5BBA  5030     MOVF cp, W, ACCESS
5BBC  2415     ADDWF dividend, W, ACCESS
5BBE  6E27     MOVWF quotient, ACCESS
5BC0  5031     MOVF a, W, ACCESS
5BC2  2016     ADDWFC Message, W, ACCESS
5BC4  6E28     MOVWF 0x28, ACCESS
5BC6  0012     RETURN 0
95:            }
96:            #endif
97:            
98:            #ifdef _VFPF_A
99:            static _INLINE int atoa(FILE *fp, long double f, char c)
100:           {
101:               char mode, nmode;
102:               int d, e, i, m, n, ne, p, pp, sign, t, w;
103:               long double g, h, l, ou, u;
104:           
105:               /* Record sign, get absolute value */
106:               sign = 0;
107:               g = f;
108:               if (g < 0.0) {
109:                   sign = 1;
110:                   g = -g;
111:               }
112:           
113:               /* Print sign, prefix */
114:               n = 0;
115:               w = width;
116:               if (sign || (flags & PLUS_FLAG)) {
117:                   dbuf[n] = sign ? '-' : '+';
118:                   ++n;
119:                   --w;
120:               }
121:               dbuf[n++] = '0';
122:               dbuf[n++] = isupper((int)c) ? 'X' : 'x';
123:           
124:               /* Catch infinities, NaNs here */
125:               if (isinf(g)) {
126:                   if (isupper((int)c)) {
127:                       strcpy(&dbuf[n], "INF");
128:                   } else {
129:                       strcpy(&dbuf[n], "inf");
130:                   }
131:                   w -= CSTRLEN("inf");
132:                   return pad(fp, &dbuf[0], w);
133:               }
134:               if (isnan(g)) {
135:                   if (isupper((int)c)) {
136:                       strcpy(&dbuf[n], "NAN");
137:                   } else {
138:                       strcpy(&dbuf[n], "nan");
139:                   }
140:                   w -= CSTRLEN("inf");
141:                   return pad(fp, &dbuf[0], w);
142:               }
143:           
144:               /* First find the largest power of 2 not larger than number to print */
145:               u = 1.0;
146:               e = 0;
147:               if (!(g == 0.0)) {
148:                   while (!(g < (u*2.0))) {
149:                       u = u*2.0;
150:                       ++e;
151:                   }
152:                   while (g < u) {
153:                       u = u/2.0;
154:                       --e;
155:                   }
156:               }
157:           
158:               /* Get precision */
159:               p = (prec < 0) ? 6 : prec;
160:           
161:               /* Hex places, total */
162:               m = p + 1;
163:           
164:               /* Go through the conversion once to get to the rounding step */
165:               i = 0;
166:               h = g;
167:               ou = u;
168:               while (i < m) {
169:                   l = floor(h/u);
170:                   d = (int)l;
171:                   h -= l*u;
172:                   u = u/16.0;
173:                   ++i;
174:               }
175:               
176:               /* Remainder >= halfway ? */
177:               l = u*8.0;
178:               if (h < l) {
179:                   l = 0.0;
180:               } else {
181:                   /* On tie choose even number */
182:                   if ((h == l) && !(d % 2)) {
183:                       l = 0.0;
184:                   }
185:               }
186:           
187:               /* Round */
188:               h = g + l;
189:               
190:               /* Convert again, after rounding */
191:               u = ou;
192:               ne = 0;
193:               pp = 0;
194:               t = 0;
195:               i = 0;
196:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
197:                   l = floor(h/u);
198:                   d = (int)l;
199:                   if (!(flags & POUND_FLAG) && !d && (ne < 0)) {
200:                       ++t;
201:                   } else {
202:                       if (!pp && (ne < 0)) {
203:                           dbuf[n++] = '.';
204:                           --w;
205:                           pp = 1;
206:                       }
207:                       while (t) {
208:                           dbuf[n++] = '0';
209:                           --w;
210:                           --t;
211:                       }
212:                       d = (d < 10) ? '0' + d : 'a' + (d - 10);
213:                       if (isupper((int)c) && isalpha(d)) {
214:                           d = toupper(d);
215:                       }
216:                       dbuf[n++] = d;
217:                       --w;
218:                   }
219:                   h -= l*u;
220:                   u = u/16.0;
221:                   --ne;
222:                   ++i;
223:               }
224:               if (!pp && (flags & POUND_FLAG)) {
225:                   dbuf[n++] = '.';
226:               }
227:               dbuf[n] = '\0';
228:           
229:               /* Convert exponent */
230:               i = sizeof(dbuf) - 1;
231:               dbuf[i] = '\0';
232:               sign = 0;
233:               if (e < 0) {
234:                   sign = 1;
235:                   e = -e;
236:               }
237:               p = 1;
238:               while (e || (0 < p)) {
239:                   --i;
240:                   dbuf[i] = '0' + (e % 10);
241:                   e = e / 10;
242:                   --p;
243:                   --w;
244:               }
245:               --i;
246:               dbuf[i] = sign ? '-' : '+';
247:               --w;
248:               --i;
249:               dbuf[i] = isupper((int)c) ? 'P' : 'p';
250:               --w;
251:               strcpy(&dbuf[n], &dbuf[i]);
252:           
253:               /* Put out padded string */
254:               return pad(fp, &dbuf[0], w);
255:           }
256:           #endif
257:           
258:           #ifdef _VFPF_C
259:           static _INLINE int ctoa(FILE *fp, char c)
260:           {
261:               int l, w;
262:           
263:               /* Get width */
264:               w = width ? width - 1 : width;
6194  5037     MOVF width, W, ACCESS
265:           
266:               /* Put out padded string */
267:               dbuf[0] = c;
61B2  C034     MOVFF l, dbuf
61B4  F16A     NOP
268:               dbuf[1] = '\0';
61B6  0E00     MOVLW 0x0
61B8  0101     MOVLB 0x1
61BA  6F6B     MOVWF prod, BANKED
269:               return pad(fp, &dbuf[0], w);
61BC  C032     MOVFF p, quotient
61BE  F027     NOP
61C0  C033     MOVFF 0x33, 0x28
61C2  F028     NOP
61C4  0E6A     MOVLW 0x6A
61C6  6E29     MOVWF buf, ACCESS
61C8  0E01     MOVLW 0x1
61CA  6E2A     MOVWF aexp, ACCESS
61CC  C035     MOVFF w, p
61CE  F02B     NOP
61D0  C036     MOVFF exp1, i
61D2  F02C     NOP
61D4  EC99     CALL 0x5B32, 0
61D6  F02D     NOP
61D8  C027     MOVFF quotient, p
61DA  F032     NOP
61DC  C028     MOVFF 0x28, 0x33
61DE  F033     NOP
61E0  0012     RETURN 0
270:           }
271:           #endif
272:           
273:           #ifdef _VFPF_D
274:           static _INLINE int dtoa(FILE *fp, long long d)
275:           {
276:               int i, p, s, w;
277:               long long n;
278:           
279:               /* Record sign, get absolute value */
280:               n = d;
419C  C062     MOVFF d, n
281:               s = n < 0 ? 1 : 0;
41BC  0100     MOVLB 0x0
41BE  AF81     BTFSS sign, 7, BANKED
41C0  D002     BRA 0x41C6
41C2  0E01     MOVLW 0x1
41C4  D001     BRA 0x41C8
41C6  0E00     MOVLW 0x0
41C8  6F78     MOVWF n, BANKED
41CA  6B79     CLRF w, BANKED
282:               if (s) {
41CC  5178     MOVF n, W, BANKED
41CE  1179     IORWF w, W, BANKED
41D0  B4D8     BTFSC STATUS, 2, ACCESS
41D2  D010     BRA 0x41F4
283:                   n = -n;
41D4  1F81     COMF sign, F, BANKED
41D6  1F80     COMF i, F, BANKED
41D8  1F7F     COMF 0x7F, F, BANKED
41DA  1F7E     COMF i, F, BANKED
41DC  1F7D     COMF rem, F, BANKED
41DE  1F7C     COMF 0x7C, F, BANKED
41E0  1F7B     COMF n, F, BANKED
41E2  6D7A     NEGF n, BANKED
41E4  0E00     MOVLW 0x0
41E6  237B     ADDWFC n, F, BANKED
41E8  237C     ADDWFC 0x7C, F, BANKED
41EA  237D     ADDWFC rem, F, BANKED
41EC  237E     ADDWFC i, F, BANKED
41EE  237F     ADDWFC 0x7F, F, BANKED
41F0  2380     ADDWFC i, F, BANKED
41F2  2381     ADDWFC sign, F, BANKED
284:               }
285:           
286:               /* Adjust flags, precision, width */
287:               if (!(prec < 0)) {
41F4  AE3A     BTFSS 0x3A, 7, ACCESS
288:                   flags &= ~ZERO_FLAG;
41F6  923B     BCF flags, 1, ACCESS
289:               }
290:               p = (0 < prec) ? prec : 1;
41F8  BE3A     BTFSC 0x3A, 7, ACCESS
41FA  D005     BRA 0x4206
41FC  503A     MOVF 0x3A, W, ACCESS
41FE  E108     BNZ 0x4210
4200  0439     DECF prec, W, ACCESS
4202  B0D8     BTFSC STATUS, 0, ACCESS
4204  D005     BRA 0x4210
4206  0E00     MOVLW 0x0
4208  6F75     MOVWF a, BANKED
420A  0E01     MOVLW 0x1
420C  6F74     MOVWF w, BANKED
420E  D004     BRA 0x4218
4210  C039     MOVFF prec, w
4212  F074     NOP
4214  C03A     MOVFF 0x3A, a
4216  F075     NOP
291:               w = width;
4218  C037     MOVFF width, n
421A  F076     NOP
421C  C038     MOVFF 0x38, p
421E  F077     NOP
292:               if (s || (flags & PLUS_FLAG)) {
4220  5178     MOVF n, W, BANKED
4222  1179     IORWF w, W, BANKED
4224  A4D8     BTFSS STATUS, 2, ACCESS
4226  D002     BRA 0x422C
4228  A43B     BTFSS flags, 2, ACCESS
422A  D003     BRA 0x4232
293:                   --w;
422C  0776     DECF n, F, BANKED
422E  A0D8     BTFSS STATUS, 0, ACCESS
4230  0777     DECF p, F, BANKED
294:               }
295:           
296:               /* Convert to decimal, possibly filling on the left with zeroes */
297:               i = sizeof(dbuf) - 1;
4232  0E00     MOVLW 0x0
4234  6F83     MOVWF i, BANKED
4236  0E1F     MOVLW 0x1F
4238  6F82     MOVWF i, BANKED
298:               dbuf[i] = '\0';
423A  0E6A     MOVLW 0x6A
423C  2582     ADDWF i, W, BANKED
423E  6ED9     MOVWF FSR2, ACCESS
4240  0E01     MOVLW 0x1
4242  2183     ADDWFC i, W, BANKED
4244  6EDA     MOVWF FSR2H, ACCESS
4246  0E00     MOVLW 0x0
4248  6EDF     MOVWF INDF2, ACCESS
299:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
424A  D07D     BRA 0x4346
300:                   --i;
424C  0782     DECF i, F, BANKED
424E  A0D8     BTFSS STATUS, 0, ACCESS
4250  0783     DECF i, F, BANKED
301:                   dbuf[i] = '0' + abs(n % 10);
4252  0E6A     MOVLW 0x6A
4254  2582     ADDWF i, W, BANKED
4256  6ED9     MOVWF FSR2, ACCESS
4258  0E01     MOVLW 0x1
425A  2183     ADDWFC i, W, BANKED
425C  6EDA     MOVWF FSR2H, ACCESS
425E  C07A     MOVFF n, dividend
4260  F015     NOP
4262  C07B     MOVFF n, Message
4264  F016     NOP
4266  C07C     MOVFF 0x7C, _r
4268  F017     NOP
426A  C07D     MOVFF rem, 0x18
426C  F018     NOP
426E  C07E     MOVFF i, multiplicand
4270  F019     NOP
4272  C07F     MOVFF 0x7F, s
4274  F01A     NOP
4276  C080     MOVFF i, c
4278  F01B     NOP
427A  C081     MOVFF sign, c
427C  F01C     NOP
427E  0E0A     MOVLW 0xA
4280  6E1D     MOVWF divisor, ACCESS
4282  0E00     MOVLW 0x0
4284  6E1E     MOVWF l, ACCESS
4286  0E00     MOVLW 0x0
4288  6E1F     MOVWF i, ACCESS
428A  0E00     MOVLW 0x0
428C  6E20     MOVWF r, ACCESS
428E  0E00     MOVLW 0x0
4290  6E21     MOVWF s, ACCESS
4292  0E00     MOVLW 0x0
4294  6E22     MOVWF s, ACCESS
4296  0E00     MOVLW 0x0
4298  6E23     MOVWF sep, ACCESS
429A  0E00     MOVLW 0x0
429C  6E24     MOVWF n, ACCESS
429E  ECB2     CALL 0x5164, 0
42A0  F028     NOP
42A2  C015     MOVFF dividend, x
42A4  F06A     NOP
42A6  C016     MOVFF Message, prod
42A8  F06B     NOP
42AA  C017     MOVFF _r, 0x6C
42AC  F06C     NOP
42AE  C018     MOVFF 0x18, 0x6D
42B0  F06D     NOP
42B2  C019     MOVFF multiplicand, 0x6E
42B4  F06E     NOP
42B6  C01A     MOVFF s, temp
42B8  F06F     NOP
42BA  C01B     MOVFF c, 0x70
42BC  F070     NOP
42BE  C01C     MOVFF c, b
42C0  F071     NOP
42C2  C06A     MOVFF x, quotient
42C4  F027     NOP
42C6  C06C     MOVFF 0x6C, 0x28
42C8  F028     NOP
42CA  ECEA     CALL 0x65D4, 0
42CC  F032     NOP
42CE  5027     MOVF quotient, W, ACCESS
42D0  0F30     ADDLW 0x30
42D2  6EDF     MOVWF INDF2, ACCESS
302:                   --p;
42D4  0100     MOVLB 0x0
42D6  0774     DECF w, F, BANKED
42D8  A0D8     BTFSS STATUS, 0, ACCESS
42DA  0775     DECF a, F, BANKED
303:                   --w;
42DC  0776     DECF n, F, BANKED
42DE  A0D8     BTFSS STATUS, 0, ACCESS
42E0  0777     DECF p, F, BANKED
304:                   n = n / 10;
42E2  C07A     MOVFF n, dividend
42E4  F015     NOP
42E6  C07B     MOVFF n, Message
42E8  F016     NOP
42EA  C07C     MOVFF 0x7C, _r
42EC  F017     NOP
42EE  C07D     MOVFF rem, 0x18
42F0  F018     NOP
42F2  C07E     MOVFF i, multiplicand
42F4  F019     NOP
42F6  C07F     MOVFF 0x7F, s
42F8  F01A     NOP
42FA  C080     MOVFF i, c
42FC  F01B     NOP
42FE  C081     MOVFF sign, c
4300  F01C     NOP
4302  0E0A     MOVLW 0xA
4304  6E1D     MOVWF divisor, ACCESS
4306  0E00     MOVLW 0x0
4308  6E1E     MOVWF l, ACCESS
430A  0E00     MOVLW 0x0
430C  6E1F     MOVWF i, ACCESS
430E  0E00     MOVLW 0x0
4310  6E20     MOVWF r, ACCESS
4312  0E00     MOVLW 0x0
4314  6E21     MOVWF s, ACCESS
4316  0E00     MOVLW 0x0
4318  6E22     MOVWF s, ACCESS
431A  0E00     MOVLW 0x0
431C  6E23     MOVWF sep, ACCESS
431E  0E00     MOVLW 0x0
4320  6E24     MOVWF n, ACCESS
4322  EC39     CALL 0x4C72, 0
4324  F026     NOP
4326  C015     MOVFF dividend, n
4328  F07A     NOP
432A  C016     MOVFF Message, n
432C  F07B     NOP
432E  C017     MOVFF _r, 0x7C
4330  F07C     NOP
4332  C018     MOVFF 0x18, rem
4334  F07D     NOP
4336  C019     MOVFF multiplicand, i
4338  F07E     NOP
433A  C01A     MOVFF s, 0x7F
433C  F07F     NOP
433E  C01B     MOVFF c, i
4340  F080     NOP
4342  C01C     MOVFF c, sign
4344  F081     NOP
305:               }
4346  0100     MOVLB 0x0
4348  BF83     BTFSC i, 7, BANKED
434A  D01F     BRA 0x438A
434C  5183     MOVF i, W, BANKED
434E  E103     BNZ 0x4356
4350  0582     DECF i, W, BANKED
4352  A0D8     BTFSS STATUS, 0, ACCESS
4354  D01A     BRA 0x438A
4356  517A     MOVF n, W, BANKED
4358  117B     IORWF n, W, BANKED
435A  117C     IORWF 0x7C, W, BANKED
435C  117D     IORWF rem, W, BANKED
435E  117E     IORWF i, W, BANKED
4360  117F     IORWF 0x7F, W, BANKED
4362  1180     IORWF i, W, BANKED
4364  1181     IORWF sign, W, BANKED
4366  A4D8     BTFSS STATUS, 2, ACCESS
4368  D771     BRA 0x424C
436A  BF75     BTFSC a, 7, BANKED
436C  D005     BRA 0x4378
436E  5175     MOVF a, W, BANKED
4370  E102     BNZ 0x4376
4372  0574     DECF w, W, BANKED
4374  B0D8     BTFSC STATUS, 0, ACCESS
4376  D76A     BRA 0x424C
4378  BF77     BTFSC p, 7, BANKED
437A  D007     BRA 0x438A
437C  5177     MOVF p, W, BANKED
437E  E103     BNZ 0x4386
4380  0576     DECF n, W, BANKED
4382  A0D8     BTFSS STATUS, 0, ACCESS
4384  D002     BRA 0x438A
4386  B23B     BTFSC flags, 1, ACCESS
4388  D761     BRA 0x424C
306:           
307:               /* Display sign if required */
308:               if (s || (flags & PLUS_FLAG)) {
438A  5178     MOVF n, W, BANKED
438C  1179     IORWF w, W, BANKED
438E  A4D8     BTFSS STATUS, 2, ACCESS
4390  D002     BRA 0x4396
4392  A43B     BTFSS flags, 2, ACCESS
4394  D017     BRA 0x43C4
309:                   --i;
4396  0782     DECF i, F, BANKED
4398  A0D8     BTFSS STATUS, 0, ACCESS
439A  0783     DECF i, F, BANKED
310:                   dbuf[i] = s ? '-' : '+';
439C  5178     MOVF n, W, BANKED
439E  1179     IORWF w, W, BANKED
43A0  A4D8     BTFSS STATUS, 2, ACCESS
43A2  D004     BRA 0x43AC
43A4  0E00     MOVLW 0x0
43A6  6F73     MOVWF 0x73, BANKED
43A8  0E2B     MOVLW 0x2B
43AA  D003     BRA 0x43B2
43AC  0E00     MOVLW 0x0
43AE  6F73     MOVWF 0x73, BANKED
43B0  0E2D     MOVLW 0x2D
43B2  6F72     MOVWF p, BANKED
43B4  0E6A     MOVLW 0x6A
43B6  2582     ADDWF i, W, BANKED
43B8  6ED9     MOVWF FSR2, ACCESS
43BA  0E01     MOVLW 0x1
43BC  2183     ADDWFC i, W, BANKED
43BE  6EDA     MOVWF FSR2H, ACCESS
43C0  C072     MOVFF p, INDF2
43C2  FFDF     NOP
311:               }
312:           
313:               /* Put out padded string */
314:               return pad(fp, &dbuf[i], w);
43C4  C060     MOVFF __pcstackBANK0, quotient
43C6  F027     NOP
43C8  C061     MOVFF 0x61, 0x28
43CA  F028     NOP
43CC  0E6A     MOVLW 0x6A
43CE  2582     ADDWF i, W, BANKED
43D0  6E29     MOVWF buf, ACCESS
43D2  0E01     MOVLW 0x1
43D4  2183     ADDWFC i, W, BANKED
43D6  6E2A     MOVWF aexp, ACCESS
43D8  C076     MOVFF n, p
43DA  F02B     NOP
43DC  C077     MOVFF p, i
43DE  F02C     NOP
43E0  EC99     CALL 0x5B32, 0
43E2  F02D     NOP
43E4  C027     MOVFF quotient, __pcstackBANK0
43E6  F060     NOP
43E8  C028     MOVFF 0x28, 0x61
43EA  F061     NOP
43EC  0012     RETURN 0
315:           }
316:           #endif
317:           
318:           #if defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
319:           static _INLINE int efgtoa(FILE *fp, long double f, char c)
320:           {
321:               char mode, nmode;
322:               int d, e, i, m, n, ne, p, pp, sign, t, w;
323:               long double g, h, l, ou, u;
324:           
325:               /* Record sign, get absolute value */
326:               sign = 0;
327:               g = f;
328:               if (g < 0.0) {
329:                   sign = 1;
330:                   g = -g;
331:               }
332:           
333:               /* Print sign */
334:               n = 0;
335:               w = width;
336:               if (sign || (flags & PLUS_FLAG)) {
337:                   dbuf[n] = sign ? '-' : '+';
338:                   ++n;
339:                   --w;
340:               }
341:           
342:               /* Catch infinities, NaNs here */
343:               if (isinf(g)) {
344:                   if (isupper((int)c)) {
345:                       strcpy(&dbuf[n], "INF");
346:                   } else {
347:                       strcpy(&dbuf[n], "inf");
348:                   }
349:                   w -= CSTRLEN("inf");
350:                   return pad(fp, &dbuf[0], w);
351:               }
352:               if (isnan(g)) {
353:                   if (isupper((int)c)) {
354:                       strcpy(&dbuf[n], "NAN");
355:                   } else {
356:                       strcpy(&dbuf[n], "nan");
357:                   }
358:                   w -= CSTRLEN("inf");
359:                   return pad(fp, &dbuf[0], w);
360:               }
361:           
362:               /* First find the largest power of 10 not larger than number to print */
363:               u = 1.0;
364:               e = 0;
365:               if (!(g == 0.0)) {
366:                   while (!(g < (u*10.0))) {
367:                       u = u*10.0;
368:                       ++e;
369:                   }
370:                   while (g < u) {
371:                       u = u/10.0;
372:                       --e;
373:                   }
374:               }
375:           
376:               /* Get mode, precision */
377:               mode = tolower((int)c);
378:               nmode = mode;
379:               if (mode == 'g') {
380:           		if (prec == 0) {
381:           			prec = 1;
382:           		}
383:                   p = (0 < prec) ? prec : 6;
384:               } else {
385:                   p = (prec < 0) ? 6 : prec;
386:               }
387:           
388:               /* Choose e or f mode from g mode */
389:               if (mode == 'g') {
390:                   if (!(e < -4) && !((p - 1) < e)) {
391:                       nmode = 'f';
392:                   } else {
393:                       nmode = 'e';
394:                   }
395:               }
396:           
397:               /* Decimal places or significant digits */
398:               m = p;
399:               if (!(mode == 'g') || ((nmode == 'f') && (e < 0))) {
400:                   ++m;
401:               }
402:           
403:               /* Adjust starting exponent, string length for 'f' conversions */
404:               if (nmode == 'f') {
405:                   if (e < 0) {
406:                       u = 1.0;
407:                       e = 0;
408:                   }
409:                   if (!(mode == 'g')) {
410:                       m += e;
411:                   }
412:               }
413:           
414:               /* Go through the conversion once to get to the rounding step */
415:               i = 0;
416:               h = g;
417:               ou = u;
418:               while (i < m) {
419:                   l = floor(h/u);
420:                   d = (int)l;
421:                   h -= l*u;
422:                   u = u/10.0;
423:                   ++i;
424:               }
425:               
426:               /* Remainder >= halfway ? */
427:               l = u*5.0;
428:               if (h < l) {
429:                   l = 0.0;
430:               } else {
431:                   /* On tie choose even number */
432:                   if ((h == l) && !(d % 2)) {
433:                       l = 0.0;
434:                   }
435:               }
436:           
437:               /* Round */
438:               h = g + l;
439:               
440:               /* Convert again, after rounding */
441:               u = ou;
442:               ne = (nmode == 'e') ? 0 : e;
443:               pp = 0;
444:               t = 0;
445:               i = 0;
446:               while ((i < m) && (n < (DBLEN - EXPLEN))) {
447:                   l = floor(h/u);
448:                   d = (int)l;
449:                   if (!(flags & POUND_FLAG) && !d && (mode == 'g') && (ne < 0)) {
450:                       ++t;
451:                   } else {
452:                       if (!pp && (ne < 0)) {
453:                           dbuf[n++] = '.';
454:                           --w;
455:                           pp = 1;
456:                       }
457:                       while (t) {
458:                           dbuf[n++] = '0';
459:                           --w;
460:                           --t;
461:                       }
462:                       dbuf[n++] = '0' + d;
463:                       --w;
464:                   }
465:                   h -= l*u;
466:                   u = u/10.0;
467:                   --ne;
468:                   ++i;
469:               }
470:               if (!pp && (flags & POUND_FLAG)) {
471:                   dbuf[n++] = '.';
472:               }
473:               dbuf[n] = '\0';
474:           
475:               /* Convert exponent */
476:               if (nmode == 'e') {
477:                   i = sizeof(dbuf) - 1;
478:                   dbuf[i] = '\0';
479:                   sign = 0;
480:                   if (e < 0) {
481:                       sign = 1;
482:                       e = -e;
483:                   }
484:                   p = 2;
485:                   while (e || (0 < p)) {
486:                       --i;
487:                       dbuf[i] = '0' + (e % 10);
488:                       e = e / 10;
489:                       --p;
490:                       --w;
491:                   }
492:                   --i;
493:                   dbuf[i] = sign ? '-' : '+';
494:                   --w;
495:                   --i;
496:                   dbuf[i] = isupper((int)c) ? 'E' : 'e';
497:                   --w;
498:                   strcpy(&dbuf[n], &dbuf[i]);
499:               }
500:           
501:               /* Put out padded string */
502:               return pad(fp, &dbuf[0], w);
503:           }
504:           #endif
505:           
506:           #ifdef _VFPF_O
507:           static _INLINE int otoa(FILE *fp, unsigned long long d)
508:           {
509:               int i, p, t, w;
510:               unsigned long long n;
511:           
512:               /* Adjust flags, precision, width */
513:               if (!(prec < 0)) {
4992  AE3A     BTFSS 0x3A, 7, ACCESS
514:                   flags &= ~ZERO_FLAG;
4994  923B     BCF flags, 1, ACCESS
515:               }
516:               p = (0 < prec) ? prec : 1;
4996  BE3A     BTFSC 0x3A, 7, ACCESS
4998  D005     BRA 0x49A4
499A  503A     MOVF 0x3A, W, ACCESS
499C  E109     BNZ 0x49B0
499E  0439     DECF prec, W, ACCESS
49A0  B0D8     BTFSC STATUS, 0, ACCESS
49A2  D006     BRA 0x49B0
49A4  0E00     MOVLW 0x0
49A6  0100     MOVLB 0x0
49A8  6F73     MOVWF 0x73, BANKED
49AA  0E01     MOVLW 0x1
49AC  6F72     MOVWF p, BANKED
49AE  D004     BRA 0x49B8
49B0  C039     MOVFF prec, p
49B2  F072     NOP
49B4  C03A     MOVFF 0x3A, 0x73
49B6  F073     NOP
517:               w = width;
49B8  C037     MOVFF width, n
49BA  F076     NOP
49BC  C038     MOVFF 0x38, p
49BE  F077     NOP
518:           
519:               /* Convert to octal, possibly filling on the left with zeroes */
520:               n = d;
49C0  C062     MOVFF d, n
49C2  F078     NOP
49C4  C063     MOVFF 0x63, w
49C6  F079     NOP
49C8  C064     MOVFF sign, n
49CA  F07A     NOP
49CC  C065     MOVFF aexp, n
49CE  F07B     NOP
49D0  C066     MOVFF grs, 0x7C
49D2  F07C     NOP
49D4  C067     MOVFF 0x67, rem
49D6  F07D     NOP
49D8  C068     MOVFF 0x68, i
49DA  F07E     NOP
49DC  C069     MOVFF 0x69, 0x7F
49DE  F07F     NOP
521:               i = sizeof(dbuf) - 1;
49E0  0E00     MOVLW 0x0
49E2  0100     MOVLB 0x0
49E4  6F81     MOVWF sign, BANKED
49E6  0E1F     MOVLW 0x1F
49E8  6F80     MOVWF i, BANKED
522:               dbuf[i] = '\0';
49EA  0E6A     MOVLW 0x6A
49EC  2580     ADDWF i, W, BANKED
49EE  6ED9     MOVWF FSR2, ACCESS
49F0  0E01     MOVLW 0x1
49F2  2181     ADDWFC sign, W, BANKED
49F4  6EDA     MOVWF FSR2H, ACCESS
49F6  0E00     MOVLW 0x0
49F8  6EDF     MOVWF INDF2, ACCESS
523:               t = 0;
49FA  0E00     MOVLW 0x0
49FC  6F75     MOVWF a, BANKED
49FE  0E00     MOVLW 0x0
4A00  6F74     MOVWF w, BANKED
524:               while (!(i < 1) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
4A02  D043     BRA 0x4A8A
525:                   --i;
4A04  0780     DECF i, F, BANKED
4A06  A0D8     BTFSS STATUS, 0, ACCESS
4A08  0781     DECF sign, F, BANKED
526:                   t = n & 07;
4A0A  0E07     MOVLW 0x7
4A0C  1578     ANDWF n, W, BANKED
4A0E  6F74     MOVWF w, BANKED
4A10  6B75     CLRF a, BANKED
527:                   dbuf[i] = '0' + t;
4A12  0E6A     MOVLW 0x6A
4A14  2580     ADDWF i, W, BANKED
4A16  6ED9     MOVWF FSR2, ACCESS
4A18  0E01     MOVLW 0x1
4A1A  2181     ADDWFC sign, W, BANKED
4A1C  6EDA     MOVWF FSR2H, ACCESS
4A1E  5174     MOVF w, W, BANKED
4A20  0F30     ADDLW 0x30
4A22  6EDF     MOVWF INDF2, ACCESS
528:                   --p;
4A24  0772     DECF p, F, BANKED
4A26  A0D8     BTFSS STATUS, 0, ACCESS
4A28  0773     DECF 0x73, F, BANKED
529:                   --w;
4A2A  0776     DECF n, F, BANKED
4A2C  A0D8     BTFSS STATUS, 0, ACCESS
4A2E  0777     DECF p, F, BANKED
530:                   n = n >> 3;
4A30  C078     MOVFF n, x
4A32  F06A     NOP
4A34  C079     MOVFF w, prod
4A36  F06B     NOP
4A38  C07A     MOVFF n, 0x6C
4A3A  F06C     NOP
4A3C  C07B     MOVFF n, 0x6D
4A3E  F06D     NOP
4A40  C07C     MOVFF 0x7C, 0x6E
4A42  F06E     NOP
4A44  C07D     MOVFF rem, temp
4A46  F06F     NOP
4A48  C07E     MOVFF i, 0x70
4A4A  F070     NOP
4A4C  C07F     MOVFF 0x7F, b
4A4E  F071     NOP
4A50  0E04     MOVLW 0x4
4A52  D009     BRA 0x4A66
4A54  90D8     BCF STATUS, 0, ACCESS
4A56  3371     RRCF b, F, BANKED
4A58  3370     RRCF 0x70, F, BANKED
4A5A  336F     RRCF temp, F, BANKED
4A5C  336E     RRCF 0x6E, F, BANKED
4A5E  336D     RRCF 0x6D, F, BANKED
4A60  336C     RRCF 0x6C, F, BANKED
4A62  336B     RRCF prod, F, BANKED
4A64  336A     RRCF x, F, BANKED
4A66  2EE8     DECFSZ WREG, F, ACCESS
4A68  D7F5     BRA 0x4A54
4A6A  C06A     MOVFF x, n
4A6C  F078     NOP
4A6E  C06B     MOVFF prod, w
4A70  F079     NOP
4A72  C06C     MOVFF 0x6C, n
4A74  F07A     NOP
4A76  C06D     MOVFF 0x6D, n
4A78  F07B     NOP
4A7A  C06E     MOVFF 0x6E, 0x7C
4A7C  F07C     NOP
4A7E  C06F     MOVFF temp, rem
4A80  F07D     NOP
4A82  C070     MOVFF 0x70, i
4A84  F07E     NOP
4A86  C071     MOVFF b, 0x7F
4A88  F07F     NOP
531:               }
4A8A  BF81     BTFSC sign, 7, BANKED
4A8C  D01F     BRA 0x4ACC
4A8E  5181     MOVF sign, W, BANKED
4A90  E103     BNZ 0x4A98
4A92  0580     DECF i, W, BANKED
4A94  A0D8     BTFSS STATUS, 0, ACCESS
4A96  D01A     BRA 0x4ACC
4A98  5178     MOVF n, W, BANKED
4A9A  1179     IORWF w, W, BANKED
4A9C  117A     IORWF n, W, BANKED
4A9E  117B     IORWF n, W, BANKED
4AA0  117C     IORWF 0x7C, W, BANKED
4AA2  117D     IORWF rem, W, BANKED
4AA4  117E     IORWF i, W, BANKED
4AA6  117F     IORWF 0x7F, W, BANKED
4AA8  A4D8     BTFSS STATUS, 2, ACCESS
4AAA  D7AC     BRA 0x4A04
4AAC  BF73     BTFSC 0x73, 7, BANKED
4AAE  D005     BRA 0x4ABA
4AB0  5173     MOVF 0x73, W, BANKED
4AB2  E1A8     BNZ 0x4A04
4AB4  0572     DECF p, W, BANKED
4AB6  B0D8     BTFSC STATUS, 0, ACCESS
4AB8  D7A5     BRA 0x4A04
4ABA  BF77     BTFSC p, 7, BANKED
4ABC  D007     BRA 0x4ACC
4ABE  5177     MOVF p, W, BANKED
4AC0  E103     BNZ 0x4AC8
4AC2  0576     DECF n, W, BANKED
4AC4  A0D8     BTFSS STATUS, 0, ACCESS
4AC6  D002     BRA 0x4ACC
4AC8  B23B     BTFSC flags, 1, ACCESS
4ACA  D79C     BRA 0x4A04
532:           
533:               /* Display prefix if required */
534:               if ((flags & POUND_FLAG) && t) {
4ACC  A83B     BTFSS flags, 4, ACCESS
4ACE  D012     BRA 0x4AF4
4AD0  5174     MOVF w, W, BANKED
4AD2  1175     IORWF a, W, BANKED
4AD4  B4D8     BTFSC STATUS, 2, ACCESS
4AD6  D00E     BRA 0x4AF4
535:                   --i;
4AD8  0780     DECF i, F, BANKED
4ADA  A0D8     BTFSS STATUS, 0, ACCESS
4ADC  0781     DECF sign, F, BANKED
536:                   dbuf[i] = '0';
4ADE  0E6A     MOVLW 0x6A
4AE0  2580     ADDWF i, W, BANKED
4AE2  6ED9     MOVWF FSR2, ACCESS
4AE4  0E01     MOVLW 0x1
4AE6  2181     ADDWFC sign, W, BANKED
4AE8  6EDA     MOVWF FSR2H, ACCESS
4AEA  0E30     MOVLW 0x30
4AEC  6EDF     MOVWF INDF2, ACCESS
537:                   --w;
4AEE  0776     DECF n, F, BANKED
4AF0  A0D8     BTFSS STATUS, 0, ACCESS
4AF2  0777     DECF p, F, BANKED
538:               }
539:           
540:               /* Put out padded string */
541:               return pad(fp, &dbuf[i], w);
4AF4  C060     MOVFF __pcstackBANK0, quotient
4AF6  F027     NOP
4AF8  C061     MOVFF 0x61, 0x28
4AFA  F028     NOP
4AFC  0E6A     MOVLW 0x6A
4AFE  2580     ADDWF i, W, BANKED
4B00  6E29     MOVWF buf, ACCESS
4B02  0E01     MOVLW 0x1
4B04  2181     ADDWFC sign, W, BANKED
4B06  6E2A     MOVWF aexp, ACCESS
4B08  C076     MOVFF n, p
4B0A  F02B     NOP
4B0C  C077     MOVFF p, i
4B0E  F02C     NOP
4B10  EC99     CALL 0x5B32, 0
4B12  F02D     NOP
4B14  C027     MOVFF quotient, __pcstackBANK0
4B16  F060     NOP
4B18  C028     MOVFF 0x28, 0x61
4B1A  F061     NOP
4B1C  0012     RETURN 0
542:           }
543:           #endif
544:           
545:           #ifdef _VFPF_S
546:           static _INLINE int stoa(FILE *fp, char *s)
547:           {
548:               char *cp, nuls[] = "(null)";
4EFA  EE21     LFSR 2, 0x18A
549:               int i, l, p, w;
550:           
551:               /* Check for null string */
552:               cp = s;
4F0C  C022     MOVFF s, cp
4F0E  F030     NOP
4F10  C023     MOVFF sep, a
4F12  F031     NOP
553:               if (!cp) {
4F14  5030     MOVF cp, W, ACCESS
4F16  1031     IORWF a, W, ACCESS
4F18  A4D8     BTFSS STATUS, 2, ACCESS
4F1A  D004     BRA 0x4F24
554:                   cp = nuls;
4F1C  0E25     MOVLW 0x25
4F1E  6E30     MOVWF cp, ACCESS
4F20  0E00     MOVLW 0x0
4F22  6E31     MOVWF a, ACCESS
555:               }
556:           
557:               /* Get length, precision, width */
558:               l = strlen(cp);
4F24  C030     MOVFF cp, dividend
4F26  F015     NOP
4F28  C031     MOVFF a, Message
4F2A  F016     NOP
4F2C  EC03     CALL 0x6006, 0
4F2E  F030     NOP
4F30  C015     MOVFF dividend, l
4F32  F034     NOP
4F34  C016     MOVFF Message, w
4F36  F035     NOP
559:               p = prec;
4F38  C039     MOVFF prec, p
4F3A  F032     NOP
4F3C  C03A     MOVFF 0x3A, 0x33
4F3E  F033     NOP
560:               l = (!(p < 0) && (p < l)) ? p : l;
4F40  BE33     BTFSC 0x33, 7, ACCESS
4F42  D00E     BRA 0x4F60
4F44  5034     MOVF l, W, ACCESS
4F46  5C32     SUBWF p, W, ACCESS
4F48  5033     MOVF 0x33, W, ACCESS
4F4A  0A80     XORLW 0x80
4F4C  6E24     MOVWF n, ACCESS
4F4E  5035     MOVF w, W, ACCESS
4F50  0A80     XORLW 0x80
4F52  5824     SUBWFB n, W, ACCESS
4F54  B0D8     BTFSC STATUS, 0, ACCESS
4F56  D004     BRA 0x4F60
4F58  C032     MOVFF p, l
4F5A  F034     NOP
4F5C  C033     MOVFF 0x33, w
4F5E  F035     NOP
561:               p = l;
4F60  C034     MOVFF l, p
4F62  F032     NOP
4F64  C035     MOVFF w, 0x33
4F66  F033     NOP
562:               w = width;
4F68  C037     MOVFF width, w
4F6A  F02E     NOP
4F6C  C038     MOVFF 0x38, 0x2F
4F6E  F02F     NOP
563:           
564:               /* Right justify, pad on left ? */
565:               if (!(flags & MINUS_FLAG)) {
4F70  A03B     BTFSS flags, 0, ACCESS
4F72  D00D     BRA 0x4F8E
4F74  D016     BRA 0x4FA2
566:                   while (l < w) {
567:                       fputc(' ', fp);
4F76  0E00     MOVLW 0x0
4F78  6E18     MOVWF 0x18, ACCESS
4F7A  0E20     MOVLW 0x20
4F7C  6E17     MOVWF _r, ACCESS
4F7E  C020     MOVFF r, multiplicand
4F80  F019     NOP
4F82  C021     MOVFF s, s
4F84  F01A     NOP
4F86  EC49     CALL 0x5A92, 0
4F88  F02D     NOP
568:                       ++l;
4F8A  4A34     INFSNZ l, F, ACCESS
4F8C  2A35     INCF w, F, ACCESS
569:                   }
4F8E  502E     MOVF w, W, ACCESS
4F90  5C34     SUBWF l, W, ACCESS
4F92  5035     MOVF w, W, ACCESS
4F94  0A80     XORLW 0x80
4F96  6E24     MOVWF n, ACCESS
4F98  502F     MOVF 0x2F, W, ACCESS
4F9A  0A80     XORLW 0x80
4F9C  5824     SUBWFB n, W, ACCESS
4F9E  A0D8     BTFSS STATUS, 0, ACCESS
4FA0  D7EA     BRA 0x4F76
570:               }
571:           
572:               /* Put out string */
573:               i = 0;
4FA2  0E00     MOVLW 0x0
4FA4  6E2D     MOVWF counter, ACCESS
4FA6  0E00     MOVLW 0x0
4FA8  6E2C     MOVWF i, ACCESS
574:               while (i < p) {
4FAA  D01E     BRA 0x4FE8
575:                   fputc(*cp, fp);
4FAC  C030     MOVFF cp, TBLPTR
4FAE  FFF6     NOP
4FB0  C031     MOVFF a, TBLPTRH
4FB2  FFF7     NOP
4FB4  6AF8     CLRF TBLPTRU, ACCESS
4FB6  0E0E     MOVLW 0xE
4FB8  64F7     CPFSGT TBLPTRH, ACCESS
4FBA  D003     BRA 0x4FC2
4FBC  0008     TBLRD*
4FBE  50F5     MOVF TABLAT, W, ACCESS
4FC0  D005     BRA 0x4FCC
4FC2  CFF6     MOVFF TBLPTR, FSR0
4FC4  FFE9     NOP
4FC6  CFF7     MOVFF TBLPTRH, FSR0H
4FC8  FFEA     NOP
4FCA  50EF     MOVF INDF0, W, ACCESS
4FCC  6E24     MOVWF n, ACCESS
4FCE  5024     MOVF n, W, ACCESS
4FD0  6E17     MOVWF _r, ACCESS
4FD2  6A18     CLRF 0x18, ACCESS
4FD4  C020     MOVFF r, multiplicand
4FD6  F019     NOP
4FD8  C021     MOVFF s, s
4FDA  F01A     NOP
4FDC  EC49     CALL 0x5A92, 0
4FDE  F02D     NOP
576:                   ++cp;
4FE0  4A30     INFSNZ cp, F, ACCESS
4FE2  2A31     INCF a, F, ACCESS
577:                   ++i;
4FE4  4A2C     INFSNZ i, F, ACCESS
4FE6  2A2D     INCF counter, F, ACCESS
578:               }
4FE8  5032     MOVF p, W, ACCESS
4FEA  5C2C     SUBWF i, W, ACCESS
4FEC  502D     MOVF counter, W, ACCESS
4FEE  0A80     XORLW 0x80
4FF0  6E24     MOVWF n, ACCESS
4FF2  5033     MOVF 0x33, W, ACCESS
4FF4  0A80     XORLW 0x80
4FF6  5824     SUBWFB n, W, ACCESS
4FF8  A0D8     BTFSS STATUS, 0, ACCESS
4FFA  D7D8     BRA 0x4FAC
579:           
580:               /* Left justify, pad on right ? */
581:               if (flags & MINUS_FLAG) {
4FFC  B03B     BTFSC flags, 0, ACCESS
4FFE  D00D     BRA 0x501A
5000  D016     BRA 0x502E
582:                   while (l < w) {
583:                       fputc(' ', fp);
5002  0E00     MOVLW 0x0
5004  6E18     MOVWF 0x18, ACCESS
5006  0E20     MOVLW 0x20
5008  6E17     MOVWF _r, ACCESS
500A  C020     MOVFF r, multiplicand
500C  F019     NOP
500E  C021     MOVFF s, s
5010  F01A     NOP
5012  EC49     CALL 0x5A92, 0
5014  F02D     NOP
584:                       ++l;
5016  4A34     INFSNZ l, F, ACCESS
5018  2A35     INCF w, F, ACCESS
585:                   }
501A  502E     MOVF w, W, ACCESS
501C  5C34     SUBWF l, W, ACCESS
501E  5035     MOVF w, W, ACCESS
5020  0A80     XORLW 0x80
5022  6E24     MOVWF n, ACCESS
5024  502F     MOVF 0x2F, W, ACCESS
5026  0A80     XORLW 0x80
5028  5824     SUBWFB n, W, ACCESS
502A  A0D8     BTFSS STATUS, 0, ACCESS
502C  D7EA     BRA 0x5002
586:               }
587:           
588:               return l;
502E  C034     MOVFF l, r
5030  F020     NOP
5032  C035     MOVFF w, s
5034  F021     NOP
589:           }
5036  0012     RETURN 0
590:           #endif
591:           
592:           #ifdef _VFPF_U
593:           static _INLINE int utoa(FILE *fp, unsigned long long d)
594:           {
595:               int i, p, w;
596:               unsigned long long n;
597:           
598:               /* Adjust flags, precision, width */
599:               if (!(prec < 0)) {
4630  AE3A     BTFSS 0x3A, 7, ACCESS
600:                   flags &= ~ZERO_FLAG;
4632  923B     BCF flags, 1, ACCESS
601:               }
602:               p = (0 < prec) ? prec : 1;
4634  BE3A     BTFSC 0x3A, 7, ACCESS
4636  D005     BRA 0x4642
4638  503A     MOVF 0x3A, W, ACCESS
463A  E109     BNZ 0x464E
463C  0439     DECF prec, W, ACCESS
463E  B0D8     BTFSC STATUS, 0, ACCESS
4640  D006     BRA 0x464E
4642  0E00     MOVLW 0x0
4644  0100     MOVLB 0x0
4646  6F73     MOVWF 0x73, BANKED
4648  0E01     MOVLW 0x1
464A  6F72     MOVWF p, BANKED
464C  D004     BRA 0x4656
464E  C039     MOVFF prec, p
4650  F072     NOP
4652  C03A     MOVFF 0x3A, 0x73
4654  F073     NOP
603:               w = width;
4656  C037     MOVFF width, w
4658  F074     NOP
465A  C038     MOVFF 0x38, a
465C  F075     NOP
604:           
605:               /* Convert to decimal, possibly filling on the left with zeroes */
606:               n = d;
465E  C062     MOVFF d, n
4660  F076     NOP
4662  C063     MOVFF 0x63, p
4664  F077     NOP
4666  C064     MOVFF sign, n
4668  F078     NOP
466A  C065     MOVFF aexp, w
466C  F079     NOP
466E  C066     MOVFF grs, n
4670  F07A     NOP
4672  C067     MOVFF 0x67, n
4674  F07B     NOP
4676  C068     MOVFF 0x68, 0x7C
4678  F07C     NOP
467A  C069     MOVFF 0x69, rem
467C  F07D     NOP
607:               i = sizeof(dbuf) - 1;
467E  0E00     MOVLW 0x0
4680  0100     MOVLB 0x0
4682  6F7F     MOVWF 0x7F, BANKED
4684  0E1F     MOVLW 0x1F
4686  6F7E     MOVWF i, BANKED
608:               dbuf[i] = '\0';
4688  0E6A     MOVLW 0x6A
468A  257E     ADDWF i, W, BANKED
468C  6ED9     MOVWF FSR2, ACCESS
468E  0E01     MOVLW 0x1
4690  217F     ADDWFC 0x7F, W, BANKED
4692  6EDA     MOVWF FSR2H, ACCESS
4694  0E00     MOVLW 0x0
4696  6EDF     MOVWF INDF2, ACCESS
609:               while (i && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
4698  D077     BRA 0x4788
610:                   --i;
469A  077E     DECF i, F, BANKED
469C  A0D8     BTFSS STATUS, 0, ACCESS
469E  077F     DECF 0x7F, F, BANKED
611:                   dbuf[i] = '0' + (n % 10);
46A0  0E6A     MOVLW 0x6A
46A2  257E     ADDWF i, W, BANKED
46A4  6ED9     MOVWF FSR2, ACCESS
46A6  0E01     MOVLW 0x1
46A8  217F     ADDWFC 0x7F, W, BANKED
46AA  6EDA     MOVWF FSR2H, ACCESS
46AC  C076     MOVFF n, dividend
46AE  F015     NOP
46B0  C077     MOVFF p, Message
46B2  F016     NOP
46B4  C078     MOVFF n, _r
46B6  F017     NOP
46B8  C079     MOVFF w, 0x18
46BA  F018     NOP
46BC  C07A     MOVFF n, multiplicand
46BE  F019     NOP
46C0  C07B     MOVFF n, s
46C2  F01A     NOP
46C4  C07C     MOVFF 0x7C, c
46C6  F01B     NOP
46C8  C07D     MOVFF rem, c
46CA  F01C     NOP
46CC  0E0A     MOVLW 0xA
46CE  6E1D     MOVWF divisor, ACCESS
46D0  0E00     MOVLW 0x0
46D2  6E1E     MOVWF l, ACCESS
46D4  0E00     MOVLW 0x0
46D6  6E1F     MOVWF i, ACCESS
46D8  0E00     MOVLW 0x0
46DA  6E20     MOVWF r, ACCESS
46DC  0E00     MOVLW 0x0
46DE  6E21     MOVWF s, ACCESS
46E0  0E00     MOVLW 0x0
46E2  6E22     MOVWF s, ACCESS
46E4  0E00     MOVLW 0x0
46E6  6E23     MOVWF sep, ACCESS
46E8  0E00     MOVLW 0x0
46EA  6E24     MOVWF n, ACCESS
46EC  ECF2     CALL 0x59E4, 0
46EE  F02C     NOP
46F0  C015     MOVFF dividend, x
46F2  F06A     NOP
46F4  C016     MOVFF Message, prod
46F6  F06B     NOP
46F8  C017     MOVFF _r, 0x6C
46FA  F06C     NOP
46FC  C018     MOVFF 0x18, 0x6D
46FE  F06D     NOP
4700  C019     MOVFF multiplicand, 0x6E
4702  F06E     NOP
4704  C01A     MOVFF s, temp
4706  F06F     NOP
4708  C01B     MOVFF c, 0x70
470A  F070     NOP
470C  C01C     MOVFF c, b
470E  F071     NOP
4710  0100     MOVLB 0x0
4712  516A     MOVF x, W, BANKED
4714  0F30     ADDLW 0x30
4716  6EDF     MOVWF INDF2, ACCESS
612:                   --p;
4718  0772     DECF p, F, BANKED
471A  A0D8     BTFSS STATUS, 0, ACCESS
471C  0773     DECF 0x73, F, BANKED
613:                   --w;
471E  0774     DECF w, F, BANKED
4720  A0D8     BTFSS STATUS, 0, ACCESS
4722  0775     DECF a, F, BANKED
614:                   n = n / 10;
4724  C076     MOVFF n, dividend
4726  F015     NOP
4728  C077     MOVFF p, Message
472A  F016     NOP
472C  C078     MOVFF n, _r
472E  F017     NOP
4730  C079     MOVFF w, 0x18
4732  F018     NOP
4734  C07A     MOVFF n, multiplicand
4736  F019     NOP
4738  C07B     MOVFF n, s
473A  F01A     NOP
473C  C07C     MOVFF 0x7C, c
473E  F01B     NOP
4740  C07D     MOVFF rem, c
4742  F01C     NOP
4744  0E0A     MOVLW 0xA
4746  6E1D     MOVWF divisor, ACCESS
4748  0E00     MOVLW 0x0
474A  6E1E     MOVWF l, ACCESS
474C  0E00     MOVLW 0x0
474E  6E1F     MOVWF i, ACCESS
4750  0E00     MOVLW 0x0
4752  6E20     MOVWF r, ACCESS
4754  0E00     MOVLW 0x0
4756  6E21     MOVWF s, ACCESS
4758  0E00     MOVLW 0x0
475A  6E22     MOVWF s, ACCESS
475C  0E00     MOVLW 0x0
475E  6E23     MOVWF sep, ACCESS
4760  0E00     MOVLW 0x0
4762  6E24     MOVWF n, ACCESS
4764  EC31     CALL 0x5862, 0
4766  F02C     NOP
4768  C015     MOVFF dividend, n
476A  F076     NOP
476C  C016     MOVFF Message, p
476E  F077     NOP
4770  C017     MOVFF _r, n
4772  F078     NOP
4774  C018     MOVFF 0x18, w
4776  F079     NOP
4778  C019     MOVFF multiplicand, n
477A  F07A     NOP
477C  C01A     MOVFF s, n
477E  F07B     NOP
4780  C01B     MOVFF c, 0x7C
4782  F07C     NOP
4784  C01C     MOVFF c, rem
4786  F07D     NOP
615:               }
4788  0100     MOVLB 0x0
478A  517E     MOVF i, W, BANKED
478C  117F     IORWF 0x7F, W, BANKED
478E  B4D8     BTFSC STATUS, 2, ACCESS
4790  D01A     BRA 0x47C6
4792  5176     MOVF n, W, BANKED
4794  1177     IORWF p, W, BANKED
4796  1178     IORWF n, W, BANKED
4798  1179     IORWF w, W, BANKED
479A  117A     IORWF n, W, BANKED
479C  117B     IORWF n, W, BANKED
479E  117C     IORWF 0x7C, W, BANKED
47A0  117D     IORWF rem, W, BANKED
47A2  A4D8     BTFSS STATUS, 2, ACCESS
47A4  D77A     BRA 0x469A
47A6  BF73     BTFSC 0x73, 7, BANKED
47A8  D005     BRA 0x47B4
47AA  5173     MOVF 0x73, W, BANKED
47AC  E102     BNZ 0x47B2
47AE  0572     DECF p, W, BANKED
47B0  B0D8     BTFSC STATUS, 0, ACCESS
47B2  D773     BRA 0x469A
47B4  BF75     BTFSC a, 7, BANKED
47B6  D007     BRA 0x47C6
47B8  5175     MOVF a, W, BANKED
47BA  E103     BNZ 0x47C2
47BC  0574     DECF w, W, BANKED
47BE  A0D8     BTFSS STATUS, 0, ACCESS
47C0  D002     BRA 0x47C6
47C2  B23B     BTFSC flags, 1, ACCESS
47C4  D76A     BRA 0x469A
616:           
617:               /* Put out padded string */
618:               return pad(fp, &dbuf[i], w);
47C6  C060     MOVFF __pcstackBANK0, quotient
47C8  F027     NOP
47CA  C061     MOVFF 0x61, 0x28
47CC  F028     NOP
47CE  0E6A     MOVLW 0x6A
47D0  257E     ADDWF i, W, BANKED
47D2  6E29     MOVWF buf, ACCESS
47D4  0E01     MOVLW 0x1
47D6  217F     ADDWFC 0x7F, W, BANKED
47D8  6E2A     MOVWF aexp, ACCESS
47DA  C074     MOVFF w, p
47DC  F02B     NOP
47DE  C075     MOVFF a, i
47E0  F02C     NOP
47E2  EC99     CALL 0x5B32, 0
47E4  F02D     NOP
47E6  C027     MOVFF quotient, __pcstackBANK0
47E8  F060     NOP
47EA  C028     MOVFF 0x28, 0x61
47EC  F061     NOP
47EE  0012     RETURN 0
619:           }
620:           #endif
621:           
622:           #if defined(_VFPF_X) || defined(_VFPF_P)
623:           static _INLINE int xtoa(FILE *fp, unsigned long long d, char x)
624:           {
625:               int c, i, p, w;
626:               unsigned long long n;
627:           
628:               /* Adjust, flags, precision, width */
629:               if (!(prec < 0)) {
43EE  AE3A     BTFSS 0x3A, 7, ACCESS
630:                   flags &= ~ZERO_FLAG;
43F0  923B     BCF flags, 1, ACCESS
631:               }
632:               p = (0 < prec) ? prec : 1;
43F2  BE3A     BTFSC 0x3A, 7, ACCESS
43F4  D005     BRA 0x4400
43F6  503A     MOVF 0x3A, W, ACCESS
43F8  E109     BNZ 0x440C
43FA  0439     DECF prec, W, ACCESS
43FC  B0D8     BTFSC STATUS, 0, ACCESS
43FE  D006     BRA 0x440C
4400  0E00     MOVLW 0x0
4402  0100     MOVLB 0x0
4404  6F78     MOVWF n, BANKED
4406  0E01     MOVLW 0x1
4408  6F77     MOVWF p, BANKED
440A  D004     BRA 0x4414
440C  C039     MOVFF prec, p
440E  F077     NOP
4410  C03A     MOVFF 0x3A, n
4412  F078     NOP
633:               w = width;
4414  C037     MOVFF width, w
4416  F079     NOP
4418  C038     MOVFF 0x38, n
441A  F07A     NOP
634:               if (flags & POUND_FLAG) {
441C  A83B     BTFSS flags, 4, ACCESS
441E  D005     BRA 0x442A
635:                   w -= 2;
4420  0100     MOVLB 0x0
4422  0EFE     MOVLW 0xFE
4424  2779     ADDWF w, F, BANKED
4426  0EFF     MOVLW 0xFF
4428  237A     ADDWFC n, F, BANKED
636:               }
637:           
638:               /* Convert to hexadecimal, possibly filling on the left with zeroes */
639:               n = d;
442A  C062     MOVFF d, n
442C  F07B     NOP
442E  C063     MOVFF 0x63, 0x7C
4430  F07C     NOP
4432  C064     MOVFF sign, rem
4434  F07D     NOP
4436  C065     MOVFF aexp, i
4438  F07E     NOP
443A  C066     MOVFF grs, 0x7F
443C  F07F     NOP
443E  C067     MOVFF 0x67, i
4440  F080     NOP
4442  C068     MOVFF 0x68, sign
4444  F081     NOP
4446  C069     MOVFF 0x69, i
4448  F082     NOP
640:               i = sizeof(dbuf) - 1;
444A  0E00     MOVLW 0x0
444C  0100     MOVLB 0x0
444E  6F84     MOVWF grs, BANKED
4450  0E1F     MOVLW 0x1F
4452  6F83     MOVWF i, BANKED
641:               dbuf[i] = '\0';
4454  0E6A     MOVLW 0x6A
4456  2583     ADDWF i, W, BANKED
4458  6ED9     MOVWF FSR2, ACCESS
445A  0E01     MOVLW 0x1
445C  2184     ADDWFC grs, W, BANKED
445E  6EDA     MOVWF FSR2H, ACCESS
4460  0E00     MOVLW 0x0
4462  6EDF     MOVWF INDF2, ACCESS
642:               while (!(i < 2) && (n || (0 < p) || ((0 < w) && (flags & ZERO_FLAG)))) {
4464  D096     BRA 0x4592
643:                   --i;
4466  0783     DECF i, F, BANKED
4468  A0D8     BTFSS STATUS, 0, ACCESS
446A  0784     DECF grs, F, BANKED
644:                   c = n & 0x0f;
446C  0E0F     MOVLW 0xF
446E  157B     ANDWF n, W, BANKED
4470  6F85     MOVWF c, BANKED
4472  6B86     CLRF 0x86, BANKED
645:                   c = (c < 10) ? '0' + c : 'a' + (c - 10);
4474  BF86     BTFSC 0x86, 7, BANKED
4476  D008     BRA 0x4488
4478  5186     MOVF 0x86, W, BANKED
447A  E104     BNZ 0x4484
447C  0E0A     MOVLW 0xA
447E  5D85     SUBWF c, W, BANKED
4480  A0D8     BTFSS STATUS, 0, ACCESS
4482  D002     BRA 0x4488
4484  0E57     MOVLW 0x57
4486  D001     BRA 0x448A
4488  0E30     MOVLW 0x30
448A  2585     ADDWF c, W, BANKED
448C  6F85     MOVWF c, BANKED
448E  0E00     MOVLW 0x0
4490  2186     ADDWFC 0x86, W, BANKED
4492  6F86     MOVWF 0x86, BANKED
646:                   if (isupper((int)x) && isalpha(c)) {
4494  0EBF     MOVLW 0xBF
4496  6F6B     MOVWF prod, BANKED
4498  0EFF     MOVLW 0xFF
449A  6F6C     MOVWF 0x6C, BANKED
449C  516A     MOVF x, W, BANKED
449E  6F6D     MOVWF 0x6D, BANKED
44A0  6B6E     CLRF 0x6E, BANKED
44A2  516B     MOVF prod, W, BANKED
44A4  276D     ADDWF 0x6D, F, BANKED
44A6  516C     MOVF 0x6C, W, BANKED
44A8  236E     ADDWFC 0x6E, F, BANKED
44AA  516E     MOVF 0x6E, W, BANKED
44AC  E106     BNZ 0x44BA
44AE  0E1A     MOVLW 0x1A
44B0  5D6D     SUBWF 0x6D, W, BANKED
44B2  B0D8     BTFSC STATUS, 0, ACCESS
44B4  D002     BRA 0x44BA
44B6  0E01     MOVLW 0x1
44B8  D001     BRA 0x44BC
44BA  0E00     MOVLW 0x0
44BC  6F73     MOVWF 0x73, BANKED
44BE  6B74     CLRF w, BANKED
44C0  0100     MOVLB 0x0
44C2  5173     MOVF 0x73, W, BANKED
44C4  1174     IORWF w, W, BANKED
44C6  B4D8     BTFSC STATUS, 2, ACCESS
44C8  D028     BRA 0x451A
44CA  0E9F     MOVLW 0x9F
44CC  6F6B     MOVWF prod, BANKED
44CE  0EFF     MOVLW 0xFF
44D0  6F6C     MOVWF 0x6C, BANKED
44D2  0E20     MOVLW 0x20
44D4  1185     IORWF c, W, BANKED
44D6  6F6D     MOVWF 0x6D, BANKED
44D8  0E00     MOVLW 0x0
44DA  1186     IORWF 0x86, W, BANKED
44DC  6F6E     MOVWF 0x6E, BANKED
44DE  516B     MOVF prod, W, BANKED
44E0  276D     ADDWF 0x6D, F, BANKED
44E2  516C     MOVF 0x6C, W, BANKED
44E4  236E     ADDWFC 0x6E, F, BANKED
44E6  516E     MOVF 0x6E, W, BANKED
44E8  E106     BNZ 0x44F6
44EA  0E1A     MOVLW 0x1A
44EC  5D6D     SUBWF 0x6D, W, BANKED
44EE  B0D8     BTFSC STATUS, 0, ACCESS
44F0  D002     BRA 0x44F6
44F2  0E01     MOVLW 0x1
44F4  D001     BRA 0x44F8
44F6  0E00     MOVLW 0x0
44F8  6F75     MOVWF a, BANKED
44FA  6B76     CLRF n, BANKED
44FC  0100     MOVLB 0x0
44FE  5175     MOVF a, W, BANKED
4500  1176     IORWF n, W, BANKED
4502  B4D8     BTFSC STATUS, 2, ACCESS
4504  D00A     BRA 0x451A
647:                       c = toupper(c);
4506  C085     MOVFF c, c
4508  F01B     NOP
450A  C086     MOVFF 0x86, c
450C  F01C     NOP
450E  EC16     CALL 0x622C, 0
4510  F031     NOP
4512  C01B     MOVFF c, c
4514  F085     NOP
4516  C01C     MOVFF c, 0x86
4518  F086     NOP
648:                   }
649:                   dbuf[i] = (char)c;
451A  0E6A     MOVLW 0x6A
451C  0100     MOVLB 0x0
451E  2583     ADDWF i, W, BANKED
4520  6ED9     MOVWF FSR2, ACCESS
4522  0E01     MOVLW 0x1
4524  2184     ADDWFC grs, W, BANKED
4526  6EDA     MOVWF FSR2H, ACCESS
4528  C085     MOVFF c, INDF2
452A  FFDF     NOP
650:                   --p;
452C  0777     DECF p, F, BANKED
452E  A0D8     BTFSS STATUS, 0, ACCESS
4530  0778     DECF n, F, BANKED
651:                   --w;
4532  0779     DECF w, F, BANKED
4534  A0D8     BTFSS STATUS, 0, ACCESS
4536  077A     DECF n, F, BANKED
652:                   n = n >> 4;
4538  C07B     MOVFF n, prod
453A  F06B     NOP
453C  C07C     MOVFF 0x7C, 0x6C
453E  F06C     NOP
4540  C07D     MOVFF rem, 0x6D
4542  F06D     NOP
4544  C07E     MOVFF i, 0x6E
4546  F06E     NOP
4548  C07F     MOVFF 0x7F, temp
454A  F06F     NOP
454C  C080     MOVFF i, 0x70
454E  F070     NOP
4550  C081     MOVFF sign, b
4552  F071     NOP
4554  C082     MOVFF i, p
4556  F072     NOP
4558  0E05     MOVLW 0x5
455A  D009     BRA 0x456E
455C  90D8     BCF STATUS, 0, ACCESS
455E  3372     RRCF p, F, BANKED
4560  3371     RRCF b, F, BANKED
4562  3370     RRCF 0x70, F, BANKED
4564  336F     RRCF temp, F, BANKED
4566  336E     RRCF 0x6E, F, BANKED
4568  336D     RRCF 0x6D, F, BANKED
456A  336C     RRCF 0x6C, F, BANKED
456C  336B     RRCF prod, F, BANKED
456E  2EE8     DECFSZ WREG, F, ACCESS
4570  D7F5     BRA 0x455C
4572  C06B     MOVFF prod, n
4574  F07B     NOP
4576  C06C     MOVFF 0x6C, 0x7C
4578  F07C     NOP
457A  C06D     MOVFF 0x6D, rem
457C  F07D     NOP
457E  C06E     MOVFF 0x6E, i
4580  F07E     NOP
4582  C06F     MOVFF temp, 0x7F
4584  F07F     NOP
4586  C070     MOVFF 0x70, i
4588  F080     NOP
458A  C071     MOVFF b, sign
458C  F081     NOP
458E  C072     MOVFF p, i
4590  F082     NOP
653:               }
4592  BF84     BTFSC grs, 7, BANKED
4594  D020     BRA 0x45D6
4596  5184     MOVF grs, W, BANKED
4598  E104     BNZ 0x45A2
459A  0E02     MOVLW 0x2
459C  5D83     SUBWF i, W, BANKED
459E  A0D8     BTFSS STATUS, 0, ACCESS
45A0  D01A     BRA 0x45D6
45A2  517B     MOVF n, W, BANKED
45A4  117C     IORWF 0x7C, W, BANKED
45A6  117D     IORWF rem, W, BANKED
45A8  117E     IORWF i, W, BANKED
45AA  117F     IORWF 0x7F, W, BANKED
45AC  1180     IORWF i, W, BANKED
45AE  1181     IORWF sign, W, BANKED
45B0  1182     IORWF i, W, BANKED
45B2  A4D8     BTFSS STATUS, 2, ACCESS
45B4  D758     BRA 0x4466
45B6  BF78     BTFSC n, 7, BANKED
45B8  D005     BRA 0x45C4
45BA  5178     MOVF n, W, BANKED
45BC  E102     BNZ 0x45C2
45BE  0577     DECF p, W, BANKED
45C0  B0D8     BTFSC STATUS, 0, ACCESS
45C2  D751     BRA 0x4466
45C4  BF7A     BTFSC n, 7, BANKED
45C6  D007     BRA 0x45D6
45C8  517A     MOVF n, W, BANKED
45CA  E103     BNZ 0x45D2
45CC  0579     DECF w, W, BANKED
45CE  A0D8     BTFSS STATUS, 0, ACCESS
45D0  D002     BRA 0x45D6
45D2  B23B     BTFSC flags, 1, ACCESS
45D4  D748     BRA 0x4466
654:           
655:               /* Display prefix if required */
656:               if (flags & POUND_FLAG) {
45D6  A83B     BTFSS flags, 4, ACCESS
45D8  D016     BRA 0x4606
657:                   --i;
45DA  0783     DECF i, F, BANKED
45DC  A0D8     BTFSS STATUS, 0, ACCESS
45DE  0784     DECF grs, F, BANKED
658:                   dbuf[i] = x;
45E0  0E6A     MOVLW 0x6A
45E2  2583     ADDWF i, W, BANKED
45E4  6ED9     MOVWF FSR2, ACCESS
45E6  0E01     MOVLW 0x1
45E8  2184     ADDWFC grs, W, BANKED
45EA  6EDA     MOVWF FSR2H, ACCESS
45EC  C06A     MOVFF x, INDF2
45EE  FFDF     NOP
659:                   --i;
45F0  0783     DECF i, F, BANKED
45F2  A0D8     BTFSS STATUS, 0, ACCESS
45F4  0784     DECF grs, F, BANKED
660:                   dbuf[i] = '0';
45F6  0E6A     MOVLW 0x6A
45F8  2583     ADDWF i, W, BANKED
45FA  6ED9     MOVWF FSR2, ACCESS
45FC  0E01     MOVLW 0x1
45FE  2184     ADDWFC grs, W, BANKED
4600  6EDA     MOVWF FSR2H, ACCESS
4602  0E30     MOVLW 0x30
4604  6EDF     MOVWF INDF2, ACCESS
661:               }
662:           
663:               /* Put out padded string */
664:               return pad(fp, &dbuf[i], w);
4606  C060     MOVFF __pcstackBANK0, quotient
4608  F027     NOP
460A  C061     MOVFF 0x61, 0x28
460C  F028     NOP
460E  0E6A     MOVLW 0x6A
4610  2583     ADDWF i, W, BANKED
4612  6E29     MOVWF buf, ACCESS
4614  0E01     MOVLW 0x1
4616  2184     ADDWFC grs, W, BANKED
4618  6E2A     MOVWF aexp, ACCESS
461A  C079     MOVFF w, p
461C  F02B     NOP
461E  C07A     MOVFF n, i
4620  F02C     NOP
4622  EC99     CALL 0x5B32, 0
4624  F02D     NOP
4626  C027     MOVFF quotient, __pcstackBANK0
4628  F060     NOP
462A  C028     MOVFF 0x28, 0x61
462C  F061     NOP
462E  0012     RETURN 0
665:           }
666:           #endif
667:           
668:           /* Consume and convert the next part of the format string */
669:           #ifdef _VFPF_CONVERT
670:           static _INLINE int vfpfcnvrt(FILE *fp, char *fmt[], va_list ap)
671:           {
672:               char c, *cp, ct[3];
673:               int done, i;
674:               long long ll;
675:               unsigned long long llu;
676:               long double f;
677:               void *vp;
678:           
679:               /* Conversion ? */
680:               if ((*fmt)[0] == '%') {
0074  C089     MOVFF fmt, FSR2
681:                   ++*fmt;
0090  C089     MOVFF fmt, FSR2
0092  FFD9     NOP
0094  C08A     MOVFF s, FSR2H
0096  FFDA     NOP
0098  2ADE     INCF POSTINC2, F, ACCESS
009A  0E00     MOVLW 0x0
009C  22DD     ADDWFC POSTDEC2, F, ACCESS
682:           
683:                   flags = width = 0;
009E  0E00     MOVLW 0x0
00A0  6E38     MOVWF 0x38, ACCESS
00A2  0E00     MOVLW 0x0
00A4  6E37     MOVWF width, ACCESS
00A6  C037     MOVFF width, flags
00A8  F03B     NOP
00AA  C038     MOVFF 0x38, 0x3C
00AC  F03C     NOP
684:                   prec = -1;
00AE  6839     SETF prec, ACCESS
00B0  683A     SETF 0x3A, ACCESS
685:           
686:           #ifdef _VFPF_FLAGS
687:                   /* Get flags */
688:                   done = 0;
00B2  0E00     MOVLW 0x0
00B4  0100     MOVLB 0x0
00B6  6F94     MOVWF 0x94, BANKED
00B8  0E00     MOVLW 0x0
00BA  D014     BRA 0xE4
689:                   while (!done) {
012A  5193     MOVF done, W, BANKED
012C  1194     IORWF 0x94, W, BANKED
012E  B4D8     BTFSC STATUS, 2, ACCESS
0130  D7DB     BRA 0xE8
690:                       switch ((*fmt)[0]) {
691:                           case '-' :
692:                               flags |= MINUS_FLAG;
00BC  803B     BSF flags, 0, ACCESS
693:                               ++*fmt;
00BE  D007     BRA 0xCE
694:                               break;
695:                           case '0' :
696:                               flags |= ZERO_FLAG;
00C0  823B     BSF flags, 1, ACCESS
697:                               ++*fmt;
00C2  D005     BRA 0xCE
698:                               break;
699:                           case '+' :
700:                               flags |= PLUS_FLAG;
00C4  843B     BSF flags, 2, ACCESS
701:                               ++*fmt;
00C6  D003     BRA 0xCE
702:                               break;
703:                           case ' ' :
704:                               flags |= SPACE_FLAG;
00C8  863B     BSF flags, 3, ACCESS
705:                               ++*fmt;
00CA  D001     BRA 0xCE
706:                               break;
707:                           case '#' :
708:                               flags |= POUND_FLAG;
00CC  883B     BSF flags, 4, ACCESS
709:                               ++*fmt;
00CE  C089     MOVFF fmt, FSR2
00D0  FFD9     NOP
00D2  C08A     MOVFF s, FSR2H
00D4  FFDA     NOP
00D6  2ADE     INCF POSTINC2, F, ACCESS
00D8  0E00     MOVLW 0x0
00DA  22DD     ADDWFC POSTDEC2, F, ACCESS
710:                               break;
00DC  D026     BRA 0x12A
711:                           default:
712:                               done = 1;
00DE  0E00     MOVLW 0x0
00E0  6F94     MOVWF 0x94, BANKED
00E2  0E01     MOVLW 0x1
00E4  6F93     MOVWF done, BANKED
713:                               break;
714:                       }
00E6  D021     BRA 0x12A
00E8  C089     MOVFF fmt, FSR2
00EA  FFD9     NOP
00EC  C08A     MOVFF s, FSR2H
00EE  FFDA     NOP
00F0  CFDE     MOVFF POSTINC2, TBLPTR
00F2  FFF6     NOP
00F4  CFDD     MOVFF POSTDEC2, TBLPTRH
00F6  FFF7     NOP
00F8  0008     TBLRD*
00FA  50F5     MOVF TABLAT, W, ACCESS
00FC  6F8D     MOVWF 0x8D, BANKED
00FE  6B8E     CLRF 0x8E, BANKED
0100  518E     MOVF 0x8E, W, BANKED
0102  0A00     XORLW 0x0
0104  A4D8     BTFSS STATUS, 2, ACCESS
0106  D7EB     BRA 0xDE
0108  518D     MOVF 0x8D, W, BANKED
010A  0A20     XORLW 0x20
010C  B4D8     BTFSC STATUS, 2, ACCESS
010E  D7DC     BRA 0xC8
0110  0A03     XORLW 0x3
0112  B4D8     BTFSC STATUS, 2, ACCESS
0114  D7DB     BRA 0xCC
0116  0A08     XORLW 0x8
0118  B4D8     BTFSC STATUS, 2, ACCESS
011A  D7D4     BRA 0xC4
011C  0A06     XORLW 0x6
011E  B4D8     BTFSC STATUS, 2, ACCESS
0120  D7CD     BRA 0xBC
0122  0A1D     XORLW 0x1D
0124  B4D8     BTFSC STATUS, 2, ACCESS
0126  D7CC     BRA 0xC0
0128  D7DA     BRA 0xDE
715:                   }
716:                   if (flags & MINUS_FLAG) {
0132  B03B     BTFSC flags, 0, ACCESS
717:                       flags &= ~ZERO_FLAG;
0134  923B     BCF flags, 1, ACCESS
718:                   }
719:           #endif
720:           
721:           #ifdef _VFPF_WIDTH
722:                   /* Get field width */
723:                   if ((*fmt)[0] == '*') {
0136  C089     MOVFF fmt, FSR2
0138  FFD9     NOP
013A  C08A     MOVFF s, FSR2H
013C  FFDA     NOP
013E  CFDE     MOVFF POSTINC2, TBLPTR
0140  FFF6     NOP
0142  CFDD     MOVFF POSTDEC2, TBLPTRH
0144  FFF7     NOP
0146  0008     TBLRD*
0148  50F5     MOVF TABLAT, W, ACCESS
014A  0A2A     XORLW 0x2A
014C  A4D8     BTFSS STATUS, 2, ACCESS
014E  D023     BRA 0x196
724:                       ++*fmt;
0150  C089     MOVFF fmt, FSR2
0152  FFD9     NOP
0154  C08A     MOVFF s, FSR2H
0156  FFDA     NOP
0158  2ADE     INCF POSTINC2, F, ACCESS
015A  0E00     MOVLW 0x0
015C  22DD     ADDWFC POSTDEC2, F, ACCESS
725:                       width = va_arg(ap, int);
015E  C08B     MOVFF ap, FSR2
0160  FFD9     NOP
0162  C08C     MOVFF res, FSR2H
0164  FFDA     NOP
0166  CFDF     MOVFF INDF2, 0x8D
0168  F08D     NOP
016A  0E02     MOVLW 0x2
016C  26DE     ADDWF POSTINC2, F, ACCESS
016E  CFDF     MOVFF INDF2, 0x8E
0170  F08E     NOP
0172  0E00     MOVLW 0x0
0174  22DD     ADDWFC POSTDEC2, F, ACCESS
0176  C08D     MOVFF 0x8D, FSR2
0178  FFD9     NOP
017A  C08E     MOVFF 0x8E, FSR2H
017C  FFDA     NOP
017E  CFDE     MOVFF POSTINC2, width
0180  F037     NOP
0182  CFDD     MOVFF POSTDEC2, 0x38
0184  F038     NOP
726:                       if (width < 0) {
0186  AE38     BTFSS 0x38, 7, ACCESS
0188  D041     BRA 0x20C
727:                           flags |= MINUS_FLAG;
018A  803B     BSF flags, 0, ACCESS
728:                           width = -width;
018C  6C37     NEGF width, ACCESS
018E  1E38     COMF 0x38, F, ACCESS
0190  B0D8     BTFSC STATUS, 0, ACCESS
0192  2A38     INCF 0x38, F, ACCESS
729:                       }
730:                   } else {
0194  D03B     BRA 0x20C
731:                       width = atoi(*fmt);
0196  C089     MOVFF fmt, FSR2
0198  FFD9     NOP
019A  C08A     MOVFF s, FSR2H
019C  FFDA     NOP
019E  CFDE     MOVFF POSTINC2, c
01A0  F01C     NOP
01A2  CFDD     MOVFF POSTDEC2, divisor
01A4  F01D     NOP
01A6  EC8F     CALL 0x4B1E, 0
01A8  F025     NOP
01AA  C01C     MOVFF c, width
01AC  F037     NOP
01AE  C01D     MOVFF divisor, 0x38
01B0  F038     NOP
732:                       while (isdigit((*fmt)[0])) {
01B2  D007     BRA 0x1C2
733:                           ++*fmt;
01B4  C089     MOVFF fmt, FSR2
01B6  FFD9     NOP
01B8  C08A     MOVFF s, FSR2H
01BA  FFDA     NOP
01BC  2ADE     INCF POSTINC2, F, ACCESS
01BE  0E00     MOVLW 0x0
01C0  22DD     ADDWFC POSTDEC2, F, ACCESS
734:                       }
01C2  0ED0     MOVLW 0xD0
01C4  0100     MOVLB 0x0
01C6  6F8D     MOVWF 0x8D, BANKED
01C8  0EFF     MOVLW 0xFF
01CA  6F8E     MOVWF 0x8E, BANKED
01CC  C089     MOVFF fmt, FSR2
01CE  FFD9     NOP
01D0  C08A     MOVFF s, FSR2H
01D2  FFDA     NOP
01D4  CFDE     MOVFF POSTINC2, TBLPTR
01D6  FFF6     NOP
01D8  CFDD     MOVFF POSTDEC2, TBLPTRH
01DA  FFF7     NOP
01DC  0008     TBLRD*
01DE  50F5     MOVF TABLAT, W, ACCESS
01E0  6F8F     MOVWF 0x8F, BANKED
01E2  6B90     CLRF 0x90, BANKED
01E4  518D     MOVF 0x8D, W, BANKED
01E6  278F     ADDWF 0x8F, F, BANKED
01E8  518E     MOVF 0x8E, W, BANKED
01EA  2390     ADDWFC 0x90, F, BANKED
01EC  5190     MOVF 0x90, W, BANKED
01EE  E106     BNZ 0x1FC
01F0  0E0A     MOVLW 0xA
01F2  5D8F     SUBWF 0x8F, W, BANKED
01F4  B0D8     BTFSC STATUS, 0, ACCESS
01F6  D002     BRA 0x1FC
01F8  0E01     MOVLW 0x1
01FA  D001     BRA 0x1FE
01FC  0E00     MOVLW 0x0
01FE  6F95     MOVWF 0x95, BANKED
0200  6B96     CLRF 0x96, BANKED
0202  0100     MOVLB 0x0
0204  5195     MOVF 0x95, W, BANKED
0206  1196     IORWF 0x96, W, BANKED
0208  A4D8     BTFSS STATUS, 2, ACCESS
020A  D7D4     BRA 0x1B4
735:                   }
736:           #endif
737:           
738:           #ifdef _VFPF_PRECISION
739:                   /* Get precision */
740:                   if ((*fmt)[0] == '.') {
020C  C089     MOVFF fmt, FSR2
020E  FFD9     NOP
0210  C08A     MOVFF s, FSR2H
0212  FFDA     NOP
0214  CFDE     MOVFF POSTINC2, TBLPTR
0216  FFF6     NOP
0218  CFDD     MOVFF POSTDEC2, TBLPTRH
021A  FFF7     NOP
021C  0008     TBLRD*
021E  50F5     MOVF TABLAT, W, ACCESS
0220  0A2E     XORLW 0x2E
0222  A4D8     BTFSS STATUS, 2, ACCESS
0224  D06F     BRA 0x304
741:                       prec = 0;
0226  0E00     MOVLW 0x0
0228  6E3A     MOVWF 0x3A, ACCESS
022A  0E00     MOVLW 0x0
022C  6E39     MOVWF prec, ACCESS
742:                       ++*fmt;
022E  C089     MOVFF fmt, FSR2
0230  FFD9     NOP
0232  C08A     MOVFF s, FSR2H
0234  FFDA     NOP
0236  2ADE     INCF POSTINC2, F, ACCESS
0238  0E00     MOVLW 0x0
023A  22DD     ADDWFC POSTDEC2, F, ACCESS
743:                       if ((*fmt)[0] == '*') {
023C  C089     MOVFF fmt, FSR2
023E  FFD9     NOP
0240  C08A     MOVFF s, FSR2H
0242  FFDA     NOP
0244  CFDE     MOVFF POSTINC2, TBLPTR
0246  FFF6     NOP
0248  CFDD     MOVFF POSTDEC2, TBLPTRH
024A  FFF7     NOP
024C  0008     TBLRD*
024E  50F5     MOVF TABLAT, W, ACCESS
0250  0A2A     XORLW 0x2A
0252  A4D8     BTFSS STATUS, 2, ACCESS
0254  D01C     BRA 0x28E
744:                           ++*fmt;
0256  C089     MOVFF fmt, FSR2
0258  FFD9     NOP
025A  C08A     MOVFF s, FSR2H
025C  FFDA     NOP
025E  2ADE     INCF POSTINC2, F, ACCESS
0260  0E00     MOVLW 0x0
0262  22DD     ADDWFC POSTDEC2, F, ACCESS
745:                           prec = va_arg(ap, int);
0264  C08B     MOVFF ap, FSR2
0266  FFD9     NOP
0268  C08C     MOVFF res, FSR2H
026A  FFDA     NOP
026C  CFDF     MOVFF INDF2, 0x8D
026E  F08D     NOP
0270  0E02     MOVLW 0x2
0272  26DE     ADDWF POSTINC2, F, ACCESS
0274  CFDF     MOVFF INDF2, 0x8E
0276  F08E     NOP
0278  0E00     MOVLW 0x0
027A  22DD     ADDWFC POSTDEC2, F, ACCESS
027C  C08D     MOVFF 0x8D, FSR2
027E  FFD9     NOP
0280  C08E     MOVFF 0x8E, FSR2H
0282  FFDA     NOP
0284  CFDE     MOVFF POSTINC2, prec
0286  F039     NOP
0288  CFDD     MOVFF POSTDEC2, 0x3A
028A  F03A     NOP
746:                       } else {
028C  D03B     BRA 0x304
747:                           prec = atoi(*fmt);
028E  C089     MOVFF fmt, FSR2
0290  FFD9     NOP
0292  C08A     MOVFF s, FSR2H
0294  FFDA     NOP
0296  CFDE     MOVFF POSTINC2, c
0298  F01C     NOP
029A  CFDD     MOVFF POSTDEC2, divisor
029C  F01D     NOP
029E  EC8F     CALL 0x4B1E, 0
02A0  F025     NOP
02A2  C01C     MOVFF c, prec
02A4  F039     NOP
02A6  C01D     MOVFF divisor, 0x3A
02A8  F03A     NOP
748:                           while (isdigit((*fmt)[0])) {
02AA  D007     BRA 0x2BA
749:                               ++*fmt;
02AC  C089     MOVFF fmt, FSR2
02AE  FFD9     NOP
02B0  C08A     MOVFF s, FSR2H
02B2  FFDA     NOP
02B4  2ADE     INCF POSTINC2, F, ACCESS
02B6  0E00     MOVLW 0x0
02B8  22DD     ADDWFC POSTDEC2, F, ACCESS
750:                           }
02BA  0ED0     MOVLW 0xD0
02BC  0100     MOVLB 0x0
02BE  6F8D     MOVWF 0x8D, BANKED
02C0  0EFF     MOVLW 0xFF
02C2  6F8E     MOVWF 0x8E, BANKED
02C4  C089     MOVFF fmt, FSR2
02C6  FFD9     NOP
02C8  C08A     MOVFF s, FSR2H
02CA  FFDA     NOP
02CC  CFDE     MOVFF POSTINC2, TBLPTR
02CE  FFF6     NOP
02D0  CFDD     MOVFF POSTDEC2, TBLPTRH
02D2  FFF7     NOP
02D4  0008     TBLRD*
02D6  50F5     MOVF TABLAT, W, ACCESS
02D8  6F8F     MOVWF 0x8F, BANKED
02DA  6B90     CLRF 0x90, BANKED
02DC  518D     MOVF 0x8D, W, BANKED
02DE  278F     ADDWF 0x8F, F, BANKED
02E0  518E     MOVF 0x8E, W, BANKED
02E2  2390     ADDWFC 0x90, F, BANKED
02E4  5190     MOVF 0x90, W, BANKED
02E6  E106     BNZ 0x2F4
02E8  0E0A     MOVLW 0xA
02EA  5D8F     SUBWF 0x8F, W, BANKED
02EC  B0D8     BTFSC STATUS, 0, ACCESS
02EE  D002     BRA 0x2F4
02F0  0E01     MOVLW 0x1
02F2  D001     BRA 0x2F6
02F4  0E00     MOVLW 0x0
02F6  6F97     MOVWF 0x97, BANKED
02F8  6B98     CLRF 0x98, BANKED
02FA  0100     MOVLB 0x0
02FC  5197     MOVF 0x97, W, BANKED
02FE  1198     IORWF 0x98, W, BANKED
0300  A4D8     BTFSS STATUS, 2, ACCESS
0302  D7D4     BRA 0x2AC
751:                       }
752:                   }
753:           #endif
754:           
755:           #if defined(_VFPF_A) || defined(_VFPF_E) || defined(_VFPF_F) || defined(_VFPF_G)
756:                   /* Case-folded conversion types */
757:                   ct[0] = tolower((int)(*fmt)[0]);
758:                   if (ct[0]) {
759:                       ct[1] = tolower((int)(*fmt)[1]);
760:                       if (ct[1]) {
761:                           ct[2] = tolower((int)(*fmt)[2]);
762:                       }
763:                   }
764:           #endif
765:           
766:           #ifdef _VFPF_A
767:                   /* 'a' style (hex) floating point */
768:                   if (ct[0] == 'a') {
769:           
770:                       c = (*fmt)[0];
771:                       ++*fmt;
772:                       f = (long double)va_arg(ap, double);
773:                                   
774:                       return atoa(fp, f, c);
775:                   }
776:                   if (!strncmp(ct, "la", CSTRLEN("la"))) {
777:           
778:                       c = (*fmt)[1];
779:                       if (isupper((int)(*fmt)[0])) {
780:                           f = va_arg(ap, long double);
781:                       } else {
782:                           f = (long double)va_arg(ap, double);
783:                       }
784:                       *fmt += CSTRLEN("la");
785:                                   
786:                       return atoa(fp, f, c);
787:                   }
788:           #endif
789:           
790:           #ifdef _VFPF_C
791:                   /* Character */
792:                   if (*fmt[0] == 'c') {
0304  C089     MOVFF fmt, FSR2
0306  FFD9     NOP
0308  C08A     MOVFF s, FSR2H
030A  FFDA     NOP
030C  CFDE     MOVFF POSTINC2, TBLPTR
030E  FFF6     NOP
0310  CFDD     MOVFF POSTDEC2, TBLPTRH
0312  FFF7     NOP
0314  0008     TBLRD*
0316  50F5     MOVF TABLAT, W, ACCESS
0318  0A63     XORLW 0x63
031A  A4D8     BTFSS STATUS, 2, ACCESS
031C  D026     BRA 0x36A
793:                       ++*fmt;
031E  C089     MOVFF fmt, FSR2
0320  FFD9     NOP
0322  C08A     MOVFF s, FSR2H
0324  FFDA     NOP
0326  2ADE     INCF POSTINC2, F, ACCESS
0328  0E00     MOVLW 0x0
032A  22DD     ADDWFC POSTDEC2, F, ACCESS
794:                       c = (unsigned char)va_arg(ap, int);
032C  C08B     MOVFF ap, FSR2
032E  FFD9     NOP
0330  C08C     MOVFF res, FSR2H
0332  FFDA     NOP
0334  CFDF     MOVFF INDF2, 0x8D
0336  F08D     NOP
0338  0E02     MOVLW 0x2
033A  26DE     ADDWF POSTINC2, F, ACCESS
033C  CFDF     MOVFF INDF2, 0x8E
033E  F08E     NOP
0340  0E00     MOVLW 0x0
0342  22DD     ADDWFC POSTDEC2, F, ACCESS
0344  C08D     MOVFF 0x8D, FSR2
0346  FFD9     NOP
0348  C08E     MOVFF 0x8E, FSR2H
034A  FFDA     NOP
034C  50DF     MOVF INDF2, W, ACCESS
034E  6FA3     MOVWF c, BANKED
795:                       return ctoa(fp, c);
0350  C087     MOVFF fp, p
0352  F032     NOP
0354  C088     MOVFF bexp, 0x33
0356  F033     NOP
0358  C0A3     MOVFF c, l
035A  F034     NOP
035C  ECCA     CALL 0x6194, 0
035E  F030     NOP
0360  C032     MOVFF p, fp
0362  F087     NOP
0364  C033     MOVFF 0x33, bexp
0366  F088     NOP
0368  0012     RETURN 0
796:                   }
797:           #endif
798:           
799:           #ifdef _VFPF_D
800:           #ifdef _VFPF_HH
801:                   /* Character decimal integer */
802:                   if (!strncmp(*fmt, "hhd", CSTRLEN("hhd")) || \
036A  C089     MOVFF fmt, FSR2
036C  FFD9     NOP
036E  C08A     MOVFF s, FSR2H
0370  FFDA     NOP
0372  CFDE     MOVFF POSTINC2, dividend
0374  F015     NOP
0376  CFDD     MOVFF POSTDEC2, Message
0378  F016     NOP
037A  0ECB     MOVLW 0xCB
037C  6E17     MOVWF _r, ACCESS
037E  0E7F     MOVLW 0x7F
0380  6E18     MOVWF 0x18, ACCESS
0382  0E00     MOVLW 0x0
0384  6E1A     MOVWF s, ACCESS
0386  0E03     MOVLW 0x3
0388  6E19     MOVWF multiplicand, ACCESS
038A  ECD7     CALL 0x55AE, 0
038C  F02A     NOP
038E  5015     MOVF dividend, W, ACCESS
0390  1016     IORWF Message, W, ACCESS
0392  B4D8     BTFSC STATUS, 2, ACCESS
0394  D016     BRA 0x3C2
0396  C089     MOVFF fmt, FSR2
0398  FFD9     NOP
039A  C08A     MOVFF s, FSR2H
039C  FFDA     NOP
039E  CFDE     MOVFF POSTINC2, dividend
03A0  F015     NOP
03A2  CFDD     MOVFF POSTDEC2, Message
03A4  F016     NOP
03A6  0ECF     MOVLW 0xCF
03A8  6E17     MOVWF _r, ACCESS
03AA  0E7F     MOVLW 0x7F
03AC  6E18     MOVWF 0x18, ACCESS
03AE  0E00     MOVLW 0x0
03B0  6E1A     MOVWF s, ACCESS
03B2  0E03     MOVLW 0x3
03B4  6E19     MOVWF multiplicand, ACCESS
03B6  ECD7     CALL 0x55AE, 0
03B8  F02A     NOP
03BA  5015     MOVF dividend, W, ACCESS
03BC  1016     IORWF Message, W, ACCESS
03BE  A4D8     BTFSS STATUS, 2, ACCESS
03C0  D040     BRA 0x442
803:                       !strncmp(*fmt, "hhi", CSTRLEN("hhi"))) {
804:           
805:                       *fmt += CSTRLEN("hhd");
03C2  0E03     MOVLW 0x3
03C4  C089     MOVFF fmt, FSR2
03C6  FFD9     NOP
03C8  C08A     MOVFF s, FSR2H
03CA  FFDA     NOP
03CC  26DE     ADDWF POSTINC2, F, ACCESS
03CE  0E00     MOVLW 0x0
03D0  22DD     ADDWFC POSTDEC2, F, ACCESS
806:                       ll = (long long)(signed char)va_arg(ap, int);
03D2  C08B     MOVFF ap, FSR2
03D4  FFD9     NOP
03D6  C08C     MOVFF res, FSR2H
03D8  FFDA     NOP
03DA  CFDF     MOVFF INDF2, 0x8D
03DC  F08D     NOP
03DE  0E02     MOVLW 0x2
03E0  26DE     ADDWF POSTINC2, F, ACCESS
03E2  CFDF     MOVFF INDF2, 0x8E
03E4  F08E     NOP
03E6  0E00     MOVLW 0x0
03E8  22DD     ADDWFC POSTDEC2, F, ACCESS
03EA  C08D     MOVFF 0x8D, FSR2
03EC  FFD9     NOP
03EE  C08E     MOVFF 0x8E, FSR2H
03F0  FFDA     NOP
03F2  50DF     MOVF INDF2, W, ACCESS
03F4  0100     MOVLB 0x0
03F6  6F99     MOVWF ll, BANKED
03F8  0E00     MOVLW 0x0
03FA  BF99     BTFSC ll, 7, BANKED
03FC  0EFF     MOVLW 0xFF
03FE  6F9A     MOVWF 0x9A, BANKED
0400  6F9B     MOVWF 0x9B, BANKED
0402  6F9C     MOVWF 0x9C, BANKED
0404  6F9D     MOVWF 0x9D, BANKED
0406  6F9E     MOVWF 0x9E, BANKED
0408  6F9F     MOVWF 0x9F, BANKED
040A  6FA0     MOVWF 0xA0, BANKED
807:                                   
808:                       return dtoa(fp, ll);
040C  C087     MOVFF fp, __pcstackBANK0
040E  F060     NOP
0410  C088     MOVFF bexp, 0x61
0412  F061     NOP
0414  C099     MOVFF ll, d
0416  F062     NOP
0418  C09A     MOVFF 0x9A, 0x63
041A  F063     NOP
041C  C09B     MOVFF 0x9B, sign
041E  F064     NOP
0420  C09C     MOVFF 0x9C, aexp
0422  F065     NOP
0424  C09D     MOVFF 0x9D, grs
0426  F066     NOP
0428  C09E     MOVFF 0x9E, 0x67
042A  F067     NOP
042C  C09F     MOVFF 0x9F, 0x68
042E  F068     NOP
0430  C0A0     MOVFF 0xA0, 0x69
0432  F069     NOP
0434  ECCE     CALL 0x419C, 0
0436  F020     NOP
0438  C060     MOVFF __pcstackBANK0, fp
043A  F087     NOP
043C  C061     MOVFF 0x61, bexp
043E  F088     NOP
0440  0012     RETURN 0
809:                   }
810:           #endif
811:           
812:           #ifdef _VFPF_H
813:                   /* Short decimal integer */
814:                   if (!strncmp(*fmt, "hd", CSTRLEN("hd")) || \
0442  C089     MOVFF fmt, FSR2
0444  FFD9     NOP
0446  C08A     MOVFF s, FSR2H
0448  FFDA     NOP
044A  CFDE     MOVFF POSTINC2, dividend
044C  F015     NOP
044E  CFDD     MOVFF POSTDEC2, Message
0450  F016     NOP
0452  0ECC     MOVLW 0xCC
0454  6E17     MOVWF _r, ACCESS
0456  0E7F     MOVLW 0x7F
0458  6E18     MOVWF 0x18, ACCESS
045A  0E00     MOVLW 0x0
045C  6E1A     MOVWF s, ACCESS
045E  0E02     MOVLW 0x2
0460  6E19     MOVWF multiplicand, ACCESS
0462  ECD7     CALL 0x55AE, 0
0464  F02A     NOP
0466  5015     MOVF dividend, W, ACCESS
0468  1016     IORWF Message, W, ACCESS
046A  B4D8     BTFSC STATUS, 2, ACCESS
046C  D016     BRA 0x49A
046E  C089     MOVFF fmt, FSR2
0470  FFD9     NOP
0472  C08A     MOVFF s, FSR2H
0474  FFDA     NOP
0476  CFDE     MOVFF POSTINC2, dividend
0478  F015     NOP
047A  CFDD     MOVFF POSTDEC2, Message
047C  F016     NOP
047E  0ED0     MOVLW 0xD0
0480  6E17     MOVWF _r, ACCESS
0482  0E7F     MOVLW 0x7F
0484  6E18     MOVWF 0x18, ACCESS
0486  0E00     MOVLW 0x0
0488  6E1A     MOVWF s, ACCESS
048A  0E02     MOVLW 0x2
048C  6E19     MOVWF multiplicand, ACCESS
048E  ECD7     CALL 0x55AE, 0
0490  F02A     NOP
0492  5015     MOVF dividend, W, ACCESS
0494  1016     IORWF Message, W, ACCESS
0496  A4D8     BTFSS STATUS, 2, ACCESS
0498  D041     BRA 0x51C
815:                       !strncmp(*fmt, "hi", CSTRLEN("hi"))) {
816:           
817:                       *fmt += CSTRLEN("hd");
049A  0E02     MOVLW 0x2
049C  C089     MOVFF fmt, FSR2
049E  FFD9     NOP
04A0  C08A     MOVFF s, FSR2H
04A2  FFDA     NOP
04A4  26DE     ADDWF POSTINC2, F, ACCESS
04A6  0E00     MOVLW 0x0
04A8  22DD     ADDWFC POSTDEC2, F, ACCESS
818:                       ll = (long long)(short)va_arg(ap, int);
04AA  C08B     MOVFF ap, FSR2
04AC  FFD9     NOP
04AE  C08C     MOVFF res, FSR2H
04B0  FFDA     NOP
04B2  CFDF     MOVFF INDF2, 0x8D
04B4  F08D     NOP
04B6  0E02     MOVLW 0x2
04B8  26DE     ADDWF POSTINC2, F, ACCESS
04BA  CFDF     MOVFF INDF2, 0x8E
04BC  F08E     NOP
04BE  0E00     MOVLW 0x0
04C0  22DD     ADDWFC POSTDEC2, F, ACCESS
04C2  C08D     MOVFF 0x8D, FSR2
04C4  FFD9     NOP
04C6  C08E     MOVFF 0x8E, FSR2H
04C8  FFDA     NOP
04CA  CFDE     MOVFF POSTINC2, ll
04CC  F099     NOP
04CE  CFDD     MOVFF POSTDEC2, 0x9A
04D0  F09A     NOP
04D2  0100     MOVLB 0x0
04D4  0E00     MOVLW 0x0
04D6  BF9A     BTFSC 0x9A, 7, BANKED
04D8  0EFF     MOVLW 0xFF
04DA  6F9B     MOVWF 0x9B, BANKED
04DC  6F9C     MOVWF 0x9C, BANKED
04DE  6F9D     MOVWF 0x9D, BANKED
04E0  6F9E     MOVWF 0x9E, BANKED
04E2  6F9F     MOVWF 0x9F, BANKED
04E4  6FA0     MOVWF 0xA0, BANKED
819:                                   
820:                       return dtoa(fp, ll);
04E6  C087     MOVFF fp, __pcstackBANK0
04E8  F060     NOP
04EA  C088     MOVFF bexp, 0x61
04EC  F061     NOP
04EE  C099     MOVFF ll, d
04F0  F062     NOP
04F2  C09A     MOVFF 0x9A, 0x63
04F4  F063     NOP
04F6  C09B     MOVFF 0x9B, sign
04F8  F064     NOP
04FA  C09C     MOVFF 0x9C, aexp
04FC  F065     NOP
04FE  C09D     MOVFF 0x9D, grs
0500  F066     NOP
0502  C09E     MOVFF 0x9E, 0x67
0504  F067     NOP
0506  C09F     MOVFF 0x9F, 0x68
0508  F068     NOP
050A  C0A0     MOVFF 0xA0, 0x69
050C  F069     NOP
050E  ECCE     CALL 0x419C, 0
0510  F020     NOP
0512  C060     MOVFF __pcstackBANK0, fp
0514  F087     NOP
0516  C061     MOVFF 0x61, bexp
0518  F088     NOP
051A  0012     RETURN 0
821:                   }
822:           #endif
823:           
824:                   /* Decimal integer */
825:                   if ((*fmt[0] == 'd') || (*fmt[0] == 'i')) {
051C  C089     MOVFF fmt, FSR2
051E  FFD9     NOP
0520  C08A     MOVFF s, FSR2H
0522  FFDA     NOP
0524  CFDE     MOVFF POSTINC2, TBLPTR
0526  FFF6     NOP
0528  CFDD     MOVFF POSTDEC2, TBLPTRH
052A  FFF7     NOP
052C  0008     TBLRD*
052E  50F5     MOVF TABLAT, W, ACCESS
0530  0A64     XORLW 0x64
0532  B4D8     BTFSC STATUS, 2, ACCESS
0534  D00D     BRA 0x550
0536  C089     MOVFF fmt, FSR2
0538  FFD9     NOP
053A  C08A     MOVFF s, FSR2H
053C  FFDA     NOP
053E  CFDE     MOVFF POSTINC2, TBLPTR
0540  FFF6     NOP
0542  CFDD     MOVFF POSTDEC2, TBLPTRH
0544  FFF7     NOP
0546  0008     TBLRD*
0548  50F5     MOVF TABLAT, W, ACCESS
054A  0A69     XORLW 0x69
054C  A4D8     BTFSS STATUS, 2, ACCESS
054E  D040     BRA 0x5D0
826:           
827:                       ++*fmt;
0550  C089     MOVFF fmt, FSR2
0552  FFD9     NOP
0554  C08A     MOVFF s, FSR2H
0556  FFDA     NOP
0558  2ADE     INCF POSTINC2, F, ACCESS
055A  0E00     MOVLW 0x0
055C  22DD     ADDWFC POSTDEC2, F, ACCESS
828:                       ll = (long long)va_arg(ap, int);
055E  C08B     MOVFF ap, FSR2
0560  FFD9     NOP
0562  C08C     MOVFF res, FSR2H
0564  FFDA     NOP
0566  CFDF     MOVFF INDF2, 0x8D
0568  F08D     NOP
056A  0E02     MOVLW 0x2
056C  26DE     ADDWF POSTINC2, F, ACCESS
056E  CFDF     MOVFF INDF2, 0x8E
0570  F08E     NOP
0572  0E00     MOVLW 0x0
0574  22DD     ADDWFC POSTDEC2, F, ACCESS
0576  C08D     MOVFF 0x8D, FSR2
0578  FFD9     NOP
057A  C08E     MOVFF 0x8E, FSR2H
057C  FFDA     NOP
057E  CFDE     MOVFF POSTINC2, ll
0580  F099     NOP
0582  CFDD     MOVFF POSTDEC2, 0x9A
0584  F09A     NOP
0586  0100     MOVLB 0x0
0588  0E00     MOVLW 0x0
058A  BF9A     BTFSC 0x9A, 7, BANKED
058C  0EFF     MOVLW 0xFF
058E  6F9B     MOVWF 0x9B, BANKED
0590  6F9C     MOVWF 0x9C, BANKED
0592  6F9D     MOVWF 0x9D, BANKED
0594  6F9E     MOVWF 0x9E, BANKED
0596  6F9F     MOVWF 0x9F, BANKED
0598  6FA0     MOVWF 0xA0, BANKED
829:                                   
830:                       return dtoa(fp, ll);
059A  C087     MOVFF fp, __pcstackBANK0
059C  F060     NOP
059E  C088     MOVFF bexp, 0x61
05A0  F061     NOP
05A2  C099     MOVFF ll, d
05A4  F062     NOP
05A6  C09A     MOVFF 0x9A, 0x63
05A8  F063     NOP
05AA  C09B     MOVFF 0x9B, sign
05AC  F064     NOP
05AE  C09C     MOVFF 0x9C, aexp
05B0  F065     NOP
05B2  C09D     MOVFF 0x9D, grs
05B4  F066     NOP
05B6  C09E     MOVFF 0x9E, 0x67
05B8  F067     NOP
05BA  C09F     MOVFF 0x9F, 0x68
05BC  F068     NOP
05BE  C0A0     MOVFF 0xA0, 0x69
05C0  F069     NOP
05C2  ECCE     CALL 0x419C, 0
05C4  F020     NOP
05C6  C060     MOVFF __pcstackBANK0, fp
05C8  F087     NOP
05CA  C061     MOVFF 0x61, bexp
05CC  F088     NOP
05CE  0012     RETURN 0
831:                   }
832:           
833:           #ifdef _VFPF_L
834:                   /* Long decimal integer */
835:                   if (!strncmp(*fmt, "ld", CSTRLEN("ld")) || \
836:                       !strncmp(*fmt, "li", CSTRLEN("li"))) {
837:           
838:                       *fmt += CSTRLEN("ld");
839:                       ll = (long long)va_arg(ap, long);
840:                                   
841:                       return dtoa(fp, ll);
842:                   }
843:           #endif
844:           
845:           #ifdef _VFPF_LL
846:                   /* Long long decimal integer */
847:                   if (!strncmp(*fmt, "lld", CSTRLEN("lld")) || \
848:                       !strncmp(*fmt, "lli", CSTRLEN("lli"))) {
849:           
850:                       *fmt += CSTRLEN("lld");
851:                       ll = va_arg(ap, long long);
852:                                   
853:                       return dtoa(fp, ll);
854:                   }
855:           #endif
856:           
857:           #ifdef _VFPF_J
858:                   /* intmax_t decimal integer */
859:                   if (!strncmp(*fmt, "jd", CSTRLEN("jd")) || \
860:                       !strncmp(*fmt, "ji", CSTRLEN("ji"))) {
861:           
862:                       *fmt += CSTRLEN("jd");
863:                       ll = (long long)va_arg(ap, intmax_t);
864:                                   
865:                       return dtoa(fp, ll);
866:                   }
867:           #endif
868:           
869:           #ifdef _VFPF_T
870:                   /* ptrdiff_t decimal integer */
871:                   if (!strncmp(*fmt, "td", CSTRLEN("td")) || \
872:                       !strncmp(*fmt, "ti", CSTRLEN("ti"))) {
873:           
874:                       *fmt += CSTRLEN("td");
875:                       ll = (long long)va_arg(ap, ptrdiff_t);
876:                                   
877:                       return dtoa(fp, ll);
878:                   }
879:           #endif
880:           
881:           #ifdef _VFPF_Z
882:                   /* size_t decimal integer */
883:                   if (!strncmp(*fmt, "zd", CSTRLEN("zd")) || \
05D0  C089     MOVFF fmt, FSR2
05D2  FFD9     NOP
05D4  C08A     MOVFF s, FSR2H
05D6  FFDA     NOP
05D8  CFDE     MOVFF POSTINC2, dividend
05DA  F015     NOP
05DC  CFDD     MOVFF POSTDEC2, Message
05DE  F016     NOP
05E0  0EEA     MOVLW 0xEA
05E2  6E17     MOVWF _r, ACCESS
05E4  0E7F     MOVLW 0x7F
05E6  6E18     MOVWF 0x18, ACCESS
05E8  0E00     MOVLW 0x0
05EA  6E1A     MOVWF s, ACCESS
05EC  0E02     MOVLW 0x2
05EE  6E19     MOVWF multiplicand, ACCESS
05F0  ECD7     CALL 0x55AE, 0
05F2  F02A     NOP
05F4  5015     MOVF dividend, W, ACCESS
05F6  1016     IORWF Message, W, ACCESS
05F8  B4D8     BTFSC STATUS, 2, ACCESS
05FA  D016     BRA 0x628
05FC  C089     MOVFF fmt, FSR2
05FE  FFD9     NOP
0600  C08A     MOVFF s, FSR2H
0602  FFDA     NOP
0604  CFDE     MOVFF POSTINC2, dividend
0606  F015     NOP
0608  CFDD     MOVFF POSTDEC2, Message
060A  F016     NOP
060C  0EED     MOVLW 0xED
060E  6E17     MOVWF _r, ACCESS
0610  0E7F     MOVLW 0x7F
0612  6E18     MOVWF 0x18, ACCESS
0614  0E00     MOVLW 0x0
0616  6E1A     MOVWF s, ACCESS
0618  0E02     MOVLW 0x2
061A  6E19     MOVWF multiplicand, ACCESS
061C  ECD7     CALL 0x55AE, 0
061E  F02A     NOP
0620  5015     MOVF dividend, W, ACCESS
0622  1016     IORWF Message, W, ACCESS
0624  A4D8     BTFSS STATUS, 2, ACCESS
0626  D042     BRA 0x6AC
884:                       !strncmp(*fmt, "zi", CSTRLEN("zi"))) {
885:           
886:                       *fmt += CSTRLEN("zd");
0628  0E02     MOVLW 0x2
062A  C089     MOVFF fmt, FSR2
062C  FFD9     NOP
062E  C08A     MOVFF s, FSR2H
0630  FFDA     NOP
0632  26DE     ADDWF POSTINC2, F, ACCESS
0634  0E00     MOVLW 0x0
0636  22DD     ADDWFC POSTDEC2, F, ACCESS
887:                       ll = (long long)va_arg(ap, size_t);
0638  C08B     MOVFF ap, FSR2
063A  FFD9     NOP
063C  C08C     MOVFF res, FSR2H
063E  FFDA     NOP
0640  CFDF     MOVFF INDF2, 0x8D
0642  F08D     NOP
0644  0E02     MOVLW 0x2
0646  26DE     ADDWF POSTINC2, F, ACCESS
0648  CFDF     MOVFF INDF2, 0x8E
064A  F08E     NOP
064C  0E00     MOVLW 0x0
064E  22DD     ADDWFC POSTDEC2, F, ACCESS
0650  C08D     MOVFF 0x8D, FSR2
0652  FFD9     NOP
0654  C08E     MOVFF 0x8E, FSR2H
0656  FFDA     NOP
0658  CFDE     MOVFF POSTINC2, 0x8F
065A  F08F     NOP
065C  CFDD     MOVFF POSTDEC2, 0x90
065E  F090     NOP
0660  C08F     MOVFF 0x8F, ll
0662  F099     NOP
0664  C090     MOVFF 0x90, 0x9A
0666  F09A     NOP
0668  0100     MOVLB 0x0
066A  6B9B     CLRF 0x9B, BANKED
066C  6B9C     CLRF 0x9C, BANKED
066E  6B9D     CLRF 0x9D, BANKED
0670  6B9E     CLRF 0x9E, BANKED
0672  6B9F     CLRF 0x9F, BANKED
0674  6BA0     CLRF 0xA0, BANKED
888:                                   
889:                       return dtoa(fp, ll);
0676  C087     MOVFF fp, __pcstackBANK0
0678  F060     NOP
067A  C088     MOVFF bexp, 0x61
067C  F061     NOP
067E  C099     MOVFF ll, d
0680  F062     NOP
0682  C09A     MOVFF 0x9A, 0x63
0684  F063     NOP
0686  C09B     MOVFF 0x9B, sign
0688  F064     NOP
068A  C09C     MOVFF 0x9C, aexp
068C  F065     NOP
068E  C09D     MOVFF 0x9D, grs
0690  F066     NOP
0692  C09E     MOVFF 0x9E, 0x67
0694  F067     NOP
0696  C09F     MOVFF 0x9F, 0x68
0698  F068     NOP
069A  C0A0     MOVFF 0xA0, 0x69
069C  F069     NOP
069E  ECCE     CALL 0x419C, 0
06A0  F020     NOP
06A2  C060     MOVFF __pcstackBANK0, fp
06A4  F087     NOP
06A6  C061     MOVFF 0x61, bexp
06A8  F088     NOP
06AA  0012     RETURN 0
890:                   }
891:           #endif
892:           #endif
893:           
894:           #ifdef _VFPF_E
895:                   /* 'e' style floating point */
896:                   if (ct[0] == 'e') {
897:           
898:                       c = (*fmt)[0];
899:                       ++*fmt;
900:                       f = (long double)va_arg(ap, double);
901:                                   
902:                       return efgtoa(fp, f, c);
903:                   }
904:                   if (!strncmp(ct, "le", CSTRLEN("le"))) {
905:           
906:                       c = (*fmt)[1];
907:                       if (isupper((int)(*fmt)[0])) {
908:                           f = va_arg(ap, long double);
909:                       } else {
910:                           f = (long double)va_arg(ap, double);
911:                       }
912:                       *fmt += CSTRLEN("lf");
913:                                   
914:                       return efgtoa(fp, f, c);
915:                   }
916:           #endif
917:           
918:           #ifdef _VFPF_F
919:                   /* 'f' style floating point */
920:                   if (ct[0] == 'f') {
921:           
922:                       c = (*fmt)[0];
923:                       ++*fmt;
924:                       f = (long double)va_arg(ap, double);
925:                                   
926:                       return efgtoa(fp, f, c);
927:                   }
928:                   if (!strncmp(ct, "lf", CSTRLEN("lf"))) {
929:           
930:                       c = (*fmt)[1];
931:                       if (isupper((int)(*fmt)[0])) {
932:                           f = va_arg(ap, long double);
933:                       } else {
934:                           f = (long double)va_arg(ap, double);
935:                       }
936:                       *fmt += CSTRLEN("lf");
937:                                   
938:                       return efgtoa(fp, f, c);
939:                   }
940:           #endif
941:           
942:           #ifdef _VFPF_G
943:                   /* 'g' style floating point */
944:                   if (ct[0] == 'g') {
945:           
946:                       c = (*fmt)[0];
947:                       ++*fmt;
948:                       f = (long double)va_arg(ap, double);
949:                                   
950:                       return efgtoa(fp, f, c);
951:                   }
952:                   if (!strncmp(ct, "lg", CSTRLEN("lg"))) {
953:           
954:                       c = (*fmt)[1];
955:                       if (isupper((int)(*fmt)[0])) {
956:                           f = va_arg(ap, long double);
957:                       } else {
958:                           f = (long double)va_arg(ap, double);
959:                       }
960:                       *fmt += CSTRLEN("lg");
961:                                   
962:                       return efgtoa(fp, f, c);
963:                   }
964:           #endif
965:           
966:           #ifdef _VFPF_O
967:           #ifdef _VFPF_HH
968:                   /* Character octal integer */
969:                   if (!strncmp(*fmt, "hho", CSTRLEN("hho"))) {
06AC  C089     MOVFF fmt, FSR2
06AE  FFD9     NOP
06B0  C08A     MOVFF s, FSR2H
06B2  FFDA     NOP
06B4  CFDE     MOVFF POSTINC2, dividend
06B6  F015     NOP
06B8  CFDD     MOVFF POSTDEC2, Message
06BA  F016     NOP
06BC  0ED7     MOVLW 0xD7
06BE  6E17     MOVWF _r, ACCESS
06C0  0E7F     MOVLW 0x7F
06C2  6E18     MOVWF 0x18, ACCESS
06C4  0E00     MOVLW 0x0
06C6  6E1A     MOVWF s, ACCESS
06C8  0E03     MOVLW 0x3
06CA  6E19     MOVWF multiplicand, ACCESS
06CC  ECD7     CALL 0x55AE, 0
06CE  F02A     NOP
06D0  5015     MOVF dividend, W, ACCESS
06D2  1016     IORWF Message, W, ACCESS
06D4  A4D8     BTFSS STATUS, 2, ACCESS
06D6  D03F     BRA 0x756
970:           
971:                       *fmt += CSTRLEN("hho");
06D8  0E03     MOVLW 0x3
06DA  C089     MOVFF fmt, FSR2
06DC  FFD9     NOP
06DE  C08A     MOVFF s, FSR2H
06E0  FFDA     NOP
06E2  26DE     ADDWF POSTINC2, F, ACCESS
06E4  0E00     MOVLW 0x0
06E6  22DD     ADDWFC POSTDEC2, F, ACCESS
972:                       llu = (unsigned long long)(unsigned char)va_arg(ap, int);
06E8  C08B     MOVFF ap, FSR2
06EA  FFD9     NOP
06EC  C08C     MOVFF res, FSR2H
06EE  FFDA     NOP
06F0  CFDF     MOVFF INDF2, 0x8D
06F2  F08D     NOP
06F4  0E02     MOVLW 0x2
06F6  26DE     ADDWF POSTINC2, F, ACCESS
06F8  CFDF     MOVFF INDF2, 0x8E
06FA  F08E     NOP
06FC  0E00     MOVLW 0x0
06FE  22DD     ADDWFC POSTDEC2, F, ACCESS
0700  C08D     MOVFF 0x8D, FSR2
0702  FFD9     NOP
0704  C08E     MOVFF 0x8E, FSR2H
0706  FFDA     NOP
0708  50DF     MOVF INDF2, W, ACCESS
070A  0100     MOVLB 0x0
070C  6F8F     MOVWF 0x8F, BANKED
070E  518F     MOVF 0x8F, W, BANKED
0710  6FA4     MOVWF llu, BANKED
0712  6BA5     CLRF digit, BANKED
0714  6BA6     CLRF flags, BANKED
0716  6BA7     CLRF expon, BANKED
0718  6BA8     CLRF 0xA8, BANKED
071A  6BA9     CLRF eexp, BANKED
071C  6BAA     CLRF 0xAA, BANKED
071E  6BAB     CLRF _u, BANKED
973:                                   
974:                       return otoa(fp, llu);
0720  C087     MOVFF fp, __pcstackBANK0
0722  F060     NOP
0724  C088     MOVFF bexp, 0x61
0726  F061     NOP
0728  C0A4     MOVFF llu, d
072A  F062     NOP
072C  C0A5     MOVFF digit, 0x63
072E  F063     NOP
0730  C0A6     MOVFF flags, sign
0732  F064     NOP
0734  C0A7     MOVFF expon, aexp
0736  F065     NOP
0738  C0A8     MOVFF 0xA8, grs
073A  F066     NOP
073C  C0A9     MOVFF eexp, 0x67
073E  F067     NOP
0740  C0AA     MOVFF 0xAA, 0x68
0742  F068     NOP
0744  C0AB     MOVFF _u, 0x69
0746  F069     NOP
0748  ECC9     CALL 0x4992, 0
074A  F024     NOP
074C  C060     MOVFF __pcstackBANK0, fp
074E  F087     NOP
0750  C061     MOVFF 0x61, bexp
0752  F088     NOP
0754  0012     RETURN 0
975:                   }
976:           #endif
977:           
978:           #ifdef _VFPF_H
979:                   /* Short octal integer */
980:                   if (!strncmp(*fmt, "ho", CSTRLEN("ho"))) {
0756  C089     MOVFF fmt, FSR2
0758  FFD9     NOP
075A  C08A     MOVFF s, FSR2H
075C  FFDA     NOP
075E  CFDE     MOVFF POSTINC2, dividend
0760  F015     NOP
0762  CFDD     MOVFF POSTDEC2, Message
0764  F016     NOP
0766  0ED8     MOVLW 0xD8
0768  6E17     MOVWF _r, ACCESS
076A  0E7F     MOVLW 0x7F
076C  6E18     MOVWF 0x18, ACCESS
076E  0E00     MOVLW 0x0
0770  6E1A     MOVWF s, ACCESS
0772  0E02     MOVLW 0x2
0774  6E19     MOVWF multiplicand, ACCESS
0776  ECD7     CALL 0x55AE, 0
0778  F02A     NOP
077A  5015     MOVF dividend, W, ACCESS
077C  1016     IORWF Message, W, ACCESS
077E  A4D8     BTFSS STATUS, 2, ACCESS
0780  D042     BRA 0x806
981:           
982:                       *fmt += CSTRLEN("ho");
0782  0E02     MOVLW 0x2
0784  C089     MOVFF fmt, FSR2
0786  FFD9     NOP
0788  C08A     MOVFF s, FSR2H
078A  FFDA     NOP
078C  26DE     ADDWF POSTINC2, F, ACCESS
078E  0E00     MOVLW 0x0
0790  22DD     ADDWFC POSTDEC2, F, ACCESS
983:                       llu = (unsigned long long)(unsigned short)va_arg(ap, int);
0792  C08B     MOVFF ap, FSR2
0794  FFD9     NOP
0796  C08C     MOVFF res, FSR2H
0798  FFDA     NOP
079A  CFDF     MOVFF INDF2, 0x8D
079C  F08D     NOP
079E  0E02     MOVLW 0x2
07A0  26DE     ADDWF POSTINC2, F, ACCESS
07A2  CFDF     MOVFF INDF2, 0x8E
07A4  F08E     NOP
07A6  0E00     MOVLW 0x0
07A8  22DD     ADDWFC POSTDEC2, F, ACCESS
07AA  C08D     MOVFF 0x8D, FSR2
07AC  FFD9     NOP
07AE  C08E     MOVFF 0x8E, FSR2H
07B0  FFDA     NOP
07B2  CFDE     MOVFF POSTINC2, 0x8F
07B4  F08F     NOP
07B6  CFDD     MOVFF POSTDEC2, 0x90
07B8  F090     NOP
07BA  C08F     MOVFF 0x8F, llu
07BC  F0A4     NOP
07BE  C090     MOVFF 0x90, digit
07C0  F0A5     NOP
07C2  0100     MOVLB 0x0
07C4  6BA6     CLRF flags, BANKED
07C6  6BA7     CLRF expon, BANKED
07C8  6BA8     CLRF 0xA8, BANKED
07CA  6BA9     CLRF eexp, BANKED
07CC  6BAA     CLRF 0xAA, BANKED
07CE  6BAB     CLRF _u, BANKED
984:                                   
985:                       return otoa(fp, llu);
07D0  C087     MOVFF fp, __pcstackBANK0
07D2  F060     NOP
07D4  C088     MOVFF bexp, 0x61
07D6  F061     NOP
07D8  C0A4     MOVFF llu, d
07DA  F062     NOP
07DC  C0A5     MOVFF digit, 0x63
07DE  F063     NOP
07E0  C0A6     MOVFF flags, sign
07E2  F064     NOP
07E4  C0A7     MOVFF expon, aexp
07E6  F065     NOP
07E8  C0A8     MOVFF 0xA8, grs
07EA  F066     NOP
07EC  C0A9     MOVFF eexp, 0x67
07EE  F067     NOP
07F0  C0AA     MOVFF 0xAA, 0x68
07F2  F068     NOP
07F4  C0AB     MOVFF _u, 0x69
07F6  F069     NOP
07F8  ECC9     CALL 0x4992, 0
07FA  F024     NOP
07FC  C060     MOVFF __pcstackBANK0, fp
07FE  F087     NOP
0800  C061     MOVFF 0x61, bexp
0802  F088     NOP
0804  0012     RETURN 0
986:                   }
987:           #endif
988:           
989:                   /* Octal integer */
990:                   if (*fmt[0] == 'o') {
0806  C089     MOVFF fmt, FSR2
0808  FFD9     NOP
080A  C08A     MOVFF s, FSR2H
080C  FFDA     NOP
080E  CFDE     MOVFF POSTINC2, TBLPTR
0810  FFF6     NOP
0812  CFDD     MOVFF POSTDEC2, TBLPTRH
0814  FFF7     NOP
0816  0008     TBLRD*
0818  50F5     MOVF TABLAT, W, ACCESS
081A  0A6F     XORLW 0x6F
081C  A4D8     BTFSS STATUS, 2, ACCESS
081E  D041     BRA 0x8A2
991:           
992:                       ++*fmt;
0820  C089     MOVFF fmt, FSR2
0822  FFD9     NOP
0824  C08A     MOVFF s, FSR2H
0826  FFDA     NOP
0828  2ADE     INCF POSTINC2, F, ACCESS
082A  0E00     MOVLW 0x0
082C  22DD     ADDWFC POSTDEC2, F, ACCESS
993:                       llu = (unsigned long long)va_arg(ap, unsigned int);
082E  C08B     MOVFF ap, FSR2
0830  FFD9     NOP
0832  C08C     MOVFF res, FSR2H
0834  FFDA     NOP
0836  CFDF     MOVFF INDF2, 0x8D
0838  F08D     NOP
083A  0E02     MOVLW 0x2
083C  26DE     ADDWF POSTINC2, F, ACCESS
083E  CFDF     MOVFF INDF2, 0x8E
0840  F08E     NOP
0842  0E00     MOVLW 0x0
0844  22DD     ADDWFC POSTDEC2, F, ACCESS
0846  C08D     MOVFF 0x8D, FSR2
0848  FFD9     NOP
084A  C08E     MOVFF 0x8E, FSR2H
084C  FFDA     NOP
084E  CFDE     MOVFF POSTINC2, 0x8F
0850  F08F     NOP
0852  CFDD     MOVFF POSTDEC2, 0x90
0854  F090     NOP
0856  C08F     MOVFF 0x8F, llu
0858  F0A4     NOP
085A  C090     MOVFF 0x90, digit
085C  F0A5     NOP
085E  0100     MOVLB 0x0
0860  6BA6     CLRF flags, BANKED
0862  6BA7     CLRF expon, BANKED
0864  6BA8     CLRF 0xA8, BANKED
0866  6BA9     CLRF eexp, BANKED
0868  6BAA     CLRF 0xAA, BANKED
086A  6BAB     CLRF _u, BANKED
994:                                   
995:                       return otoa(fp, llu);
086C  C087     MOVFF fp, __pcstackBANK0
086E  F060     NOP
0870  C088     MOVFF bexp, 0x61
0872  F061     NOP
0874  C0A4     MOVFF llu, d
0876  F062     NOP
0878  C0A5     MOVFF digit, 0x63
087A  F063     NOP
087C  C0A6     MOVFF flags, sign
087E  F064     NOP
0880  C0A7     MOVFF expon, aexp
0882  F065     NOP
0884  C0A8     MOVFF 0xA8, grs
0886  F066     NOP
0888  C0A9     MOVFF eexp, 0x67
088A  F067     NOP
088C  C0AA     MOVFF 0xAA, 0x68
088E  F068     NOP
0890  C0AB     MOVFF _u, 0x69
0892  F069     NOP
0894  ECC9     CALL 0x4992, 0
0896  F024     NOP
0898  C060     MOVFF __pcstackBANK0, fp
089A  F087     NOP
089C  C061     MOVFF 0x61, bexp
089E  F088     NOP
08A0  0012     RETURN 0
996:                   }
997:           
998:           #ifdef _VFPF_L
999:                   /* Long octal integer */
1000:                  if (!strncmp(*fmt, "lo", CSTRLEN("lo"))) {
1001:          
1002:                      *fmt += CSTRLEN("lo");
1003:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1004:                                  
1005:                      return otoa(fp, llu);
1006:                  }
1007:          #endif
1008:          
1009:          #ifdef _VFPF_LL
1010:                  /* Long long octal integer */
1011:                  if (!strncmp(*fmt, "llo", CSTRLEN("llo"))) {
1012:          
1013:                      *fmt += CSTRLEN("llo");
1014:                      llu = va_arg(ap, unsigned long long);
1015:                                  
1016:                      return otoa(fp, llu);
1017:                  }
1018:          #endif
1019:          
1020:          #ifdef _VFPF_J
1021:                  /* uintmax_t octal integer */
1022:                  if (!strncmp(*fmt, "jo", CSTRLEN("jo"))) {
1023:          
1024:                      *fmt += CSTRLEN("jo");
1025:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1026:                                  
1027:                      return otoa(fp, llu);
1028:                  }
1029:          #endif
1030:          
1031:          #ifdef _VFPF_T
1032:                  /* ptrdiff_t octal integer */
1033:                  if (!strncmp(*fmt, "to", CSTRLEN("to"))) {
1034:          
1035:                      *fmt += CSTRLEN("to");
1036:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1037:                                  
1038:                      return otoa(fp, llu);
1039:                  }
1040:          #endif
1041:          
1042:          #ifdef _VFPF_Z
1043:                  /* size_t octal integer */
1044:                  if (!strncmp(*fmt, "zo", CSTRLEN("zo"))) {
08A2  C089     MOVFF fmt, FSR2
08A4  FFD9     NOP
08A6  C08A     MOVFF s, FSR2H
08A8  FFDA     NOP
08AA  CFDE     MOVFF POSTINC2, dividend
08AC  F015     NOP
08AE  CFDD     MOVFF POSTDEC2, Message
08B0  F016     NOP
08B2  0EF3     MOVLW 0xF3
08B4  6E17     MOVWF _r, ACCESS
08B6  0E7F     MOVLW 0x7F
08B8  6E18     MOVWF 0x18, ACCESS
08BA  0E00     MOVLW 0x0
08BC  6E1A     MOVWF s, ACCESS
08BE  0E02     MOVLW 0x2
08C0  6E19     MOVWF multiplicand, ACCESS
08C2  ECD7     CALL 0x55AE, 0
08C4  F02A     NOP
08C6  5015     MOVF dividend, W, ACCESS
08C8  1016     IORWF Message, W, ACCESS
08CA  A4D8     BTFSS STATUS, 2, ACCESS
08CC  D042     BRA 0x952
1045:          
1046:                      *fmt += CSTRLEN("zo");
08CE  0E02     MOVLW 0x2
08D0  C089     MOVFF fmt, FSR2
08D2  FFD9     NOP
08D4  C08A     MOVFF s, FSR2H
08D6  FFDA     NOP
08D8  26DE     ADDWF POSTINC2, F, ACCESS
08DA  0E00     MOVLW 0x0
08DC  22DD     ADDWFC POSTDEC2, F, ACCESS
1047:                      llu = (unsigned long long)va_arg(ap, size_t);
08DE  C08B     MOVFF ap, FSR2
08E0  FFD9     NOP
08E2  C08C     MOVFF res, FSR2H
08E4  FFDA     NOP
08E6  CFDF     MOVFF INDF2, 0x8D
08E8  F08D     NOP
08EA  0E02     MOVLW 0x2
08EC  26DE     ADDWF POSTINC2, F, ACCESS
08EE  CFDF     MOVFF INDF2, 0x8E
08F0  F08E     NOP
08F2  0E00     MOVLW 0x0
08F4  22DD     ADDWFC POSTDEC2, F, ACCESS
08F6  C08D     MOVFF 0x8D, FSR2
08F8  FFD9     NOP
08FA  C08E     MOVFF 0x8E, FSR2H
08FC  FFDA     NOP
08FE  CFDE     MOVFF POSTINC2, 0x8F
0900  F08F     NOP
0902  CFDD     MOVFF POSTDEC2, 0x90
0904  F090     NOP
0906  C08F     MOVFF 0x8F, llu
0908  F0A4     NOP
090A  C090     MOVFF 0x90, digit
090C  F0A5     NOP
090E  0100     MOVLB 0x0
0910  6BA6     CLRF flags, BANKED
0912  6BA7     CLRF expon, BANKED
0914  6BA8     CLRF 0xA8, BANKED
0916  6BA9     CLRF eexp, BANKED
0918  6BAA     CLRF 0xAA, BANKED
091A  6BAB     CLRF _u, BANKED
1048:                                  
1049:                      return otoa(fp, llu);
091C  C087     MOVFF fp, __pcstackBANK0
091E  F060     NOP
0920  C088     MOVFF bexp, 0x61
0922  F061     NOP
0924  C0A4     MOVFF llu, d
0926  F062     NOP
0928  C0A5     MOVFF digit, 0x63
092A  F063     NOP
092C  C0A6     MOVFF flags, sign
092E  F064     NOP
0930  C0A7     MOVFF expon, aexp
0932  F065     NOP
0934  C0A8     MOVFF 0xA8, grs
0936  F066     NOP
0938  C0A9     MOVFF eexp, 0x67
093A  F067     NOP
093C  C0AA     MOVFF 0xAA, 0x68
093E  F068     NOP
0940  C0AB     MOVFF _u, 0x69
0942  F069     NOP
0944  ECC9     CALL 0x4992, 0
0946  F024     NOP
0948  C060     MOVFF __pcstackBANK0, fp
094A  F087     NOP
094C  C061     MOVFF 0x61, bexp
094E  F088     NOP
0950  0012     RETURN 0
1050:                  }
1051:          #endif
1052:          #endif
1053:          
1054:                  /* Character count */
1055:          #ifdef _VFPF_N
1056:          
1057:          #ifdef _VFPF_HH
1058:                  if (!strncmp(*fmt, "hhn", CSTRLEN("hhn"))) {
0952  C089     MOVFF fmt, FSR2
0954  FFD9     NOP
0956  C08A     MOVFF s, FSR2H
0958  FFDA     NOP
095A  CFDE     MOVFF POSTINC2, dividend
095C  F015     NOP
095E  CFDD     MOVFF POSTDEC2, Message
0960  F016     NOP
0962  0ED3     MOVLW 0xD3
0964  6E17     MOVWF _r, ACCESS
0966  0E7F     MOVLW 0x7F
0968  6E18     MOVWF 0x18, ACCESS
096A  0E00     MOVLW 0x0
096C  6E1A     MOVWF s, ACCESS
096E  0E03     MOVLW 0x3
0970  6E19     MOVWF multiplicand, ACCESS
0972  ECD7     CALL 0x55AE, 0
0974  F02A     NOP
0976  5015     MOVF dividend, W, ACCESS
0978  1016     IORWF Message, W, ACCESS
097A  A4D8     BTFSS STATUS, 2, ACCESS
097C  D034     BRA 0x9E6
1059:          
1060:                      *fmt += CSTRLEN("hhn");
097E  0E03     MOVLW 0x3
0980  C089     MOVFF fmt, FSR2
0982  FFD9     NOP
0984  C08A     MOVFF s, FSR2H
0986  FFDA     NOP
0988  26DE     ADDWF POSTINC2, F, ACCESS
098A  0E00     MOVLW 0x0
098C  22DD     ADDWFC POSTDEC2, F, ACCESS
1061:                      vp = (void *)va_arg(ap, char *);
098E  C08B     MOVFF ap, FSR2
0990  FFD9     NOP
0992  C08C     MOVFF res, FSR2H
0994  FFDA     NOP
0996  CFDF     MOVFF INDF2, 0x8D
0998  F08D     NOP
099A  0E02     MOVLW 0x2
099C  26DE     ADDWF POSTINC2, F, ACCESS
099E  CFDF     MOVFF INDF2, 0x8E
09A0  F08E     NOP
09A2  0E00     MOVLW 0x0
09A4  22DD     ADDWFC POSTDEC2, F, ACCESS
09A6  C08D     MOVFF 0x8D, FSR2
09A8  FFD9     NOP
09AA  C08E     MOVFF 0x8E, FSR2H
09AC  FFDA     NOP
09AE  CFDE     MOVFF POSTINC2, vp
09B0  F0A1     NOP
09B2  CFDD     MOVFF POSTDEC2, 0xA2
09B4  F0A2     NOP
1062:                      *(char *)vp = (char)nout;
09B6  C0A1     MOVFF vp, TBLPTR
09B8  FFF6     NOP
09BA  C0A2     MOVFF 0xA2, TBLPTRH
09BC  FFF7     NOP
09BE  6AF8     CLRF TBLPTRU, ACCESS
09C0  0E0E     MOVLW 0xE
09C2  64F7     CPFSGT TBLPTRH, ACCESS
09C4  D004     BRA 0x9CE
09C6  C0CF     MOVFF nout, TABLAT
09C8  FFF5     NOP
09CA  000C     TBLWT*
09CC  D006     BRA 0x9DA
09CE  CFF6     MOVFF TBLPTR, FSR0
09D0  FFE9     NOP
09D2  CFF7     MOVFF TBLPTRH, FSR0H
09D4  FFEA     NOP
09D6  C0CF     MOVFF nout, INDF0
09D8  FFEF     NOP
1063:                      return 0;
09DA  0E00     MOVLW 0x0
09DC  0100     MOVLB 0x0
09DE  6F88     MOVWF bexp, BANKED
09E0  0E00     MOVLW 0x0
09E2  6F87     MOVWF fp, BANKED
09E4  0012     RETURN 0
1064:                  }
1065:          #endif
1066:          
1067:          #ifdef _VFPF_H
1068:                  if (!strncmp(*fmt, "hn", CSTRLEN("hn"))) {
09E6  C089     MOVFF fmt, FSR2
09E8  FFD9     NOP
09EA  C08A     MOVFF s, FSR2H
09EC  FFDA     NOP
09EE  CFDE     MOVFF POSTINC2, dividend
09F0  F015     NOP
09F2  CFDD     MOVFF POSTDEC2, Message
09F4  F016     NOP
09F6  0ED4     MOVLW 0xD4
09F8  6E17     MOVWF _r, ACCESS
09FA  0E7F     MOVLW 0x7F
09FC  6E18     MOVWF 0x18, ACCESS
09FE  0E00     MOVLW 0x0
0A00  6E1A     MOVWF s, ACCESS
0A02  0E02     MOVLW 0x2
0A04  6E19     MOVWF multiplicand, ACCESS
0A06  ECD7     CALL 0x55AE, 0
0A08  F02A     NOP
0A0A  5015     MOVF dividend, W, ACCESS
0A0C  1016     IORWF Message, W, ACCESS
0A0E  A4D8     BTFSS STATUS, 2, ACCESS
0A10  D039     BRA 0xA84
1069:          
1070:                      *fmt += CSTRLEN("hn");
0A12  0E02     MOVLW 0x2
0A14  C089     MOVFF fmt, FSR2
0A16  FFD9     NOP
0A18  C08A     MOVFF s, FSR2H
0A1A  FFDA     NOP
0A1C  26DE     ADDWF POSTINC2, F, ACCESS
0A1E  0E00     MOVLW 0x0
0A20  22DD     ADDWFC POSTDEC2, F, ACCESS
1071:                      vp = (void *)va_arg(ap, short *);
0A22  C08B     MOVFF ap, FSR2
0A24  FFD9     NOP
0A26  C08C     MOVFF res, FSR2H
0A28  FFDA     NOP
0A2A  CFDF     MOVFF INDF2, 0x8D
0A2C  F08D     NOP
0A2E  0E02     MOVLW 0x2
0A30  26DE     ADDWF POSTINC2, F, ACCESS
0A32  CFDF     MOVFF INDF2, 0x8E
0A34  F08E     NOP
0A36  0E00     MOVLW 0x0
0A38  22DD     ADDWFC POSTDEC2, F, ACCESS
0A3A  C08D     MOVFF 0x8D, FSR2
0A3C  FFD9     NOP
0A3E  C08E     MOVFF 0x8E, FSR2H
0A40  FFDA     NOP
0A42  CFDE     MOVFF POSTINC2, vp
0A44  F0A1     NOP
0A46  CFDD     MOVFF POSTDEC2, 0xA2
0A48  F0A2     NOP
1072:                      *(short *)vp = (short)nout;
0A4A  C0A1     MOVFF vp, TBLPTR
0A4C  FFF6     NOP
0A4E  C0A2     MOVFF 0xA2, TBLPTRH
0A50  FFF7     NOP
0A52  6AF8     CLRF TBLPTRU, ACCESS
0A54  0E0E     MOVLW 0xE
0A56  64F7     CPFSGT TBLPTRH, ACCESS
0A58  D007     BRA 0xA68
0A5A  C0CF     MOVFF nout, TABLAT
0A5C  FFF5     NOP
0A5E  000D     TBLWT*+
0A60  C0D0     MOVFF 0xD0, TABLAT
0A62  FFF5     NOP
0A64  000C     TBLWT*
0A66  D008     BRA 0xA78
0A68  CFF6     MOVFF TBLPTR, FSR0
0A6A  FFE9     NOP
0A6C  CFF7     MOVFF TBLPTRH, FSR0H
0A6E  FFEA     NOP
0A70  C0CF     MOVFF nout, POSTINC0
0A72  FFEE     NOP
0A74  C0D0     MOVFF 0xD0, INDF0
0A76  FFEF     NOP
1073:                      return 0;
0A78  0E00     MOVLW 0x0
0A7A  0100     MOVLB 0x0
0A7C  6F88     MOVWF bexp, BANKED
0A7E  0E00     MOVLW 0x0
0A80  6F87     MOVWF fp, BANKED
0A82  0012     RETURN 0
1074:                  }
1075:          #endif
1076:          
1077:                  if (*fmt[0] == 'n') {
0A84  C089     MOVFF fmt, FSR2
0A86  FFD9     NOP
0A88  C08A     MOVFF s, FSR2H
0A8A  FFDA     NOP
0A8C  CFDE     MOVFF POSTINC2, TBLPTR
0A8E  FFF6     NOP
0A90  CFDD     MOVFF POSTDEC2, TBLPTRH
0A92  FFF7     NOP
0A94  0008     TBLRD*
0A96  50F5     MOVF TABLAT, W, ACCESS
0A98  0A6E     XORLW 0x6E
0A9A  A4D8     BTFSS STATUS, 2, ACCESS
0A9C  D038     BRA 0xB0E
1078:                      ++*fmt;
0A9E  C089     MOVFF fmt, FSR2
0AA0  FFD9     NOP
0AA2  C08A     MOVFF s, FSR2H
0AA4  FFDA     NOP
0AA6  2ADE     INCF POSTINC2, F, ACCESS
0AA8  0E00     MOVLW 0x0
0AAA  22DD     ADDWFC POSTDEC2, F, ACCESS
1079:                      vp = (void *)va_arg(ap, int *);
0AAC  C08B     MOVFF ap, FSR2
0AAE  FFD9     NOP
0AB0  C08C     MOVFF res, FSR2H
0AB2  FFDA     NOP
0AB4  CFDF     MOVFF INDF2, 0x8D
0AB6  F08D     NOP
0AB8  0E02     MOVLW 0x2
0ABA  26DE     ADDWF POSTINC2, F, ACCESS
0ABC  CFDF     MOVFF INDF2, 0x8E
0ABE  F08E     NOP
0AC0  0E00     MOVLW 0x0
0AC2  22DD     ADDWFC POSTDEC2, F, ACCESS
0AC4  C08D     MOVFF 0x8D, FSR2
0AC6  FFD9     NOP
0AC8  C08E     MOVFF 0x8E, FSR2H
0ACA  FFDA     NOP
0ACC  CFDE     MOVFF POSTINC2, vp
0ACE  F0A1     NOP
0AD0  CFDD     MOVFF POSTDEC2, 0xA2
0AD2  F0A2     NOP
1080:                      *(int *)vp = nout;
0AD4  C0A1     MOVFF vp, TBLPTR
0AD6  FFF6     NOP
0AD8  C0A2     MOVFF 0xA2, TBLPTRH
0ADA  FFF7     NOP
0ADC  6AF8     CLRF TBLPTRU, ACCESS
0ADE  0E0E     MOVLW 0xE
0AE0  64F7     CPFSGT TBLPTRH, ACCESS
0AE2  D007     BRA 0xAF2
0AE4  C0CF     MOVFF nout, TABLAT
0AE6  FFF5     NOP
0AE8  000D     TBLWT*+
0AEA  C0D0     MOVFF 0xD0, TABLAT
0AEC  FFF5     NOP
0AEE  000C     TBLWT*
0AF0  D008     BRA 0xB02
0AF2  CFF6     MOVFF TBLPTR, FSR0
0AF4  FFE9     NOP
0AF6  CFF7     MOVFF TBLPTRH, FSR0H
0AF8  FFEA     NOP
0AFA  C0CF     MOVFF nout, POSTINC0
0AFC  FFEE     NOP
0AFE  C0D0     MOVFF 0xD0, INDF0
0B00  FFEF     NOP
1081:                      return 0;
0B02  0E00     MOVLW 0x0
0B04  0100     MOVLB 0x0
0B06  6F88     MOVWF bexp, BANKED
0B08  0E00     MOVLW 0x0
0B0A  6F87     MOVWF fp, BANKED
0B0C  0012     RETURN 0
1082:                  }
1083:          
1084:          #ifdef _VFPF_L
1085:                  if (!strncmp(*fmt, "ln", CSTRLEN("ln"))) {
1086:          
1087:                      *fmt += CSTRLEN("ln");
1088:                      vp = (void *)va_arg(ap, long *);
1089:                      *(long *)vp = (long)nout;
1090:                      return 0;
1091:                  }
1092:          #endif
1093:          
1094:          #ifdef _VFPF_LL
1095:                  if (!strncmp(*fmt, "lln", CSTRLEN("lln"))) {
1096:          
1097:                      *fmt += CSTRLEN("lln");
1098:                      vp = (void *)va_arg(ap, long long *);
1099:                      *(long long *)vp = (long long)nout;
1100:                      return 0;
1101:                  }
1102:          #endif
1103:          
1104:          #ifdef _VFPF_J
1105:                  if (!strncmp(*fmt, "jn", CSTRLEN("jn"))) {
1106:          
1107:                      *fmt += CSTRLEN("jn");
1108:                      vp = (void *)va_arg(ap, uintmax_t *);
1109:                      *(uintmax_t *)vp = (uintmax_t)nout;
1110:                      return 0;
1111:                  }
1112:          #endif
1113:          
1114:          #ifdef _VFPF_T
1115:                  if (!strncmp(*fmt, "tn", CSTRLEN("tn"))) {
1116:          
1117:                      *fmt += CSTRLEN("tn");
1118:                      vp = (void *)va_arg(ap, ptrdiff_t *);
1119:                      *(ptrdiff_t *)vp = (ptrdiff_t)nout;
1120:                      return 0;
1121:                  }
1122:          #endif
1123:          
1124:          #ifdef _VFPF_Z
1125:                  if (!strncmp(*fmt, "zn", CSTRLEN("zn"))) {
0B0E  C089     MOVFF fmt, FSR2
0B10  FFD9     NOP
0B12  C08A     MOVFF s, FSR2H
0B14  FFDA     NOP
0B16  CFDE     MOVFF POSTINC2, dividend
0B18  F015     NOP
0B1A  CFDD     MOVFF POSTDEC2, Message
0B1C  F016     NOP
0B1E  0EF0     MOVLW 0xF0
0B20  6E17     MOVWF _r, ACCESS
0B22  0E7F     MOVLW 0x7F
0B24  6E18     MOVWF 0x18, ACCESS
0B26  0E00     MOVLW 0x0
0B28  6E1A     MOVWF s, ACCESS
0B2A  0E02     MOVLW 0x2
0B2C  6E19     MOVWF multiplicand, ACCESS
0B2E  ECD7     CALL 0x55AE, 0
0B30  F02A     NOP
0B32  5015     MOVF dividend, W, ACCESS
0B34  1016     IORWF Message, W, ACCESS
0B36  A4D8     BTFSS STATUS, 2, ACCESS
0B38  D039     BRA 0xBAC
1126:          
1127:                      *fmt += CSTRLEN("zn");
0B3A  0E02     MOVLW 0x2
0B3C  C089     MOVFF fmt, FSR2
0B3E  FFD9     NOP
0B40  C08A     MOVFF s, FSR2H
0B42  FFDA     NOP
0B44  26DE     ADDWF POSTINC2, F, ACCESS
0B46  0E00     MOVLW 0x0
0B48  22DD     ADDWFC POSTDEC2, F, ACCESS
1128:                      vp = (void *)va_arg(ap, size_t *);
0B4A  C08B     MOVFF ap, FSR2
0B4C  FFD9     NOP
0B4E  C08C     MOVFF res, FSR2H
0B50  FFDA     NOP
0B52  CFDF     MOVFF INDF2, 0x8D
0B54  F08D     NOP
0B56  0E02     MOVLW 0x2
0B58  26DE     ADDWF POSTINC2, F, ACCESS
0B5A  CFDF     MOVFF INDF2, 0x8E
0B5C  F08E     NOP
0B5E  0E00     MOVLW 0x0
0B60  22DD     ADDWFC POSTDEC2, F, ACCESS
0B62  C08D     MOVFF 0x8D, FSR2
0B64  FFD9     NOP
0B66  C08E     MOVFF 0x8E, FSR2H
0B68  FFDA     NOP
0B6A  CFDE     MOVFF POSTINC2, vp
0B6C  F0A1     NOP
0B6E  CFDD     MOVFF POSTDEC2, 0xA2
0B70  F0A2     NOP
1129:                      *(size_t *)vp = (size_t)nout;
0B72  C0A1     MOVFF vp, TBLPTR
0B74  FFF6     NOP
0B76  C0A2     MOVFF 0xA2, TBLPTRH
0B78  FFF7     NOP
0B7A  6AF8     CLRF TBLPTRU, ACCESS
0B7C  0E0E     MOVLW 0xE
0B7E  64F7     CPFSGT TBLPTRH, ACCESS
0B80  D007     BRA 0xB90
0B82  C0CF     MOVFF nout, TABLAT
0B84  FFF5     NOP
0B86  000D     TBLWT*+
0B88  C0D0     MOVFF 0xD0, TABLAT
0B8A  FFF5     NOP
0B8C  000C     TBLWT*
0B8E  D008     BRA 0xBA0
0B90  CFF6     MOVFF TBLPTR, FSR0
0B92  FFE9     NOP
0B94  CFF7     MOVFF TBLPTRH, FSR0H
0B96  FFEA     NOP
0B98  C0CF     MOVFF nout, POSTINC0
0B9A  FFEE     NOP
0B9C  C0D0     MOVFF 0xD0, INDF0
0B9E  FFEF     NOP
1130:                      return 0;
0BA0  0E00     MOVLW 0x0
0BA2  0100     MOVLB 0x0
0BA4  6F88     MOVWF bexp, BANKED
0BA6  0E00     MOVLW 0x0
0BA8  6F87     MOVWF fp, BANKED
0BAA  0012     RETURN 0
1131:                  }
1132:          #endif
1133:          
1134:          #endif
1135:          
1136:          #ifdef _VFPF_P
1137:                  /* Pointer */
1138:                  if (*fmt[0] == 'p') {
0BAC  C089     MOVFF fmt, FSR2
0BAE  FFD9     NOP
0BB0  C08A     MOVFF s, FSR2H
0BB2  FFDA     NOP
0BB4  CFDE     MOVFF POSTINC2, TBLPTR
0BB6  FFF6     NOP
0BB8  CFDD     MOVFF POSTDEC2, TBLPTRH
0BBA  FFF7     NOP
0BBC  0008     TBLRD*
0BBE  50F5     MOVF TABLAT, W, ACCESS
0BC0  0A70     XORLW 0x70
0BC2  A4D8     BTFSS STATUS, 2, ACCESS
0BC4  D043     BRA 0xC4C
1139:          
1140:                      ++*fmt;
0BC6  C089     MOVFF fmt, FSR2
0BC8  FFD9     NOP
0BCA  C08A     MOVFF s, FSR2H
0BCC  FFDA     NOP
0BCE  2ADE     INCF POSTINC2, F, ACCESS
0BD0  0E00     MOVLW 0x0
0BD2  22DD     ADDWFC POSTDEC2, F, ACCESS
1141:                      llu = (unsigned long long)(size_t)va_arg(ap, void *);
0BD4  C08B     MOVFF ap, FSR2
0BD6  FFD9     NOP
0BD8  C08C     MOVFF res, FSR2H
0BDA  FFDA     NOP
0BDC  CFDF     MOVFF INDF2, 0x8D
0BDE  F08D     NOP
0BE0  0E02     MOVLW 0x2
0BE2  26DE     ADDWF POSTINC2, F, ACCESS
0BE4  CFDF     MOVFF INDF2, 0x8E
0BE6  F08E     NOP
0BE8  0E00     MOVLW 0x0
0BEA  22DD     ADDWFC POSTDEC2, F, ACCESS
0BEC  C08D     MOVFF 0x8D, FSR2
0BEE  FFD9     NOP
0BF0  C08E     MOVFF 0x8E, FSR2H
0BF2  FFDA     NOP
0BF4  CFDE     MOVFF POSTINC2, 0x8F
0BF6  F08F     NOP
0BF8  CFDD     MOVFF POSTDEC2, 0x90
0BFA  F090     NOP
0BFC  C08F     MOVFF 0x8F, llu
0BFE  F0A4     NOP
0C00  C090     MOVFF 0x90, digit
0C02  F0A5     NOP
0C04  0100     MOVLB 0x0
0C06  6BA6     CLRF flags, BANKED
0C08  6BA7     CLRF expon, BANKED
0C0A  6BA8     CLRF 0xA8, BANKED
0C0C  6BA9     CLRF eexp, BANKED
0C0E  6BAA     CLRF 0xAA, BANKED
0C10  6BAB     CLRF _u, BANKED
1142:                                  
1143:                      return xtoa(fp, llu, 'x');
0C12  C087     MOVFF fp, __pcstackBANK0
0C14  F060     NOP
0C16  C088     MOVFF bexp, 0x61
0C18  F061     NOP
0C1A  C0A4     MOVFF llu, d
0C1C  F062     NOP
0C1E  C0A5     MOVFF digit, 0x63
0C20  F063     NOP
0C22  C0A6     MOVFF flags, sign
0C24  F064     NOP
0C26  C0A7     MOVFF expon, aexp
0C28  F065     NOP
0C2A  C0A8     MOVFF 0xA8, grs
0C2C  F066     NOP
0C2E  C0A9     MOVFF eexp, 0x67
0C30  F067     NOP
0C32  C0AA     MOVFF 0xAA, 0x68
0C34  F068     NOP
0C36  C0AB     MOVFF _u, 0x69
0C38  F069     NOP
0C3A  0E78     MOVLW 0x78
0C3C  6F6A     MOVWF x, BANKED
0C3E  ECF7     CALL 0x43EE, 0
0C40  F021     NOP
0C42  C060     MOVFF __pcstackBANK0, fp
0C44  F087     NOP
0C46  C061     MOVFF 0x61, bexp
0C48  F088     NOP
0C4A  0012     RETURN 0
1144:                  }
1145:          #endif
1146:          
1147:          #ifdef _VFPF_S
1148:                  /* String */
1149:                  if (*fmt[0] == 's') {
0C4C  C089     MOVFF fmt, FSR2
0C4E  FFD9     NOP
0C50  C08A     MOVFF s, FSR2H
0C52  FFDA     NOP
0C54  CFDE     MOVFF POSTINC2, TBLPTR
0C56  FFF6     NOP
0C58  CFDD     MOVFF POSTDEC2, TBLPTRH
0C5A  FFF7     NOP
0C5C  0008     TBLRD*
0C5E  50F5     MOVF TABLAT, W, ACCESS
0C60  0A73     XORLW 0x73
0C62  A4D8     BTFSS STATUS, 2, ACCESS
0C64  D02A     BRA 0xCBA
1150:          
1151:                      ++*fmt;
0C66  C089     MOVFF fmt, FSR2
0C68  FFD9     NOP
0C6A  C08A     MOVFF s, FSR2H
0C6C  FFDA     NOP
0C6E  2ADE     INCF POSTINC2, F, ACCESS
0C70  0E00     MOVLW 0x0
0C72  22DD     ADDWFC POSTDEC2, F, ACCESS
1152:                      cp = va_arg(ap, char *);
0C74  C08B     MOVFF ap, FSR2
0C76  FFD9     NOP
0C78  C08C     MOVFF res, FSR2H
0C7A  FFDA     NOP
0C7C  CFDF     MOVFF INDF2, 0x8D
0C7E  F08D     NOP
0C80  0E02     MOVLW 0x2
0C82  26DE     ADDWF POSTINC2, F, ACCESS
0C84  CFDF     MOVFF INDF2, 0x8E
0C86  F08E     NOP
0C88  0E00     MOVLW 0x0
0C8A  22DD     ADDWFC POSTDEC2, F, ACCESS
0C8C  C08D     MOVFF 0x8D, FSR2
0C8E  FFD9     NOP
0C90  C08E     MOVFF 0x8E, FSR2H
0C92  FFDA     NOP
0C94  CFDE     MOVFF POSTINC2, cp
0C96  F091     NOP
0C98  CFDD     MOVFF POSTDEC2, 0x92
0C9A  F092     NOP
1153:          
1154:                      return stoa(fp, cp);
0C9C  C087     MOVFF fp, r
0C9E  F020     NOP
0CA0  C088     MOVFF bexp, s
0CA2  F021     NOP
0CA4  C091     MOVFF cp, s
0CA6  F022     NOP
0CA8  C092     MOVFF 0x92, sep
0CAA  F023     NOP
0CAC  EC7D     CALL 0x4EFA, 0
0CAE  F027     NOP
0CB0  C020     MOVFF r, fp
0CB2  F087     NOP
0CB4  C021     MOVFF s, bexp
0CB6  F088     NOP
0CB8  0012     RETURN 0
1155:                  }
1156:          #endif
1157:          
1158:          #ifdef _VFPF_U
1159:          #ifdef _VFPF_HH
1160:                  /* Unsigned character decimal integer */
1161:                  if (!strncmp(*fmt, "hhu", CSTRLEN("hhu"))) {
0CBA  C089     MOVFF fmt, FSR2
0CBC  FFD9     NOP
0CBE  C08A     MOVFF s, FSR2H
0CC0  FFDA     NOP
0CC2  CFDE     MOVFF POSTINC2, dividend
0CC4  F015     NOP
0CC6  CFDD     MOVFF POSTDEC2, Message
0CC8  F016     NOP
0CCA  0EDB     MOVLW 0xDB
0CCC  6E17     MOVWF _r, ACCESS
0CCE  0E7F     MOVLW 0x7F
0CD0  6E18     MOVWF 0x18, ACCESS
0CD2  0E00     MOVLW 0x0
0CD4  6E1A     MOVWF s, ACCESS
0CD6  0E03     MOVLW 0x3
0CD8  6E19     MOVWF multiplicand, ACCESS
0CDA  ECD7     CALL 0x55AE, 0
0CDC  F02A     NOP
0CDE  5015     MOVF dividend, W, ACCESS
0CE0  1016     IORWF Message, W, ACCESS
0CE2  A4D8     BTFSS STATUS, 2, ACCESS
0CE4  D03F     BRA 0xD64
1162:          
1163:                      *fmt += CSTRLEN("hhu");
0CE6  0E03     MOVLW 0x3
0CE8  C089     MOVFF fmt, FSR2
0CEA  FFD9     NOP
0CEC  C08A     MOVFF s, FSR2H
0CEE  FFDA     NOP
0CF0  26DE     ADDWF POSTINC2, F, ACCESS
0CF2  0E00     MOVLW 0x0
0CF4  22DD     ADDWFC POSTDEC2, F, ACCESS
1164:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
0CF6  C08B     MOVFF ap, FSR2
0CF8  FFD9     NOP
0CFA  C08C     MOVFF res, FSR2H
0CFC  FFDA     NOP
0CFE  CFDF     MOVFF INDF2, 0x8D
0D00  F08D     NOP
0D02  0E02     MOVLW 0x2
0D04  26DE     ADDWF POSTINC2, F, ACCESS
0D06  CFDF     MOVFF INDF2, 0x8E
0D08  F08E     NOP
0D0A  0E00     MOVLW 0x0
0D0C  22DD     ADDWFC POSTDEC2, F, ACCESS
0D0E  C08D     MOVFF 0x8D, FSR2
0D10  FFD9     NOP
0D12  C08E     MOVFF 0x8E, FSR2H
0D14  FFDA     NOP
0D16  50DF     MOVF INDF2, W, ACCESS
0D18  0100     MOVLB 0x0
0D1A  6F8F     MOVWF 0x8F, BANKED
0D1C  518F     MOVF 0x8F, W, BANKED
0D1E  6FA4     MOVWF llu, BANKED
0D20  6BA5     CLRF digit, BANKED
0D22  6BA6     CLRF flags, BANKED
0D24  6BA7     CLRF expon, BANKED
0D26  6BA8     CLRF 0xA8, BANKED
0D28  6BA9     CLRF eexp, BANKED
0D2A  6BAA     CLRF 0xAA, BANKED
0D2C  6BAB     CLRF _u, BANKED
1165:                                  
1166:                      return utoa(fp, llu);
0D2E  C087     MOVFF fp, __pcstackBANK0
0D30  F060     NOP
0D32  C088     MOVFF bexp, 0x61
0D34  F061     NOP
0D36  C0A4     MOVFF llu, d
0D38  F062     NOP
0D3A  C0A5     MOVFF digit, 0x63
0D3C  F063     NOP
0D3E  C0A6     MOVFF flags, sign
0D40  F064     NOP
0D42  C0A7     MOVFF expon, aexp
0D44  F065     NOP
0D46  C0A8     MOVFF 0xA8, grs
0D48  F066     NOP
0D4A  C0A9     MOVFF eexp, 0x67
0D4C  F067     NOP
0D4E  C0AA     MOVFF 0xAA, 0x68
0D50  F068     NOP
0D52  C0AB     MOVFF _u, 0x69
0D54  F069     NOP
0D56  EC18     CALL 0x4630, 0
0D58  F023     NOP
0D5A  C060     MOVFF __pcstackBANK0, fp
0D5C  F087     NOP
0D5E  C061     MOVFF 0x61, bexp
0D60  F088     NOP
0D62  0012     RETURN 0
1167:                  }
1168:          #endif
1169:          
1170:          #ifdef _VFPF_H
1171:                  /* Unsigned short decimal integer */
1172:                  if (!strncmp(*fmt, "hu", CSTRLEN("hu"))) {
0D64  C089     MOVFF fmt, FSR2
0D66  FFD9     NOP
0D68  C08A     MOVFF s, FSR2H
0D6A  FFDA     NOP
0D6C  CFDE     MOVFF POSTINC2, dividend
0D6E  F015     NOP
0D70  CFDD     MOVFF POSTDEC2, Message
0D72  F016     NOP
0D74  0EDC     MOVLW 0xDC
0D76  6E17     MOVWF _r, ACCESS
0D78  0E7F     MOVLW 0x7F
0D7A  6E18     MOVWF 0x18, ACCESS
0D7C  0E00     MOVLW 0x0
0D7E  6E1A     MOVWF s, ACCESS
0D80  0E02     MOVLW 0x2
0D82  6E19     MOVWF multiplicand, ACCESS
0D84  ECD7     CALL 0x55AE, 0
0D86  F02A     NOP
0D88  5015     MOVF dividend, W, ACCESS
0D8A  1016     IORWF Message, W, ACCESS
0D8C  A4D8     BTFSS STATUS, 2, ACCESS
0D8E  D042     BRA 0xE14
1173:          
1174:                      *fmt += CSTRLEN("hu");
0D90  0E02     MOVLW 0x2
0D92  C089     MOVFF fmt, FSR2
0D94  FFD9     NOP
0D96  C08A     MOVFF s, FSR2H
0D98  FFDA     NOP
0D9A  26DE     ADDWF POSTINC2, F, ACCESS
0D9C  0E00     MOVLW 0x0
0D9E  22DD     ADDWFC POSTDEC2, F, ACCESS
1175:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
0DA0  C08B     MOVFF ap, FSR2
0DA2  FFD9     NOP
0DA4  C08C     MOVFF res, FSR2H
0DA6  FFDA     NOP
0DA8  CFDF     MOVFF INDF2, 0x8D
0DAA  F08D     NOP
0DAC  0E02     MOVLW 0x2
0DAE  26DE     ADDWF POSTINC2, F, ACCESS
0DB0  CFDF     MOVFF INDF2, 0x8E
0DB2  F08E     NOP
0DB4  0E00     MOVLW 0x0
0DB6  22DD     ADDWFC POSTDEC2, F, ACCESS
0DB8  C08D     MOVFF 0x8D, FSR2
0DBA  FFD9     NOP
0DBC  C08E     MOVFF 0x8E, FSR2H
0DBE  FFDA     NOP
0DC0  CFDE     MOVFF POSTINC2, 0x8F
0DC2  F08F     NOP
0DC4  CFDD     MOVFF POSTDEC2, 0x90
0DC6  F090     NOP
0DC8  C08F     MOVFF 0x8F, llu
0DCA  F0A4     NOP
0DCC  C090     MOVFF 0x90, digit
0DCE  F0A5     NOP
0DD0  0100     MOVLB 0x0
0DD2  6BA6     CLRF flags, BANKED
0DD4  6BA7     CLRF expon, BANKED
0DD6  6BA8     CLRF 0xA8, BANKED
0DD8  6BA9     CLRF eexp, BANKED
0DDA  6BAA     CLRF 0xAA, BANKED
0DDC  6BAB     CLRF _u, BANKED
1176:                                  
1177:                      return utoa(fp, llu);
0DDE  C087     MOVFF fp, __pcstackBANK0
0DE0  F060     NOP
0DE2  C088     MOVFF bexp, 0x61
0DE4  F061     NOP
0DE6  C0A4     MOVFF llu, d
0DE8  F062     NOP
0DEA  C0A5     MOVFF digit, 0x63
0DEC  F063     NOP
0DEE  C0A6     MOVFF flags, sign
0DF0  F064     NOP
0DF2  C0A7     MOVFF expon, aexp
0DF4  F065     NOP
0DF6  C0A8     MOVFF 0xA8, grs
0DF8  F066     NOP
0DFA  C0A9     MOVFF eexp, 0x67
0DFC  F067     NOP
0DFE  C0AA     MOVFF 0xAA, 0x68
0E00  F068     NOP
0E02  C0AB     MOVFF _u, 0x69
0E04  F069     NOP
0E06  EC18     CALL 0x4630, 0
0E08  F023     NOP
0E0A  C060     MOVFF __pcstackBANK0, fp
0E0C  F087     NOP
0E0E  C061     MOVFF 0x61, bexp
0E10  F088     NOP
0E12  0012     RETURN 0
1178:                  }
1179:          #endif
1180:          
1181:                  /* Unsigned decimal integer */
1182:                  if (*fmt[0] == 'u') {
0E14  C089     MOVFF fmt, FSR2
0E16  FFD9     NOP
0E18  C08A     MOVFF s, FSR2H
0E1A  FFDA     NOP
0E1C  CFDE     MOVFF POSTINC2, TBLPTR
0E1E  FFF6     NOP
0E20  CFDD     MOVFF POSTDEC2, TBLPTRH
0E22  FFF7     NOP
0E24  0008     TBLRD*
0E26  50F5     MOVF TABLAT, W, ACCESS
0E28  0A75     XORLW 0x75
0E2A  A4D8     BTFSS STATUS, 2, ACCESS
0E2C  D041     BRA 0xEB0
1183:          
1184:                      ++*fmt;
0E2E  C089     MOVFF fmt, FSR2
0E30  FFD9     NOP
0E32  C08A     MOVFF s, FSR2H
0E34  FFDA     NOP
0E36  2ADE     INCF POSTINC2, F, ACCESS
0E38  0E00     MOVLW 0x0
0E3A  22DD     ADDWFC POSTDEC2, F, ACCESS
1185:                      llu = (unsigned long long)va_arg(ap, unsigned int);
0E3C  C08B     MOVFF ap, FSR2
0E3E  FFD9     NOP
0E40  C08C     MOVFF res, FSR2H
0E42  FFDA     NOP
0E44  CFDF     MOVFF INDF2, 0x8D
0E46  F08D     NOP
0E48  0E02     MOVLW 0x2
0E4A  26DE     ADDWF POSTINC2, F, ACCESS
0E4C  CFDF     MOVFF INDF2, 0x8E
0E4E  F08E     NOP
0E50  0E00     MOVLW 0x0
0E52  22DD     ADDWFC POSTDEC2, F, ACCESS
0E54  C08D     MOVFF 0x8D, FSR2
0E56  FFD9     NOP
0E58  C08E     MOVFF 0x8E, FSR2H
0E5A  FFDA     NOP
0E5C  CFDE     MOVFF POSTINC2, 0x8F
0E5E  F08F     NOP
0E60  CFDD     MOVFF POSTDEC2, 0x90
0E62  F090     NOP
0E64  C08F     MOVFF 0x8F, llu
0E66  F0A4     NOP
0E68  C090     MOVFF 0x90, digit
0E6A  F0A5     NOP
0E6C  0100     MOVLB 0x0
0E6E  6BA6     CLRF flags, BANKED
0E70  6BA7     CLRF expon, BANKED
0E72  6BA8     CLRF 0xA8, BANKED
0E74  6BA9     CLRF eexp, BANKED
0E76  6BAA     CLRF 0xAA, BANKED
0E78  6BAB     CLRF _u, BANKED
1186:                                  
1187:                      return utoa(fp, llu);
0E7A  C087     MOVFF fp, __pcstackBANK0
0E7C  F060     NOP
0E7E  C088     MOVFF bexp, 0x61
0E80  F061     NOP
0E82  C0A4     MOVFF llu, d
0E84  F062     NOP
0E86  C0A5     MOVFF digit, 0x63
0E88  F063     NOP
0E8A  C0A6     MOVFF flags, sign
0E8C  F064     NOP
0E8E  C0A7     MOVFF expon, aexp
0E90  F065     NOP
0E92  C0A8     MOVFF 0xA8, grs
0E94  F066     NOP
0E96  C0A9     MOVFF eexp, 0x67
0E98  F067     NOP
0E9A  C0AA     MOVFF 0xAA, 0x68
0E9C  F068     NOP
0E9E  C0AB     MOVFF _u, 0x69
0EA0  F069     NOP
0EA2  EC18     CALL 0x4630, 0
0EA4  F023     NOP
0EA6  C060     MOVFF __pcstackBANK0, fp
0EA8  F087     NOP
0EAA  C061     MOVFF 0x61, bexp
0EAC  F088     NOP
0EAE  0012     RETURN 0
1188:                  }
1189:          
1190:          #ifdef _VFPF_L
1191:                  /* Unsigned long decimal integer */
1192:                  if (!strncmp(*fmt, "lu", CSTRLEN("lu"))) {
1193:          
1194:                      *fmt += CSTRLEN("lu");
1195:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1196:                                  
1197:                      return utoa(fp, llu);
1198:                  }
1199:          #endif
1200:          
1201:          #ifdef _VFPF_LL
1202:                  /* Unsigned long long decimal integer */
1203:                  if (!strncmp(*fmt, "llu", CSTRLEN("llu"))) {
1204:          
1205:                      *fmt += CSTRLEN("llu");
1206:                      llu = va_arg(ap, unsigned long long);
1207:                                  
1208:                      return utoa(fp, llu);
1209:                  }
1210:          #endif
1211:          
1212:          #ifdef _VFPF_J
1213:                  /* uintmax_t decimal integer */
1214:                  if (!strncmp(*fmt, "ju", CSTRLEN("ju"))) {
1215:          
1216:                      *fmt += CSTRLEN("ju");
1217:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1218:                                  
1219:                      return utoa(fp, llu);
1220:                  }
1221:          #endif
1222:          
1223:          #ifdef _VFPF_T
1224:                  /* ptrdiff_t decimal integer */
1225:                  if (!strncmp(*fmt, "tu", CSTRLEN("tu"))) {
1226:          
1227:                      *fmt += CSTRLEN("tu");
1228:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1229:                                  
1230:                      return utoa(fp, llu);
1231:                  }
1232:          #endif
1233:          
1234:          #ifdef _VFPF_Z
1235:                  /* size_t decimal integer */
1236:                  if (!strncmp(*fmt, "zu", CSTRLEN("zu"))) {
0EB0  C089     MOVFF fmt, FSR2
0EB2  FFD9     NOP
0EB4  C08A     MOVFF s, FSR2H
0EB6  FFDA     NOP
0EB8  CFDE     MOVFF POSTINC2, dividend
0EBA  F015     NOP
0EBC  CFDD     MOVFF POSTDEC2, Message
0EBE  F016     NOP
0EC0  0EF6     MOVLW 0xF6
0EC2  6E17     MOVWF _r, ACCESS
0EC4  0E7F     MOVLW 0x7F
0EC6  6E18     MOVWF 0x18, ACCESS
0EC8  0E00     MOVLW 0x0
0ECA  6E1A     MOVWF s, ACCESS
0ECC  0E02     MOVLW 0x2
0ECE  6E19     MOVWF multiplicand, ACCESS
0ED0  ECD7     CALL 0x55AE, 0
0ED2  F02A     NOP
0ED4  5015     MOVF dividend, W, ACCESS
0ED6  1016     IORWF Message, W, ACCESS
0ED8  A4D8     BTFSS STATUS, 2, ACCESS
0EDA  D042     BRA 0xF60
1237:          
1238:                      *fmt += CSTRLEN("zu");
0EDC  0E02     MOVLW 0x2
0EDE  C089     MOVFF fmt, FSR2
0EE0  FFD9     NOP
0EE2  C08A     MOVFF s, FSR2H
0EE4  FFDA     NOP
0EE6  26DE     ADDWF POSTINC2, F, ACCESS
0EE8  0E00     MOVLW 0x0
0EEA  22DD     ADDWFC POSTDEC2, F, ACCESS
1239:                      llu = (unsigned long long)va_arg(ap, size_t);
0EEC  C08B     MOVFF ap, FSR2
0EEE  FFD9     NOP
0EF0  C08C     MOVFF res, FSR2H
0EF2  FFDA     NOP
0EF4  CFDF     MOVFF INDF2, 0x8D
0EF6  F08D     NOP
0EF8  0E02     MOVLW 0x2
0EFA  26DE     ADDWF POSTINC2, F, ACCESS
0EFC  CFDF     MOVFF INDF2, 0x8E
0EFE  F08E     NOP
0F00  0E00     MOVLW 0x0
0F02  22DD     ADDWFC POSTDEC2, F, ACCESS
0F04  C08D     MOVFF 0x8D, FSR2
0F06  FFD9     NOP
0F08  C08E     MOVFF 0x8E, FSR2H
0F0A  FFDA     NOP
0F0C  CFDE     MOVFF POSTINC2, 0x8F
0F0E  F08F     NOP
0F10  CFDD     MOVFF POSTDEC2, 0x90
0F12  F090     NOP
0F14  C08F     MOVFF 0x8F, llu
0F16  F0A4     NOP
0F18  C090     MOVFF 0x90, digit
0F1A  F0A5     NOP
0F1C  0100     MOVLB 0x0
0F1E  6BA6     CLRF flags, BANKED
0F20  6BA7     CLRF expon, BANKED
0F22  6BA8     CLRF 0xA8, BANKED
0F24  6BA9     CLRF eexp, BANKED
0F26  6BAA     CLRF 0xAA, BANKED
0F28  6BAB     CLRF _u, BANKED
1240:                                  
1241:                      return utoa(fp, llu);
0F2A  C087     MOVFF fp, __pcstackBANK0
0F2C  F060     NOP
0F2E  C088     MOVFF bexp, 0x61
0F30  F061     NOP
0F32  C0A4     MOVFF llu, d
0F34  F062     NOP
0F36  C0A5     MOVFF digit, 0x63
0F38  F063     NOP
0F3A  C0A6     MOVFF flags, sign
0F3C  F064     NOP
0F3E  C0A7     MOVFF expon, aexp
0F40  F065     NOP
0F42  C0A8     MOVFF 0xA8, grs
0F44  F066     NOP
0F46  C0A9     MOVFF eexp, 0x67
0F48  F067     NOP
0F4A  C0AA     MOVFF 0xAA, 0x68
0F4C  F068     NOP
0F4E  C0AB     MOVFF _u, 0x69
0F50  F069     NOP
0F52  EC18     CALL 0x4630, 0
0F54  F023     NOP
0F56  C060     MOVFF __pcstackBANK0, fp
0F58  F087     NOP
0F5A  C061     MOVFF 0x61, bexp
0F5C  F088     NOP
0F5E  0012     RETURN 0
1242:                  }
1243:          #endif
1244:          #endif
1245:          
1246:          #ifdef _VFPF_X
1247:          #ifdef _VFPF_HH
1248:                  /* Character hexadecimal integer */
1249:                  if (!strncmp(*fmt, "hhx", CSTRLEN("hhx")) || \
0F60  C089     MOVFF fmt, FSR2
0F62  FFD9     NOP
0F64  C08A     MOVFF s, FSR2H
0F66  FFDA     NOP
0F68  CFDE     MOVFF POSTINC2, dividend
0F6A  F015     NOP
0F6C  CFDD     MOVFF POSTDEC2, Message
0F6E  F016     NOP
0F70  0EDF     MOVLW 0xDF
0F72  6E17     MOVWF _r, ACCESS
0F74  0E7F     MOVLW 0x7F
0F76  6E18     MOVWF 0x18, ACCESS
0F78  0E00     MOVLW 0x0
0F7A  6E1A     MOVWF s, ACCESS
0F7C  0E03     MOVLW 0x3
0F7E  6E19     MOVWF multiplicand, ACCESS
0F80  ECD7     CALL 0x55AE, 0
0F82  F02A     NOP
0F84  5015     MOVF dividend, W, ACCESS
0F86  1016     IORWF Message, W, ACCESS
0F88  B4D8     BTFSC STATUS, 2, ACCESS
0F8A  D016     BRA 0xFB8
0F8C  C089     MOVFF fmt, FSR2
0F8E  FFD9     NOP
0F90  C08A     MOVFF s, FSR2H
0F92  FFDA     NOP
0F94  CFDE     MOVFF POSTINC2, dividend
0F96  F015     NOP
0F98  CFDD     MOVFF POSTDEC2, Message
0F9A  F016     NOP
0F9C  0EC7     MOVLW 0xC7
0F9E  6E17     MOVWF _r, ACCESS
0FA0  0E7F     MOVLW 0x7F
0FA2  6E18     MOVWF 0x18, ACCESS
0FA4  0E00     MOVLW 0x0
0FA6  6E1A     MOVWF s, ACCESS
0FA8  0E03     MOVLW 0x3
0FAA  6E19     MOVWF multiplicand, ACCESS
0FAC  ECD7     CALL 0x55AE, 0
0FAE  F02A     NOP
0FB0  5015     MOVF dividend, W, ACCESS
0FB2  1016     IORWF Message, W, ACCESS
0FB4  A4D8     BTFSS STATUS, 2, ACCESS
0FB6  D054     BRA 0x1060
1250:                      !strncmp(*fmt, "hhX", CSTRLEN("hhX"))) {
1251:          
1252:                      c = (*fmt)[2];
0FB8  C089     MOVFF fmt, FSR2
0FBA  FFD9     NOP
0FBC  C08A     MOVFF s, FSR2H
0FBE  FFDA     NOP
0FC0  CFDE     MOVFF POSTINC2, 0x8D
0FC2  F08D     NOP
0FC4  CFDD     MOVFF POSTDEC2, 0x8E
0FC6  F08E     NOP
0FC8  0E02     MOVLW 0x2
0FCA  0100     MOVLB 0x0
0FCC  278D     ADDWF 0x8D, F, BANKED
0FCE  0E00     MOVLW 0x0
0FD0  238E     ADDWFC 0x8E, F, BANKED
0FD2  C08D     MOVFF 0x8D, TBLPTR
0FD4  FFF6     NOP
0FD6  C08E     MOVFF 0x8E, TBLPTRH
0FD8  FFF7     NOP
0FDA  0008     TBLRD*
0FDC  CFF5     MOVFF TABLAT, c
0FDE  F0A3     NOP
1253:                      *fmt += CSTRLEN("hhx");
0FE0  0E03     MOVLW 0x3
0FE2  C089     MOVFF fmt, FSR2
0FE4  FFD9     NOP
0FE6  C08A     MOVFF s, FSR2H
0FE8  FFDA     NOP
0FEA  26DE     ADDWF POSTINC2, F, ACCESS
0FEC  0E00     MOVLW 0x0
0FEE  22DD     ADDWFC POSTDEC2, F, ACCESS
1254:                      llu = (unsigned long long)(unsigned char)va_arg(ap, int);
0FF0  C08B     MOVFF ap, FSR2
0FF2  FFD9     NOP
0FF4  C08C     MOVFF res, FSR2H
0FF6  FFDA     NOP
0FF8  CFDF     MOVFF INDF2, 0x8D
0FFA  F08D     NOP
0FFC  0E02     MOVLW 0x2
0FFE  26DE     ADDWF POSTINC2, F, ACCESS
1000  CFDF     MOVFF INDF2, 0x8E
1002  F08E     NOP
1004  0E00     MOVLW 0x0
1006  22DD     ADDWFC POSTDEC2, F, ACCESS
1008  C08D     MOVFF 0x8D, FSR2
100A  FFD9     NOP
100C  C08E     MOVFF 0x8E, FSR2H
100E  FFDA     NOP
1010  50DF     MOVF INDF2, W, ACCESS
1012  6F8F     MOVWF 0x8F, BANKED
1014  518F     MOVF 0x8F, W, BANKED
1016  6FA4     MOVWF llu, BANKED
1018  6BA5     CLRF digit, BANKED
101A  6BA6     CLRF flags, BANKED
101C  6BA7     CLRF expon, BANKED
101E  6BA8     CLRF 0xA8, BANKED
1020  6BA9     CLRF eexp, BANKED
1022  6BAA     CLRF 0xAA, BANKED
1024  6BAB     CLRF _u, BANKED
1255:                                  
1256:                      return xtoa(fp, llu, c);
1026  C087     MOVFF fp, __pcstackBANK0
1028  F060     NOP
102A  C088     MOVFF bexp, 0x61
102C  F061     NOP
102E  C0A4     MOVFF llu, d
1030  F062     NOP
1032  C0A5     MOVFF digit, 0x63
1034  F063     NOP
1036  C0A6     MOVFF flags, sign
1038  F064     NOP
103A  C0A7     MOVFF expon, aexp
103C  F065     NOP
103E  C0A8     MOVFF 0xA8, grs
1040  F066     NOP
1042  C0A9     MOVFF eexp, 0x67
1044  F067     NOP
1046  C0AA     MOVFF 0xAA, 0x68
1048  F068     NOP
104A  C0AB     MOVFF _u, 0x69
104C  F069     NOP
104E  C0A3     MOVFF c, x
1050  F06A     NOP
1052  ECF7     CALL 0x43EE, 0
1054  F021     NOP
1056  C060     MOVFF __pcstackBANK0, fp
1058  F087     NOP
105A  C061     MOVFF 0x61, bexp
105C  F088     NOP
105E  0012     RETURN 0
1257:                  }
1258:          #endif
1259:          
1260:          #ifdef _VFPF_H
1261:                  /* Short hexadecimal integer */
1262:                  if (!strncmp(*fmt, "hx", CSTRLEN("hx")) || \
1060  C089     MOVFF fmt, FSR2
1062  FFD9     NOP
1064  C08A     MOVFF s, FSR2H
1066  FFDA     NOP
1068  CFDE     MOVFF POSTINC2, dividend
106A  F015     NOP
106C  CFDD     MOVFF POSTDEC2, Message
106E  F016     NOP
1070  0EE0     MOVLW 0xE0
1072  6E17     MOVWF _r, ACCESS
1074  0E7F     MOVLW 0x7F
1076  6E18     MOVWF 0x18, ACCESS
1078  0E00     MOVLW 0x0
107A  6E1A     MOVWF s, ACCESS
107C  0E02     MOVLW 0x2
107E  6E19     MOVWF multiplicand, ACCESS
1080  ECD7     CALL 0x55AE, 0
1082  F02A     NOP
1084  5015     MOVF dividend, W, ACCESS
1086  1016     IORWF Message, W, ACCESS
1088  B4D8     BTFSC STATUS, 2, ACCESS
108A  D016     BRA 0x10B8
108C  C089     MOVFF fmt, FSR2
108E  FFD9     NOP
1090  C08A     MOVFF s, FSR2H
1092  FFDA     NOP
1094  CFDE     MOVFF POSTINC2, dividend
1096  F015     NOP
1098  CFDD     MOVFF POSTDEC2, Message
109A  F016     NOP
109C  0EC8     MOVLW 0xC8
109E  6E17     MOVWF _r, ACCESS
10A0  0E7F     MOVLW 0x7F
10A2  6E18     MOVWF 0x18, ACCESS
10A4  0E00     MOVLW 0x0
10A6  6E1A     MOVWF s, ACCESS
10A8  0E02     MOVLW 0x2
10AA  6E19     MOVWF multiplicand, ACCESS
10AC  ECD7     CALL 0x55AE, 0
10AE  F02A     NOP
10B0  5015     MOVF dividend, W, ACCESS
10B2  1016     IORWF Message, W, ACCESS
10B4  A4D8     BTFSS STATUS, 2, ACCESS
10B6  D057     BRA 0x1166
1263:                      !strncmp(*fmt, "hX", CSTRLEN("hX"))) {
1264:          
1265:                      c = (*fmt)[1];
10B8  C089     MOVFF fmt, FSR2
10BA  FFD9     NOP
10BC  C08A     MOVFF s, FSR2H
10BE  FFDA     NOP
10C0  CFDE     MOVFF POSTINC2, 0x8D
10C2  F08D     NOP
10C4  CFDD     MOVFF POSTDEC2, 0x8E
10C6  F08E     NOP
10C8  0E01     MOVLW 0x1
10CA  0100     MOVLB 0x0
10CC  278D     ADDWF 0x8D, F, BANKED
10CE  0E00     MOVLW 0x0
10D0  238E     ADDWFC 0x8E, F, BANKED
10D2  C08D     MOVFF 0x8D, TBLPTR
10D4  FFF6     NOP
10D6  C08E     MOVFF 0x8E, TBLPTRH
10D8  FFF7     NOP
10DA  0008     TBLRD*
10DC  CFF5     MOVFF TABLAT, c
10DE  F0A3     NOP
1266:                      *fmt += CSTRLEN("hx");
10E0  0E02     MOVLW 0x2
10E2  C089     MOVFF fmt, FSR2
10E4  FFD9     NOP
10E6  C08A     MOVFF s, FSR2H
10E8  FFDA     NOP
10EA  26DE     ADDWF POSTINC2, F, ACCESS
10EC  0E00     MOVLW 0x0
10EE  22DD     ADDWFC POSTDEC2, F, ACCESS
1267:                      llu = (unsigned long long)(unsigned short)va_arg(ap, int);
10F0  C08B     MOVFF ap, FSR2
10F2  FFD9     NOP
10F4  C08C     MOVFF res, FSR2H
10F6  FFDA     NOP
10F8  CFDF     MOVFF INDF2, 0x8D
10FA  F08D     NOP
10FC  0E02     MOVLW 0x2
10FE  26DE     ADDWF POSTINC2, F, ACCESS
1100  CFDF     MOVFF INDF2, 0x8E
1102  F08E     NOP
1104  0E00     MOVLW 0x0
1106  22DD     ADDWFC POSTDEC2, F, ACCESS
1108  C08D     MOVFF 0x8D, FSR2
110A  FFD9     NOP
110C  C08E     MOVFF 0x8E, FSR2H
110E  FFDA     NOP
1110  CFDE     MOVFF POSTINC2, 0x8F
1112  F08F     NOP
1114  CFDD     MOVFF POSTDEC2, 0x90
1116  F090     NOP
1118  C08F     MOVFF 0x8F, llu
111A  F0A4     NOP
111C  C090     MOVFF 0x90, digit
111E  F0A5     NOP
1120  6BA6     CLRF flags, BANKED
1122  6BA7     CLRF expon, BANKED
1124  6BA8     CLRF 0xA8, BANKED
1126  6BA9     CLRF eexp, BANKED
1128  6BAA     CLRF 0xAA, BANKED
112A  6BAB     CLRF _u, BANKED
1268:                                  
1269:                      return xtoa(fp, llu, c);
112C  C087     MOVFF fp, __pcstackBANK0
112E  F060     NOP
1130  C088     MOVFF bexp, 0x61
1132  F061     NOP
1134  C0A4     MOVFF llu, d
1136  F062     NOP
1138  C0A5     MOVFF digit, 0x63
113A  F063     NOP
113C  C0A6     MOVFF flags, sign
113E  F064     NOP
1140  C0A7     MOVFF expon, aexp
1142  F065     NOP
1144  C0A8     MOVFF 0xA8, grs
1146  F066     NOP
1148  C0A9     MOVFF eexp, 0x67
114A  F067     NOP
114C  C0AA     MOVFF 0xAA, 0x68
114E  F068     NOP
1150  C0AB     MOVFF _u, 0x69
1152  F069     NOP
1154  C0A3     MOVFF c, x
1156  F06A     NOP
1158  ECF7     CALL 0x43EE, 0
115A  F021     NOP
115C  C060     MOVFF __pcstackBANK0, fp
115E  F087     NOP
1160  C061     MOVFF 0x61, bexp
1162  F088     NOP
1164  0012     RETURN 0
1270:                  }
1271:          #endif
1272:          
1273:                  /* Hexadecimal integer */
1274:                  if ((*fmt[0] == 'x') || (*fmt[0] == 'X')) {
1166  C089     MOVFF fmt, FSR2
1168  FFD9     NOP
116A  C08A     MOVFF s, FSR2H
116C  FFDA     NOP
116E  CFDE     MOVFF POSTINC2, TBLPTR
1170  FFF6     NOP
1172  CFDD     MOVFF POSTDEC2, TBLPTRH
1174  FFF7     NOP
1176  0008     TBLRD*
1178  50F5     MOVF TABLAT, W, ACCESS
117A  0A78     XORLW 0x78
117C  B4D8     BTFSC STATUS, 2, ACCESS
117E  D00D     BRA 0x119A
1180  C089     MOVFF fmt, FSR2
1182  FFD9     NOP
1184  C08A     MOVFF s, FSR2H
1186  FFDA     NOP
1188  CFDE     MOVFF POSTINC2, TBLPTR
118A  FFF6     NOP
118C  CFDD     MOVFF POSTDEC2, TBLPTRH
118E  FFF7     NOP
1190  0008     TBLRD*
1192  50F5     MOVF TABLAT, W, ACCESS
1194  0A58     XORLW 0x58
1196  A4D8     BTFSS STATUS, 2, ACCESS
1198  D04E     BRA 0x1236
1275:          
1276:                      c = (*fmt)[0];
119A  C089     MOVFF fmt, FSR2
119C  FFD9     NOP
119E  C08A     MOVFF s, FSR2H
11A0  FFDA     NOP
11A2  CFDE     MOVFF POSTINC2, TBLPTR
11A4  FFF6     NOP
11A6  CFDD     MOVFF POSTDEC2, TBLPTRH
11A8  FFF7     NOP
11AA  0008     TBLRD*
11AC  CFF5     MOVFF TABLAT, c
11AE  F0A3     NOP
1277:                      ++*fmt;
11B0  C089     MOVFF fmt, FSR2
11B2  FFD9     NOP
11B4  C08A     MOVFF s, FSR2H
11B6  FFDA     NOP
11B8  2ADE     INCF POSTINC2, F, ACCESS
11BA  0E00     MOVLW 0x0
11BC  22DD     ADDWFC POSTDEC2, F, ACCESS
1278:                      llu = (unsigned long long)va_arg(ap, unsigned int);
11BE  C08B     MOVFF ap, FSR2
11C0  FFD9     NOP
11C2  C08C     MOVFF res, FSR2H
11C4  FFDA     NOP
11C6  CFDF     MOVFF INDF2, 0x8D
11C8  F08D     NOP
11CA  0E02     MOVLW 0x2
11CC  26DE     ADDWF POSTINC2, F, ACCESS
11CE  CFDF     MOVFF INDF2, 0x8E
11D0  F08E     NOP
11D2  0E00     MOVLW 0x0
11D4  22DD     ADDWFC POSTDEC2, F, ACCESS
11D6  C08D     MOVFF 0x8D, FSR2
11D8  FFD9     NOP
11DA  C08E     MOVFF 0x8E, FSR2H
11DC  FFDA     NOP
11DE  CFDE     MOVFF POSTINC2, 0x8F
11E0  F08F     NOP
11E2  CFDD     MOVFF POSTDEC2, 0x90
11E4  F090     NOP
11E6  C08F     MOVFF 0x8F, llu
11E8  F0A4     NOP
11EA  C090     MOVFF 0x90, digit
11EC  F0A5     NOP
11EE  0100     MOVLB 0x0
11F0  6BA6     CLRF flags, BANKED
11F2  6BA7     CLRF expon, BANKED
11F4  6BA8     CLRF 0xA8, BANKED
11F6  6BA9     CLRF eexp, BANKED
11F8  6BAA     CLRF 0xAA, BANKED
11FA  6BAB     CLRF _u, BANKED
1279:                                  
1280:                      return xtoa(fp, llu, c);
11FC  C087     MOVFF fp, __pcstackBANK0
11FE  F060     NOP
1200  C088     MOVFF bexp, 0x61
1202  F061     NOP
1204  C0A4     MOVFF llu, d
1206  F062     NOP
1208  C0A5     MOVFF digit, 0x63
120A  F063     NOP
120C  C0A6     MOVFF flags, sign
120E  F064     NOP
1210  C0A7     MOVFF expon, aexp
1212  F065     NOP
1214  C0A8     MOVFF 0xA8, grs
1216  F066     NOP
1218  C0A9     MOVFF eexp, 0x67
121A  F067     NOP
121C  C0AA     MOVFF 0xAA, 0x68
121E  F068     NOP
1220  C0AB     MOVFF _u, 0x69
1222  F069     NOP
1224  C0A3     MOVFF c, x
1226  F06A     NOP
1228  ECF7     CALL 0x43EE, 0
122A  F021     NOP
122C  C060     MOVFF __pcstackBANK0, fp
122E  F087     NOP
1230  C061     MOVFF 0x61, bexp
1232  F088     NOP
1234  0012     RETURN 0
1281:                  }
1282:          
1283:          #ifdef _VFPF_L
1284:                  /* Long hexadecimal integer */
1285:                  if (!strncmp(*fmt, "lx", CSTRLEN("lx")) || \
1286:                      !strncmp(*fmt, "lX", CSTRLEN("lX"))) {
1287:          
1288:                      c = (*fmt)[1];
1289:                      *fmt += CSTRLEN("lx");
1290:                      llu = (unsigned long long)va_arg(ap, unsigned long);
1291:                                  
1292:                      return xtoa(fp, llu, c);
1293:                  }
1294:          #endif
1295:          
1296:          #ifdef _VFPF_LL
1297:                  /* Long long hexadecimal integer */
1298:                  if (!strncmp(*fmt, "llx", CSTRLEN("llx")) || \
1299:                      !strncmp(*fmt, "llX", CSTRLEN("llX"))) {
1300:          
1301:                      c = (*fmt)[2];
1302:                      *fmt += CSTRLEN("llx");
1303:                      llu = va_arg(ap, unsigned long long);
1304:                                  
1305:                      return xtoa(fp, llu, c);
1306:                  }
1307:          #endif
1308:          
1309:          #ifdef _VFPF_J
1310:                  /* uintmax_t hexadecimal integer */
1311:                  if (!strncmp(*fmt, "jx", CSTRLEN("jx")) || \
1312:                      !strncmp(*fmt, "jX", CSTRLEN("jX"))) {
1313:          
1314:                      c = (*fmt)[1];
1315:                      *fmt += CSTRLEN("jx");
1316:                      llu = (unsigned long long)va_arg(ap, uintmax_t);
1317:                                  
1318:                      return xtoa(fp, llu, c);
1319:                  }
1320:          #endif
1321:          
1322:          #ifdef _VFPF_T
1323:                  /* ptrdiff_t hexadecimal integer */
1324:                  if (!strncmp(*fmt, "tx", CSTRLEN("tx")) || \
1325:                      !strncmp(*fmt, "tX", CSTRLEN("tX"))) {
1326:          
1327:                      c = (*fmt)[1];
1328:                      *fmt += CSTRLEN("tx");
1329:                      llu = (unsigned long long)va_arg(ap, ptrdiff_t);
1330:                                  
1331:                      return xtoa(fp, llu, c);
1332:                  }
1333:          #endif
1334:          
1335:          #ifdef _VFPF_Z
1336:                  /* size_t hexadecimal integer */
1337:                  if (!strncmp(*fmt, "zx", CSTRLEN("zx")) || \
1236  C089     MOVFF fmt, FSR2
1238  FFD9     NOP
123A  C08A     MOVFF s, FSR2H
123C  FFDA     NOP
123E  CFDE     MOVFF POSTINC2, dividend
1240  F015     NOP
1242  CFDD     MOVFF POSTDEC2, Message
1244  F016     NOP
1246  0EF9     MOVLW 0xF9
1248  6E17     MOVWF _r, ACCESS
124A  0E7F     MOVLW 0x7F
124C  6E18     MOVWF 0x18, ACCESS
124E  0E00     MOVLW 0x0
1250  6E1A     MOVWF s, ACCESS
1252  0E02     MOVLW 0x2
1254  6E19     MOVWF multiplicand, ACCESS
1256  ECD7     CALL 0x55AE, 0
1258  F02A     NOP
125A  5015     MOVF dividend, W, ACCESS
125C  1016     IORWF Message, W, ACCESS
125E  B4D8     BTFSC STATUS, 2, ACCESS
1260  D016     BRA 0x128E
1262  C089     MOVFF fmt, FSR2
1264  FFD9     NOP
1266  C08A     MOVFF s, FSR2H
1268  FFDA     NOP
126A  CFDE     MOVFF POSTINC2, dividend
126C  F015     NOP
126E  CFDD     MOVFF POSTDEC2, Message
1270  F016     NOP
1272  0EE7     MOVLW 0xE7
1274  6E17     MOVWF _r, ACCESS
1276  0E7F     MOVLW 0x7F
1278  6E18     MOVWF 0x18, ACCESS
127A  0E00     MOVLW 0x0
127C  6E1A     MOVWF s, ACCESS
127E  0E02     MOVLW 0x2
1280  6E19     MOVWF multiplicand, ACCESS
1282  ECD7     CALL 0x55AE, 0
1284  F02A     NOP
1286  5015     MOVF dividend, W, ACCESS
1288  1016     IORWF Message, W, ACCESS
128A  A4D8     BTFSS STATUS, 2, ACCESS
128C  D057     BRA 0x133C
1338:                      !strncmp(*fmt, "zX", CSTRLEN("zX"))) {
1339:          
1340:                      c = (*fmt)[1];
128E  C089     MOVFF fmt, FSR2
1290  FFD9     NOP
1292  C08A     MOVFF s, FSR2H
1294  FFDA     NOP
1296  CFDE     MOVFF POSTINC2, 0x8D
1298  F08D     NOP
129A  CFDD     MOVFF POSTDEC2, 0x8E
129C  F08E     NOP
129E  0E01     MOVLW 0x1
12A0  0100     MOVLB 0x0
12A2  278D     ADDWF 0x8D, F, BANKED
12A4  0E00     MOVLW 0x0
12A6  238E     ADDWFC 0x8E, F, BANKED
12A8  C08D     MOVFF 0x8D, TBLPTR
12AA  FFF6     NOP
12AC  C08E     MOVFF 0x8E, TBLPTRH
12AE  FFF7     NOP
12B0  0008     TBLRD*
12B2  CFF5     MOVFF TABLAT, c
12B4  F0A3     NOP
1341:                      *fmt += CSTRLEN("zx");
12B6  0E02     MOVLW 0x2
12B8  C089     MOVFF fmt, FSR2
12BA  FFD9     NOP
12BC  C08A     MOVFF s, FSR2H
12BE  FFDA     NOP
12C0  26DE     ADDWF POSTINC2, F, ACCESS
12C2  0E00     MOVLW 0x0
12C4  22DD     ADDWFC POSTDEC2, F, ACCESS
1342:                      llu = (unsigned long long)va_arg(ap, size_t);
12C6  C08B     MOVFF ap, FSR2
12C8  FFD9     NOP
12CA  C08C     MOVFF res, FSR2H
12CC  FFDA     NOP
12CE  CFDF     MOVFF INDF2, 0x8D
12D0  F08D     NOP
12D2  0E02     MOVLW 0x2
12D4  26DE     ADDWF POSTINC2, F, ACCESS
12D6  CFDF     MOVFF INDF2, 0x8E
12D8  F08E     NOP
12DA  0E00     MOVLW 0x0
12DC  22DD     ADDWFC POSTDEC2, F, ACCESS
12DE  C08D     MOVFF 0x8D, FSR2
12E0  FFD9     NOP
12E2  C08E     MOVFF 0x8E, FSR2H
12E4  FFDA     NOP
12E6  CFDE     MOVFF POSTINC2, 0x8F
12E8  F08F     NOP
12EA  CFDD     MOVFF POSTDEC2, 0x90
12EC  F090     NOP
12EE  C08F     MOVFF 0x8F, llu
12F0  F0A4     NOP
12F2  C090     MOVFF 0x90, digit
12F4  F0A5     NOP
12F6  6BA6     CLRF flags, BANKED
12F8  6BA7     CLRF expon, BANKED
12FA  6BA8     CLRF 0xA8, BANKED
12FC  6BA9     CLRF eexp, BANKED
12FE  6BAA     CLRF 0xAA, BANKED
1300  6BAB     CLRF _u, BANKED
1343:                                  
1344:                      return xtoa(fp, llu, c);
1302  C087     MOVFF fp, __pcstackBANK0
1304  F060     NOP
1306  C088     MOVFF bexp, 0x61
1308  F061     NOP
130A  C0A4     MOVFF llu, d
130C  F062     NOP
130E  C0A5     MOVFF digit, 0x63
1310  F063     NOP
1312  C0A6     MOVFF flags, sign
1314  F064     NOP
1316  C0A7     MOVFF expon, aexp
1318  F065     NOP
131A  C0A8     MOVFF 0xA8, grs
131C  F066     NOP
131E  C0A9     MOVFF eexp, 0x67
1320  F067     NOP
1322  C0AA     MOVFF 0xAA, 0x68
1324  F068     NOP
1326  C0AB     MOVFF _u, 0x69
1328  F069     NOP
132A  C0A3     MOVFF c, x
132C  F06A     NOP
132E  ECF7     CALL 0x43EE, 0
1330  F021     NOP
1332  C060     MOVFF __pcstackBANK0, fp
1334  F087     NOP
1336  C061     MOVFF 0x61, bexp
1338  F088     NOP
133A  0012     RETURN 0
1345:                  }
1346:          #endif
1347:          #endif
1348:          
1349:                  /* 'Escaped' '%' character */
1350:                  if ((*fmt)[0] == '%') {
133C  C089     MOVFF fmt, FSR2
133E  FFD9     NOP
1340  C08A     MOVFF s, FSR2H
1342  FFDA     NOP
1344  CFDE     MOVFF POSTINC2, TBLPTR
1346  FFF6     NOP
1348  CFDD     MOVFF POSTDEC2, TBLPTRH
134A  FFF7     NOP
134C  0008     TBLRD*
134E  50F5     MOVF TABLAT, W, ACCESS
1350  0A25     XORLW 0x25
1352  A4D8     BTFSS STATUS, 2, ACCESS
1354  D017     BRA 0x1384
1351:                      ++*fmt;
1356  C089     MOVFF fmt, FSR2
1358  FFD9     NOP
135A  C08A     MOVFF s, FSR2H
135C  FFDA     NOP
135E  2ADE     INCF POSTINC2, F, ACCESS
1360  0E00     MOVLW 0x0
1362  22DD     ADDWFC POSTDEC2, F, ACCESS
1352:                      fputc((int)'%', fp);
1364  0E00     MOVLW 0x0
1366  6E18     MOVWF 0x18, ACCESS
1368  0E25     MOVLW 0x25
136A  6E17     MOVWF _r, ACCESS
136C  C087     MOVFF fp, multiplicand
136E  F019     NOP
1370  C088     MOVFF bexp, s
1372  F01A     NOP
1374  EC49     CALL 0x5A92, 0
1376  F02D     NOP
1353:                      return 1;
1378  0E00     MOVLW 0x0
137A  0100     MOVLB 0x0
137C  6F88     MOVWF bexp, BANKED
137E  0E01     MOVLW 0x1
1380  6F87     MOVWF fp, BANKED
1382  0012     RETURN 0
1354:                  }
1355:          
1356:                  /* Unrecognized conversion */
1357:                  ++*fmt;
1384  C089     MOVFF fmt, FSR2
1386  FFD9     NOP
1388  C08A     MOVFF s, FSR2H
138A  FFDA     NOP
138C  2ADE     INCF POSTINC2, F, ACCESS
138E  0E00     MOVLW 0x0
1390  22DD     ADDWFC POSTDEC2, F, ACCESS
1358:                  return 0;
1392  0E00     MOVLW 0x0
1394  0100     MOVLB 0x0
1396  6F88     MOVWF bexp, BANKED
1398  0E00     MOVLW 0x0
139A  6F87     MOVWF fp, BANKED
139C  0012     RETURN 0
1359:              }
1360:          
1361:              /* No conversion, just intervening text */
1362:              fputc((int)(*fmt)[0], fp);
139E  C089     MOVFF fmt, FSR2
13A0  FFD9     NOP
13A2  C08A     MOVFF s, FSR2H
13A4  FFDA     NOP
13A6  CFDE     MOVFF POSTINC2, TBLPTR
13A8  FFF6     NOP
13AA  CFDD     MOVFF POSTDEC2, TBLPTRH
13AC  FFF7     NOP
13AE  0008     TBLRD*
13B0  50F5     MOVF TABLAT, W, ACCESS
13B2  6E17     MOVWF _r, ACCESS
13B4  6A18     CLRF 0x18, ACCESS
13B6  C087     MOVFF fp, multiplicand
13B8  F019     NOP
13BA  C088     MOVFF bexp, s
13BC  F01A     NOP
13BE  EC49     CALL 0x5A92, 0
13C0  F02D     NOP
1363:              ++*fmt;
13C2  C089     MOVFF fmt, FSR2
13C4  FFD9     NOP
13C6  C08A     MOVFF s, FSR2H
13C8  FFDA     NOP
13CA  2ADE     INCF POSTINC2, F, ACCESS
13CC  0E00     MOVLW 0x0
13CE  22DD     ADDWFC POSTDEC2, F, ACCESS
1364:              return 1;
13D0  0E00     MOVLW 0x0
13D2  0100     MOVLB 0x0
13D4  6F88     MOVWF bexp, BANKED
13D6  0E01     MOVLW 0x1
13D8  6F87     MOVWF fp, BANKED
13DA  0012     RETURN 0
1365:          }
1366:          #endif
1367:          
1368:          int vfprintf(FILE *fp, const char *fmt, va_list ap)
1369:          {
1370:          #ifdef _VFPF_CONVERT
1371:              char *cfmt;
1372:          
1373:              cfmt = (char *)fmt;
5FB0  C0AE     MOVFF fmt, cfmt
5FB2  F0B2     NOP
5FB4  C0AF     MOVFF i, 0xB3
5FB6  F0B3     NOP
1374:              nout = 0;
5FB8  0E00     MOVLW 0x0
5FBA  0100     MOVLB 0x0
5FBC  6FD0     MOVWF 0xD0, BANKED
5FBE  0E00     MOVLW 0x0
5FC0  6FCF     MOVWF nout, BANKED
1375:              while (*cfmt) {
5FC2  D013     BRA 0x5FEA
1376:                  nout += vfpfcnvrt(fp, &cfmt, ap);
5FC4  C0AC     MOVFF fp, fp
5FC6  F087     NOP
5FC8  C0AD     MOVFF 0xAD, bexp
5FCA  F088     NOP
5FCC  0EB2     MOVLW 0xB2
5FCE  6F89     MOVWF fmt, BANKED
5FD0  0E00     MOVLW 0x0
5FD2  6F8A     MOVWF s, BANKED
5FD4  C0B0     MOVFF ap, ap
5FD6  F08B     NOP
5FD8  C0B1     MOVFF 0xB1, res
5FDA  F08C     NOP
5FDC  EC3A     CALL 0x74, 0
5FDE  F000     NOP
5FE0  0100     MOVLB 0x0
5FE2  5187     MOVF fp, W, BANKED
5FE4  27CF     ADDWF nout, F, BANKED
5FE6  5188     MOVF bexp, W, BANKED
5FE8  23D0     ADDWFC 0xD0, F, BANKED
1377:              }
5FEA  C0B2     MOVFF cfmt, TBLPTR
5FEC  FFF6     NOP
5FEE  C0B3     MOVFF 0xB3, TBLPTRH
5FF0  FFF7     NOP
5FF2  0008     TBLRD*
5FF4  50F5     MOVF TABLAT, W, ACCESS
5FF6  0900     IORLW 0x0
5FF8  A4D8     BTFSS STATUS, 2, ACCESS
5FFA  D7E4     BRA 0x5FC4
1378:              return nout;
5FFC  C0CF     MOVFF nout, fp
5FFE  F0AC     NOP
6000  C0D0     MOVFF 0xD0, 0xAD
6002  F0AD     NOP
1379:          #else
1380:              return fputs(fmt, fp);
1381:          #endif
1382:          }
6004  0012     RETURN 0
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/atoi.c  --------------------------------------------
1:             #include <stdlib.h>
2:             #include <ctype.h>
3:             
4:             int atoi(const char *s)
5:             {
6:             	int n=0, neg=0;
4B1E  0E00     MOVLW 0x0
4B20  6E2A     MOVWF aexp, ACCESS
4B22  0E00     MOVLW 0x0
4B24  6E29     MOVWF buf, ACCESS
4B26  0E00     MOVLW 0x0
4B28  6E23     MOVWF sep, ACCESS
4B2A  0E00     MOVLW 0x0
4B2C  6E22     MOVWF s, ACCESS
7:             	while (isspace(*s)) s++;
4B2E  D002     BRA 0x4B34
4B30  4A1C     INFSNZ c, F, ACCESS
4B32  2A1D     INCF divisor, F, ACCESS
4B34  0E01     MOVLW 0x1
4B36  6E28     MOVWF 0x28, ACCESS
4B38  C01C     MOVFF c, TBLPTR
4B3A  FFF6     NOP
4B3C  C01D     MOVFF divisor, TBLPTRH
4B3E  FFF7     NOP
4B40  0008     TBLRD*
4B42  50F5     MOVF TABLAT, W, ACCESS
4B44  0A20     XORLW 0x20
4B46  B4D8     BTFSC STATUS, 2, ACCESS
4B48  D018     BRA 0x4B7A
4B4A  0EF7     MOVLW 0xF7
4B4C  6E1E     MOVWF l, ACCESS
4B4E  0EFF     MOVLW 0xFF
4B50  6E1F     MOVWF i, ACCESS
4B52  C01C     MOVFF c, TBLPTR
4B54  FFF6     NOP
4B56  C01D     MOVFF divisor, TBLPTRH
4B58  FFF7     NOP
4B5A  0008     TBLRD*
4B5C  50F5     MOVF TABLAT, W, ACCESS
4B5E  6E20     MOVWF r, ACCESS
4B60  6A21     CLRF s, ACCESS
4B62  501E     MOVF l, W, ACCESS
4B64  2620     ADDWF r, F, ACCESS
4B66  501F     MOVF i, W, ACCESS
4B68  2221     ADDWFC s, F, ACCESS
4B6A  5021     MOVF s, W, ACCESS
4B6C  E104     BNZ 0x4B76
4B6E  0E05     MOVLW 0x5
4B70  5C20     SUBWF r, W, ACCESS
4B72  A0D8     BTFSS STATUS, 0, ACCESS
4B74  D002     BRA 0x4B7A
4B76  0E00     MOVLW 0x0
4B78  6E28     MOVWF 0x28, ACCESS
4B7A  C028     MOVFF 0x28, n
4B7C  F024     NOP
4B7E  6A25     CLRF quotient, ACCESS
4B80  5024     MOVF n, W, ACCESS
4B82  1025     IORWF quotient, W, ACCESS
4B84  B4D8     BTFSC STATUS, 2, ACCESS
4B86  D006     BRA 0x4B94
4B88  D7D3     BRA 0x4B30
8:             	switch (*s) {
9:             	case '-': neg=1;
4B8A  0E00     MOVLW 0x0
4B8C  6E23     MOVWF sep, ACCESS
4B8E  0E01     MOVLW 0x1
4B90  6E22     MOVWF s, ACCESS
10:            	case '+': s++;
4B92  D038     BRA 0x4C04
11:            	}
4B94  C01C     MOVFF c, TBLPTR
4B96  FFF6     NOP
4B98  C01D     MOVFF divisor, TBLPTRH
4B9A  FFF7     NOP
4B9C  0008     TBLRD*
4B9E  50F5     MOVF TABLAT, W, ACCESS
4BA0  6E1E     MOVWF l, ACCESS
4BA2  6A1F     CLRF i, ACCESS
4BA4  501F     MOVF i, W, ACCESS
4BA6  0A00     XORLW 0x0
4BA8  A4D8     BTFSS STATUS, 2, ACCESS
4BAA  D02E     BRA 0x4C08
4BAC  501E     MOVF l, W, ACCESS
4BAE  0A2B     XORLW 0x2B
4BB0  B4D8     BTFSC STATUS, 2, ACCESS
4BB2  D028     BRA 0x4C04
4BB4  0A06     XORLW 0x6
4BB6  B4D8     BTFSC STATUS, 2, ACCESS
4BB8  D7E8     BRA 0x4B8A
12:            	/* Compute n as a negative number to avoid overflow on INT_MIN */
13:            	while (isdigit(*s))
4BBA  D026     BRA 0x4C08
4C08  0ED0     MOVLW 0xD0
4C0A  6E1E     MOVWF l, ACCESS
4C0C  0EFF     MOVLW 0xFF
4C0E  6E1F     MOVWF i, ACCESS
4C10  C01C     MOVFF c, TBLPTR
4C12  FFF6     NOP
4C14  C01D     MOVFF divisor, TBLPTRH
4C16  FFF7     NOP
4C18  0008     TBLRD*
4C1A  50F5     MOVF TABLAT, W, ACCESS
4C1C  6E20     MOVWF r, ACCESS
4C1E  6A21     CLRF s, ACCESS
4C20  501E     MOVF l, W, ACCESS
4C22  2620     ADDWF r, F, ACCESS
4C24  501F     MOVF i, W, ACCESS
4C26  2221     ADDWFC s, F, ACCESS
4C28  5021     MOVF s, W, ACCESS
4C2A  E106     BNZ 0x4C38
4C2C  0E0A     MOVLW 0xA
4C2E  5C20     SUBWF r, W, ACCESS
4C30  B0D8     BTFSC STATUS, 0, ACCESS
4C32  D002     BRA 0x4C38
4C34  0E01     MOVLW 0x1
4C36  D001     BRA 0x4C3A
4C38  0E00     MOVLW 0x0
4C3A  6E26     MOVWF sign, ACCESS
4C3C  6A27     CLRF quotient, ACCESS
4C3E  5026     MOVF sign, W, ACCESS
4C40  1027     IORWF quotient, W, ACCESS
4C42  A4D8     BTFSS STATUS, 2, ACCESS
4C44  D7BB     BRA 0x4BBC
14:            		n = 10*n - (*s++ - '0');
4BBC  0ED0     MOVLW 0xD0
4BBE  6E1E     MOVWF l, ACCESS
4BC0  0EFF     MOVLW 0xFF
4BC2  6E1F     MOVWF i, ACCESS
4BC4  C01C     MOVFF c, TBLPTR
4BC6  FFF6     NOP
4BC8  C01D     MOVFF divisor, TBLPTRH
4BCA  FFF7     NOP
4BCC  0008     TBLRD*
4BCE  50F5     MOVF TABLAT, W, ACCESS
4BD0  6E20     MOVWF r, ACCESS
4BD2  6A21     CLRF s, ACCESS
4BD4  501E     MOVF l, W, ACCESS
4BD6  2620     ADDWF r, F, ACCESS
4BD8  501F     MOVF i, W, ACCESS
4BDA  2221     ADDWFC s, F, ACCESS
4BDC  1E20     COMF r, F, ACCESS
4BDE  1E21     COMF s, F, ACCESS
4BE0  4A20     INFSNZ r, F, ACCESS
4BE2  2A21     INCF s, F, ACCESS
4BE4  C029     MOVFF buf, dividend
4BE6  F015     NOP
4BE8  C02A     MOVFF aexp, Message
4BEA  F016     NOP
4BEC  0E00     MOVLW 0x0
4BEE  6E18     MOVWF 0x18, ACCESS
4BF0  0E0A     MOVLW 0xA
4BF2  6E17     MOVWF _r, ACCESS
4BF4  EC57     CALL 0x68AE, 0
4BF6  F034     NOP
4BF8  5020     MOVF r, W, ACCESS
4BFA  2415     ADDWF dividend, W, ACCESS
4BFC  6E29     MOVWF buf, ACCESS
4BFE  5021     MOVF s, W, ACCESS
4C00  2016     ADDWFC Message, W, ACCESS
4C02  6E2A     MOVWF aexp, ACCESS
4C04  4A1C     INFSNZ c, F, ACCESS
4C06  2A1D     INCF divisor, F, ACCESS
15:            	return neg ? n : -n;
4C46  5022     MOVF s, W, ACCESS
4C48  1023     IORWF sep, W, ACCESS
4C4A  A4D8     BTFSS STATUS, 2, ACCESS
4C4C  D00D     BRA 0x4C68
4C4E  C029     MOVFF buf, l
4C50  F01E     NOP
4C52  C02A     MOVFF aexp, i
4C54  F01F     NOP
4C56  1E1E     COMF l, F, ACCESS
4C58  1E1F     COMF i, F, ACCESS
4C5A  4A1E     INFSNZ l, F, ACCESS
4C5C  2A1F     INCF i, F, ACCESS
4C5E  C01E     MOVFF l, c
4C60  F01C     NOP
4C62  C01F     MOVFF i, divisor
4C64  F01D     NOP
4C66  0012     RETURN 0
4C68  C029     MOVFF buf, c
4C6A  F01C     NOP
4C6C  C02A     MOVFF aexp, divisor
4C6E  F01D     NOP
4C70  0012     RETURN 0
16:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/aomod.c  -------------------------------------------
1:             // long long signed unsigned modulus
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aomod(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aomod(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	unsigned char	counter, sign;
13:            
14:            	sign = 0;
5164  0E00     MOVLW 0x0
5166  6E26     MOVWF sign, ACCESS
15:            	if(dividend < 0) {
5168  AE1C     BTFSS c, 7, ACCESS
516A  D012     BRA 0x5190
16:            		dividend = -dividend;
516C  1E1C     COMF c, F, ACCESS
516E  1E1B     COMF c, F, ACCESS
5170  1E1A     COMF s, F, ACCESS
5172  1E19     COMF multiplicand, F, ACCESS
5174  1E18     COMF 0x18, F, ACCESS
5176  1E17     COMF _r, F, ACCESS
5178  1E16     COMF Message, F, ACCESS
517A  6C15     NEGF dividend, ACCESS
517C  0E00     MOVLW 0x0
517E  2216     ADDWFC Message, F, ACCESS
5180  2217     ADDWFC _r, F, ACCESS
5182  2218     ADDWFC 0x18, F, ACCESS
5184  2219     ADDWFC multiplicand, F, ACCESS
5186  221A     ADDWFC s, F, ACCESS
5188  221B     ADDWFC c, F, ACCESS
518A  221C     ADDWFC c, F, ACCESS
17:            		sign = 1;
518C  0E01     MOVLW 0x1
518E  6E26     MOVWF sign, ACCESS
18:            	}
19:            	if(divisor < 0)
5190  AE24     BTFSS n, 7, ACCESS
5192  D010     BRA 0x51B4
20:            		divisor = -divisor;
5194  1E24     COMF n, F, ACCESS
5196  1E23     COMF sep, F, ACCESS
5198  1E22     COMF s, F, ACCESS
519A  1E21     COMF s, F, ACCESS
519C  1E20     COMF r, F, ACCESS
519E  1E1F     COMF i, F, ACCESS
51A0  1E1E     COMF l, F, ACCESS
51A2  6C1D     NEGF divisor, ACCESS
51A4  0E00     MOVLW 0x0
51A6  221E     ADDWFC l, F, ACCESS
51A8  221F     ADDWFC i, F, ACCESS
51AA  2220     ADDWFC r, F, ACCESS
51AC  2221     ADDWFC s, F, ACCESS
51AE  2222     ADDWFC s, F, ACCESS
51B0  2223     ADDWFC sep, F, ACCESS
51B2  2224     ADDWFC n, F, ACCESS
21:            	if(divisor != 0) {
51B4  501D     MOVF divisor, W, ACCESS
51B6  101E     IORWF l, W, ACCESS
51B8  101F     IORWF i, W, ACCESS
51BA  1020     IORWF r, W, ACCESS
51BC  1021     IORWF s, W, ACCESS
51BE  1022     IORWF s, W, ACCESS
51C0  1023     IORWF sep, W, ACCESS
51C2  1024     IORWF n, W, ACCESS
51C4  B4D8     BTFSC STATUS, 2, ACCESS
51C6  D03C     BRA 0x5240
22:            		counter = 1;
51C8  0E01     MOVLW 0x1
51CA  6E25     MOVWF quotient, ACCESS
23:            		while((divisor & 0x8000000000000000ULL) == 0) {
51CC  D00A     BRA 0x51E2
24:            			divisor <<= 1;
51CE  90D8     BCF STATUS, 0, ACCESS
51D0  361D     RLCF divisor, F, ACCESS
51D2  361E     RLCF l, F, ACCESS
51D4  361F     RLCF i, F, ACCESS
51D6  3620     RLCF r, F, ACCESS
51D8  3621     RLCF s, F, ACCESS
51DA  3622     RLCF s, F, ACCESS
51DC  3623     RLCF sep, F, ACCESS
51DE  3624     RLCF n, F, ACCESS
25:            			counter++;
51E0  2A25     INCF quotient, F, ACCESS
26:            		}
51E2  AE24     BTFSS n, 7, ACCESS
51E4  D7F4     BRA 0x51CE
27:            		do {
28:            			if((unsigned long long)divisor <= (unsigned long long)dividend)
51E6  501D     MOVF divisor, W, ACCESS
51E8  5C15     SUBWF dividend, W, ACCESS
51EA  501E     MOVF l, W, ACCESS
51EC  5816     SUBWFB Message, W, ACCESS
51EE  501F     MOVF i, W, ACCESS
51F0  5817     SUBWFB _r, W, ACCESS
51F2  5020     MOVF r, W, ACCESS
51F4  5818     SUBWFB 0x18, W, ACCESS
51F6  5021     MOVF s, W, ACCESS
51F8  5819     SUBWFB multiplicand, W, ACCESS
51FA  5022     MOVF s, W, ACCESS
51FC  581A     SUBWFB s, W, ACCESS
51FE  5023     MOVF sep, W, ACCESS
5200  581B     SUBWFB c, W, ACCESS
5202  5024     MOVF n, W, ACCESS
5204  581C     SUBWFB c, W, ACCESS
5206  A0D8     BTFSS STATUS, 0, ACCESS
5208  D010     BRA 0x522A
29:            				dividend -= divisor;
520A  501D     MOVF divisor, W, ACCESS
520C  5E15     SUBWF dividend, F, ACCESS
520E  501E     MOVF l, W, ACCESS
5210  5A16     SUBWFB Message, F, ACCESS
5212  501F     MOVF i, W, ACCESS
5214  5A17     SUBWFB _r, F, ACCESS
5216  5020     MOVF r, W, ACCESS
5218  5A18     SUBWFB 0x18, F, ACCESS
521A  5021     MOVF s, W, ACCESS
521C  5A19     SUBWFB multiplicand, F, ACCESS
521E  5022     MOVF s, W, ACCESS
5220  5A1A     SUBWFB s, F, ACCESS
5222  5023     MOVF sep, W, ACCESS
5224  5A1B     SUBWFB c, F, ACCESS
5226  5024     MOVF n, W, ACCESS
5228  5A1C     SUBWFB c, F, ACCESS
30:            			*(unsigned long long int *)&divisor >>= 1;
522A  90D8     BCF STATUS, 0, ACCESS
522C  3224     RRCF n, F, ACCESS
522E  3223     RRCF sep, F, ACCESS
5230  3222     RRCF s, F, ACCESS
5232  3221     RRCF s, F, ACCESS
5234  3220     RRCF r, F, ACCESS
5236  321F     RRCF i, F, ACCESS
5238  321E     RRCF l, F, ACCESS
523A  321D     RRCF divisor, F, ACCESS
31:            		} while(--counter != 0);
523C  2E25     DECFSZ quotient, F, ACCESS
523E  D7D3     BRA 0x51E6
32:            	}
33:            	if(sign)
5240  5026     MOVF sign, W, ACCESS
5242  B4D8     BTFSC STATUS, 2, ACCESS
5244  D010     BRA 0x5266
34:            		dividend = -dividend;
5246  1E1C     COMF c, F, ACCESS
5248  1E1B     COMF c, F, ACCESS
524A  1E1A     COMF s, F, ACCESS
524C  1E19     COMF multiplicand, F, ACCESS
524E  1E18     COMF 0x18, F, ACCESS
5250  1E17     COMF _r, F, ACCESS
5252  1E16     COMF Message, F, ACCESS
5254  6C15     NEGF dividend, ACCESS
5256  0E00     MOVLW 0x0
5258  2216     ADDWFC Message, F, ACCESS
525A  2217     ADDWFC _r, F, ACCESS
525C  2218     ADDWFC 0x18, F, ACCESS
525E  2219     ADDWFC multiplicand, F, ACCESS
5260  221A     ADDWFC s, F, ACCESS
5262  221B     ADDWFC c, F, ACCESS
5264  221C     ADDWFC c, F, ACCESS
35:            	return dividend;
5266  C015     MOVFF dividend, dividend
5268  F015     NOP
526A  C016     MOVFF Message, Message
526C  F016     NOP
526E  C017     MOVFF _r, _r
5270  F017     NOP
5272  C018     MOVFF 0x18, 0x18
5274  F018     NOP
5276  C019     MOVFF multiplicand, multiplicand
5278  F019     NOP
527A  C01A     MOVFF s, s
527C  F01A     NOP
527E  C01B     MOVFF c, c
5280  F01B     NOP
5282  C01C     MOVFF c, c
5284  F01C     NOP
5286  0012     RETURN 0
36:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/aodiv.c  -------------------------------------------
1:             // long long signed unsigned division
2:             
3:             #pragma warning disable 1516
4:             
5:             signed long long int
6:             #ifdef __PICC__
7:             __aodiv(signed long long int divisor, signed long long int dividend)
8:             #else
9:             __aodiv(signed long long int dividend, signed long long int divisor)
10:            #endif
11:            {
12:            	signed long long int	quotient;
13:            	unsigned char	counter, sign;
14:            
15:            	sign = 0;
4C72  0E00     MOVLW 0x0
4C74  6E26     MOVWF sign, ACCESS
16:            	if(divisor < 0) {
4C76  AE24     BTFSS n, 7, ACCESS
4C78  D012     BRA 0x4C9E
17:            		divisor = -divisor;
4C7A  1E24     COMF n, F, ACCESS
4C7C  1E23     COMF sep, F, ACCESS
4C7E  1E22     COMF s, F, ACCESS
4C80  1E21     COMF s, F, ACCESS
4C82  1E20     COMF r, F, ACCESS
4C84  1E1F     COMF i, F, ACCESS
4C86  1E1E     COMF l, F, ACCESS
4C88  6C1D     NEGF divisor, ACCESS
4C8A  0E00     MOVLW 0x0
4C8C  221E     ADDWFC l, F, ACCESS
4C8E  221F     ADDWFC i, F, ACCESS
4C90  2220     ADDWFC r, F, ACCESS
4C92  2221     ADDWFC s, F, ACCESS
4C94  2222     ADDWFC s, F, ACCESS
4C96  2223     ADDWFC sep, F, ACCESS
4C98  2224     ADDWFC n, F, ACCESS
18:            		sign = 1;
4C9A  0E01     MOVLW 0x1
4C9C  6E26     MOVWF sign, ACCESS
19:            	}
20:            	if(dividend < 0) {
4C9E  AE1C     BTFSS c, 7, ACCESS
4CA0  D012     BRA 0x4CC6
21:            		dividend = -dividend;
4CA2  1E1C     COMF c, F, ACCESS
4CA4  1E1B     COMF c, F, ACCESS
4CA6  1E1A     COMF s, F, ACCESS
4CA8  1E19     COMF multiplicand, F, ACCESS
4CAA  1E18     COMF 0x18, F, ACCESS
4CAC  1E17     COMF _r, F, ACCESS
4CAE  1E16     COMF Message, F, ACCESS
4CB0  6C15     NEGF dividend, ACCESS
4CB2  0E00     MOVLW 0x0
4CB4  2216     ADDWFC Message, F, ACCESS
4CB6  2217     ADDWFC _r, F, ACCESS
4CB8  2218     ADDWFC 0x18, F, ACCESS
4CBA  2219     ADDWFC multiplicand, F, ACCESS
4CBC  221A     ADDWFC s, F, ACCESS
4CBE  221B     ADDWFC c, F, ACCESS
4CC0  221C     ADDWFC c, F, ACCESS
22:            		sign ^= 1;
4CC2  0E01     MOVLW 0x1
4CC4  1A26     XORWF sign, F, ACCESS
23:            	}
24:            	quotient = 0;
4CC6  EE20     LFSR 2, 0x27
4CC8  F027     NOP
4CCA  0E07     MOVLW 0x7
4CCC  6ADE     CLRF POSTINC2, ACCESS
4CCE  06E8     DECF WREG, F, ACCESS
4CD0  E2FD     BC 0x4CCC
25:            	if(divisor != 0) {
4CD2  501D     MOVF divisor, W, ACCESS
4CD4  101E     IORWF l, W, ACCESS
4CD6  101F     IORWF i, W, ACCESS
4CD8  1020     IORWF r, W, ACCESS
4CDA  1021     IORWF s, W, ACCESS
4CDC  1022     IORWF s, W, ACCESS
4CDE  1023     IORWF sep, W, ACCESS
4CE0  1024     IORWF n, W, ACCESS
4CE2  B4D8     BTFSC STATUS, 2, ACCESS
4CE4  D046     BRA 0x4D72
26:            		counter = 1;
4CE6  0E01     MOVLW 0x1
4CE8  6E25     MOVWF quotient, ACCESS
27:            		while((divisor & 0x8000000000000000ULL) == 0) {
4CEA  D00A     BRA 0x4D00
28:            			divisor <<= 1;
4CEC  90D8     BCF STATUS, 0, ACCESS
4CEE  361D     RLCF divisor, F, ACCESS
4CF0  361E     RLCF l, F, ACCESS
4CF2  361F     RLCF i, F, ACCESS
4CF4  3620     RLCF r, F, ACCESS
4CF6  3621     RLCF s, F, ACCESS
4CF8  3622     RLCF s, F, ACCESS
4CFA  3623     RLCF sep, F, ACCESS
4CFC  3624     RLCF n, F, ACCESS
29:            			counter++;
4CFE  2A25     INCF quotient, F, ACCESS
30:            		}
4D00  AE24     BTFSS n, 7, ACCESS
4D02  D7F4     BRA 0x4CEC
31:            		do {
32:            			quotient <<= 1;
4D04  90D8     BCF STATUS, 0, ACCESS
4D06  3627     RLCF quotient, F, ACCESS
4D08  3628     RLCF 0x28, F, ACCESS
4D0A  3629     RLCF buf, F, ACCESS
4D0C  362A     RLCF aexp, F, ACCESS
4D0E  362B     RLCF p, F, ACCESS
4D10  362C     RLCF i, F, ACCESS
4D12  362D     RLCF counter, F, ACCESS
4D14  362E     RLCF w, F, ACCESS
33:            			if((unsigned long long)divisor <= (unsigned long long)dividend) {
4D16  501D     MOVF divisor, W, ACCESS
4D18  5C15     SUBWF dividend, W, ACCESS
4D1A  501E     MOVF l, W, ACCESS
4D1C  5816     SUBWFB Message, W, ACCESS
4D1E  501F     MOVF i, W, ACCESS
4D20  5817     SUBWFB _r, W, ACCESS
4D22  5020     MOVF r, W, ACCESS
4D24  5818     SUBWFB 0x18, W, ACCESS
4D26  5021     MOVF s, W, ACCESS
4D28  5819     SUBWFB multiplicand, W, ACCESS
4D2A  5022     MOVF s, W, ACCESS
4D2C  581A     SUBWFB s, W, ACCESS
4D2E  5023     MOVF sep, W, ACCESS
4D30  581B     SUBWFB c, W, ACCESS
4D32  5024     MOVF n, W, ACCESS
4D34  581C     SUBWFB c, W, ACCESS
4D36  A0D8     BTFSS STATUS, 0, ACCESS
4D38  D011     BRA 0x4D5C
34:            				dividend -= divisor;
4D3A  501D     MOVF divisor, W, ACCESS
4D3C  5E15     SUBWF dividend, F, ACCESS
4D3E  501E     MOVF l, W, ACCESS
4D40  5A16     SUBWFB Message, F, ACCESS
4D42  501F     MOVF i, W, ACCESS
4D44  5A17     SUBWFB _r, F, ACCESS
4D46  5020     MOVF r, W, ACCESS
4D48  5A18     SUBWFB 0x18, F, ACCESS
4D4A  5021     MOVF s, W, ACCESS
4D4C  5A19     SUBWFB multiplicand, F, ACCESS
4D4E  5022     MOVF s, W, ACCESS
4D50  5A1A     SUBWFB s, F, ACCESS
4D52  5023     MOVF sep, W, ACCESS
4D54  5A1B     SUBWFB c, F, ACCESS
4D56  5024     MOVF n, W, ACCESS
4D58  5A1C     SUBWFB c, F, ACCESS
35:            				quotient |= 1;
4D5A  8027     BSF quotient, 0, ACCESS
36:            			}
37:            			*(unsigned long long int *)&divisor >>= 1;
4D5C  90D8     BCF STATUS, 0, ACCESS
4D5E  3224     RRCF n, F, ACCESS
4D60  3223     RRCF sep, F, ACCESS
4D62  3222     RRCF s, F, ACCESS
4D64  3221     RRCF s, F, ACCESS
4D66  3220     RRCF r, F, ACCESS
4D68  321F     RRCF i, F, ACCESS
4D6A  321E     RRCF l, F, ACCESS
4D6C  321D     RRCF divisor, F, ACCESS
38:            		} while(--counter != 0);
4D6E  2E25     DECFSZ quotient, F, ACCESS
4D70  D7C9     BRA 0x4D04
39:            	}
40:            	if(sign)
4D72  5026     MOVF sign, W, ACCESS
4D74  B4D8     BTFSC STATUS, 2, ACCESS
4D76  D010     BRA 0x4D98
41:            		quotient = -quotient;
4D78  1E2E     COMF w, F, ACCESS
4D7A  1E2D     COMF counter, F, ACCESS
4D7C  1E2C     COMF i, F, ACCESS
4D7E  1E2B     COMF p, F, ACCESS
4D80  1E2A     COMF aexp, F, ACCESS
4D82  1E29     COMF buf, F, ACCESS
4D84  1E28     COMF 0x28, F, ACCESS
4D86  6C27     NEGF quotient, ACCESS
4D88  0E00     MOVLW 0x0
4D8A  2228     ADDWFC 0x28, F, ACCESS
4D8C  2229     ADDWFC buf, F, ACCESS
4D8E  222A     ADDWFC aexp, F, ACCESS
4D90  222B     ADDWFC p, F, ACCESS
4D92  222C     ADDWFC i, F, ACCESS
4D94  222D     ADDWFC counter, F, ACCESS
4D96  222E     ADDWFC w, F, ACCESS
42:            	return quotient;
4D98  C027     MOVFF quotient, dividend
4D9A  F015     NOP
4D9C  C028     MOVFF 0x28, Message
4D9E  F016     NOP
4DA0  C029     MOVFF buf, _r
4DA2  F017     NOP
4DA4  C02A     MOVFF aexp, 0x18
4DA6  F018     NOP
4DA8  C02B     MOVFF p, multiplicand
4DAA  F019     NOP
4DAC  C02C     MOVFF i, s
4DAE  F01A     NOP
4DB0  C02D     MOVFF counter, c
4DB2  F01B     NOP
4DB4  C02E     MOVFF w, c
4DB6  F01C     NOP
4DB8  0012     RETURN 0
43:            }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/abs.c  ---------------------------------------------
1:             int abs(int a)
2:             {
3:             	return a>0 ? a : -a;
65D4  BE28     BTFSC 0x28, 7, ACCESS
65D6  D005     BRA 0x65E2
65D8  5028     MOVF 0x28, W, ACCESS
65DA  E110     BNZ 0x65FC
65DC  0427     DECF quotient, W, ACCESS
65DE  B0D8     BTFSC STATUS, 0, ACCESS
65E0  D00D     BRA 0x65FC
65E2  C027     MOVFF quotient, buf
65E4  F029     NOP
65E6  C028     MOVFF 0x28, aexp
65E8  F02A     NOP
65EA  1E29     COMF buf, F, ACCESS
65EC  1E2A     COMF aexp, F, ACCESS
65EE  4A29     INFSNZ buf, F, ACCESS
65F0  2A2A     INCF aexp, F, ACCESS
65F2  C029     MOVFF buf, quotient
65F4  F027     NOP
65F6  C02A     MOVFF aexp, 0x28
65F8  F028     NOP
65FA  0012     RETURN 0
65FC  C027     MOVFF quotient, quotient
65FE  F027     NOP
6600  C028     MOVFF 0x28, 0x28
6602  F028     NOP
6604  0012     RETURN 0
4:             }
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/Umul32.c  ------------------------------------------
1:             // 32 x 32 bit multiplication with 32 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned long
15:            __lmul(unsigned long multiplier, unsigned long multiplicand)
16:            {
17:            	unsigned long product;
18:            
19:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
20:            #define LMIDBYTE(x) (*(((unsigned char *)(&x))+1))
21:            #define HMIDBYTE(x) (*(((unsigned char *)(&x))+2))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+3))
23:            
24:            #if (_Has_hardware_multiply || _Has_large_call_stack) && defined(__OPTIMIZE_SPEED__)
25:            	{
26:            
27:            #define USE_SHRINK
28:            
29:            /*
30:            a 32-bit multiply can be decomposed into the sum of ten 8-bit multiplies
31:                         a  b  c  d
32:            *            e  f  g  h
33:            -----------------------
34:                       |         dh
35:                       |      ch  0
36:                       |   bh  0  0
37:                       |ah  0  0  0
38:                       |      dg  0
39:                       |   cg  0  0
40:                       |bg  0  0  0
41:                     ag| 0  0  0  0 (we ignore this intermediate product
42:                                     because it does not affect the low 32 bits of the result)
43:                       |   df  0  0
44:                       |cf  0  0  0
45:                     bf| 0  0  0  0 (ignore)
46:                  af  0| 0  0  0  0 (ignore)
47:                       |de  0  0  0
48:                     ce| 0  0  0  0 (ignore)
49:                  be  0| 0  0  0  0 (ignore)
50:            +  ae  0  0| 0  0  0  0 (ignore)
51:            =======================
52:             */
53:            		product =  (unsigned int)LOWBYTE(multiplier) * LOWBYTE(multiplicand);
54:            
55:            #if defined(USE_MASKS)
56:            		product += ((unsigned long)
57:            			     ((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand))
58:            			     +
59:            			     ((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
60:            			<< 8;
61:            
62:            		product += ((unsigned long)
63:            			    ((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand))
64:            			    +
65:            			    ((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
66:            			    +
67:            			    ((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand)))
68:            			<< 16;
69:            
70:            		/* cast to smaller type to avoid adding high bits just to discard */
71:            		product += ((unsigned long)
72:            			    (unsigned char)
73:            			    ((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand))
74:            			    +
75:            			    (unsigned char)
76:            			    ((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand))
77:            			    +
78:            			    (unsigned char)
79:            			    ((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand))
80:            			    +
81:            			    (unsigned char)
82:            			    ((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand)))
83:            			<< 24;
84:            
85:            #elif defined(USE_SHRINK)
86:            		/* add direct to upper bytes, rather than shift and add all bytes */
87:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
88:            			((unsigned int)LOWBYTE(multiplier) * LMIDBYTE(multiplicand));
89:            		*((__uint24 *)(((unsigned char*)&product)+1)) +=
90:            			((unsigned int)LMIDBYTE(multiplier) * LOWBYTE(multiplicand));
91:            
92:            
93:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
94:            			((unsigned int)LOWBYTE(multiplier) * HMIDBYTE(multiplicand));
95:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
96:            			((unsigned int)LMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
97:            		*((unsigned int*)(((unsigned char*)&product)+2)) +=
98:            			((unsigned int)HMIDBYTE(multiplier) * LOWBYTE(multiplicand));
99:            
100:           		*(((unsigned char*)&product)+3) +=
101:           			(unsigned char)
102:           			((unsigned int)LOWBYTE(multiplier) * HIGHBYTE(multiplicand));
103:           		*(((unsigned char*)&product)+3) +=
104:           			(unsigned char)
105:           			((unsigned int)LMIDBYTE(multiplier) * HMIDBYTE(multiplicand));
106:           		*(((unsigned char*)&product)+3) +=
107:           			(unsigned char)
108:           			((unsigned int)HMIDBYTE(multiplier) * LMIDBYTE(multiplicand));
109:           		*(((unsigned char*)&product)+3) +=
110:           			(unsigned char)
111:           			((unsigned int)HIGHBYTE(multiplier) * LOWBYTE(multiplicand));
112:           
113:           #else
114:           #error No method chosen
115:           #endif
116:           	}
117:           #else
118:           
119:           	product = 0;
5F5A  0E00     MOVLW 0x0
5F5C  6E1D     MOVWF divisor, ACCESS
5F5E  0E00     MOVLW 0x0
5F60  6E1E     MOVWF l, ACCESS
5F62  0E00     MOVLW 0x0
5F64  6E1F     MOVWF i, ACCESS
5F66  0E00     MOVLW 0x0
5F68  6E20     MOVWF r, ACCESS
120:           	do {
121:           		if(multiplier & 1)
5F6A  A015     BTFSS dividend, 0, ACCESS
5F6C  D008     BRA 0x5F7E
122:           			product += multiplicand;
5F6E  5019     MOVF multiplicand, W, ACCESS
5F70  261D     ADDWF divisor, F, ACCESS
5F72  501A     MOVF s, W, ACCESS
5F74  221E     ADDWFC l, F, ACCESS
5F76  501B     MOVF c, W, ACCESS
5F78  221F     ADDWFC i, F, ACCESS
5F7A  501C     MOVF c, W, ACCESS
5F7C  2220     ADDWFC r, F, ACCESS
123:           		multiplicand <<= 1;
5F7E  90D8     BCF STATUS, 0, ACCESS
5F80  3619     RLCF multiplicand, F, ACCESS
5F82  361A     RLCF s, F, ACCESS
5F84  361B     RLCF c, F, ACCESS
5F86  361C     RLCF c, F, ACCESS
124:           		multiplier >>= 1;
5F88  90D8     BCF STATUS, 0, ACCESS
5F8A  3218     RRCF 0x18, F, ACCESS
5F8C  3217     RRCF _r, F, ACCESS
5F8E  3216     RRCF Message, F, ACCESS
5F90  3215     RRCF dividend, F, ACCESS
125:           	} while(multiplier != 0);
5F92  5015     MOVF dividend, W, ACCESS
5F94  1016     IORWF Message, W, ACCESS
5F96  1017     IORWF _r, W, ACCESS
5F98  1018     IORWF 0x18, W, ACCESS
5F9A  A4D8     BTFSS STATUS, 2, ACCESS
5F9C  D7E6     BRA 0x5F6A
126:           
127:           #endif
128:           	return product;
5F9E  C01D     MOVFF divisor, dividend
5FA0  F015     NOP
5FA2  C01E     MOVFF l, Message
5FA4  F016     NOP
5FA6  C01F     MOVFF i, _r
5FA8  F017     NOP
5FAA  C020     MOVFF r, 0x18
5FAC  F018     NOP
129:           }
5FAE  0012     RETURN 0
---  /opt/microchip/xc8/v2.00/pic/sources/c99/common/Umul16.c  ------------------------------------------
1:             // 16 x 16 bit multiplication with 16 bit result
2:             #ifdef _PIC18
3:             #define _Has_hardware_multiply 1
4:             #else
5:             #define _Has_hardware_multiply 0
6:             #endif
7:             
8:             #if defined(_PIC14E) || defined(_PIC14EX) || defined(_PIC18)
9:             #define _Has_large_call_stack 1
10:            #else
11:            #define _Has_large_call_stack 0
12:            #endif
13:            
14:            unsigned int
15:            __wmul(unsigned int multiplier, unsigned int multiplicand)
16:            {
17:                    unsigned int product;
18:            
19:            #if _Has_hardware_multiply || _Has_large_call_stack
20:            
21:            #define LOWBYTE(x)  (*(unsigned char *)(&x))
22:            #define HIGHBYTE(x) (*(((unsigned char *)(&x))+1))
23:            
24:            	// optimized to allow use of the 8 x 8 bit hardware multiply instruction
25:            /*
26:            a 16-bit multiply can be decomposed into the sum of three 8-bit multiplies
27:                   a  b
28:            *      c  d
29:            -----------
30:                 |   bd
31:                 |ad  0
32:                 |bc  0
33:            +  ac| 0  0 (we ignore this intermediate product
34:                         because it does not affect the low 16 bits of the result)
35:            ===========
36:             */
37:                    product =  LOWBYTE(multiplier) * LOWBYTE(multiplicand);
68AE  5015     MOVF dividend, W, ACCESS
68B0  0217     MULWF _r, ACCESS
68B2  CFF3     MOVFF PROD, multiplicand
68B4  F019     NOP
68B6  CFF4     MOVFF PRODH, s
68B8  F01A     NOP
38:                    product += (LOWBYTE(multiplier) * HIGHBYTE(multiplicand)) << 8;
68BA  5015     MOVF dividend, W, ACCESS
68BC  0218     MULWF 0x18, ACCESS
68BE  50F3     MOVF PROD, W, ACCESS
68C0  261A     ADDWF s, F, ACCESS
39:                    product += (HIGHBYTE(multiplier) * LOWBYTE(multiplicand)) << 8;
68C2  5016     MOVF Message, W, ACCESS
68C4  0217     MULWF _r, ACCESS
68C6  50F3     MOVF PROD, W, ACCESS
68C8  261A     ADDWF s, F, ACCESS
40:            
41:            #else
42:            
43:            	product = 0;
44:            	do {
45:            		if(multiplier & 1)
46:            			product += multiplicand;
47:            		multiplicand <<= 1;
48:            		multiplier >>= 1;
49:            	} while(multiplier != 0);
50:            
51:            #endif
52:                    return product;
68CA  C019     MOVFF multiplicand, dividend
68CC  F015     NOP
68CE  C01A     MOVFF s, Message
68D0  F016     NOP
68D2  0012     RETURN 0
53:            }
---  /fred/mphase_v80/mphase.X/timers.c  ----------------------------------------------------------------
1:             #include <xc.h>
2:             #include <stdint.h>
3:             #include <stdbool.h>
4:             #include "config.h"
5:             #include "timers.h"
6:             #include "app.h"
7:             
8:             extern APP_DATA appData;
9:             
10:            static volatile uint16_t tickCount[TMR_COUNT] = {0};
11:            
12:            //**********************************************************************************************************************
13:            // Start one of the software timers
14:            
15:            inline void StartTimer(uint8_t timer, uint16_t count)
6836  6E19     MOVWF multiplicand, ACCESS
16:            {
17:            	tickCount[timer] = count << 1; //Interrupt is every 500us but StartTimer() takes multiple of 1ms so multiply by 2
6838  C015     MOVFF dividend, _r
683A  F017     NOP
683C  C016     MOVFF Message, 0x18
683E  F018     NOP
6840  90D8     BCF STATUS, 0, ACCESS
6842  3617     RLCF _r, F, ACCESS
6844  3618     RLCF 0x18, F, ACCESS
6846  5019     MOVF multiplicand, W, ACCESS
6848  0D02     MULLW 0x2
684A  0E00     MOVLW 0x0
684C  24F3     ADDWF PROD, W, ACCESS
684E  6ED9     MOVWF FSR2, ACCESS
6850  0E01     MOVLW 0x1
6852  20F4     ADDWFC PRODH, W, ACCESS
6854  6EDA     MOVWF FSR2H, ACCESS
6856  C017     MOVFF _r, POSTINC2
6858  FFDE     NOP
685A  C018     MOVFF 0x18, POSTDEC2
685C  FFDD     NOP
18:            }
685E  0012     RETURN 0
19:            
20:            //**********************************************************************************************************************
21:            // Check if one of the software software timers has timed out
22:            
23:            inline bool TimerDone(uint8_t timer)
6986  6E17     MOVWF _r, ACCESS
24:            {
25:            	if (tickCount[timer] == 0) { //Check if counted down to zero
6988  5017     MOVF _r, W, ACCESS
698A  0D02     MULLW 0x2
698C  0E00     MOVLW 0x0
698E  24F3     ADDWF PROD, W, ACCESS
6990  6ED9     MOVWF FSR2, ACCESS
6992  0E01     MOVLW 0x1
6994  20F4     ADDWFC PRODH, W, ACCESS
6996  6EDA     MOVWF FSR2H, ACCESS
6998  50DE     MOVF POSTINC2, W, ACCESS
699A  10DE     IORWF POSTINC2, W, ACCESS
699C  A4D8     BTFSS STATUS, 2, ACCESS
699E  D002     BRA 0x69A4
26:            		return true; //then return true
69A0  0E01     MOVLW 0x1
69A2  0012     RETURN 0
27:            	}
28:            	return false; //else return false
69A4  0E00     MOVLW 0x0
69A6  0012     RETURN 0
29:            }
30:            
31:            //**********************************************************************************************************************
32:            // Simple delay for n milliseconds (blocking)
33:            
34:            void WaitMs(uint16_t numMilliseconds)
35:            {
36:            	StartTimer(TMR_INTERNAL, numMilliseconds); //Start software timer and wait for it to count down
6A4E  C01A     MOVFF s, dividend
6A50  F015     NOP
6A52  C01B     MOVFF c, Message
6A54  F016     NOP
6A56  0E00     MOVLW 0x0
6A58  EC1B     CALL 0x6836, 0
6A5A  F034     NOP
37:            	while (!TimerDone(TMR_INTERNAL)) {
6A5C  0E00     MOVLW 0x0
6A5E  ECC3     CALL 0x6986, 0
6A60  F034     NOP
6A62  0900     IORLW 0x0
6A64  A4D8     BTFSS STATUS, 2, ACCESS
6A66  0012     RETURN 0
6A68  D7F9     BRA 0x6A5C
38:            		//		Idle();
39:            	} //Enter idle mode to reduce power while waiting
40:            } //(timer interrupt will wake part from idle)
41:            
42:            //**********************************************************************************************************************
43:            // Timer 1 interrupt routine - software timers
44:            
45:            void _T1Interrupt(void)
46:            {
47:            	uint8_t i;
48:            
49:            	//Decrement each software timer
50:            	for (i = 0; i < TMR_COUNT; i++) {
5EA8  0E00     MOVLW 0x0
5EAA  6E0B     MOVWF i, ACCESS
5EAC  0E06     MOVLW 0x6
5EAE  640B     CPFSGT i, ACCESS
5EB0  D001     BRA 0x5EB4
5EB2  D019     BRA 0x5EE6
51:            		if (tickCount[i] != 0) {
5EB4  500B     MOVF i, W, ACCESS
5EB6  0D02     MULLW 0x2
5EB8  0E00     MOVLW 0x0
5EBA  24F3     ADDWF PROD, W, ACCESS
5EBC  6ED9     MOVWF FSR2, ACCESS
5EBE  0E01     MOVLW 0x1
5EC0  20F4     ADDWFC PRODH, W, ACCESS
5EC2  6EDA     MOVWF FSR2H, ACCESS
5EC4  50DE     MOVF POSTINC2, W, ACCESS
5EC6  10DE     IORWF POSTINC2, W, ACCESS
5EC8  B4D8     BTFSC STATUS, 2, ACCESS
5ECA  D00B     BRA 0x5EE2
52:            			tickCount[i]--;
5ECC  500B     MOVF i, W, ACCESS
5ECE  0D02     MULLW 0x2
5ED0  0E00     MOVLW 0x0
5ED2  24F3     ADDWF PROD, W, ACCESS
5ED4  6ED9     MOVWF FSR2, ACCESS
5ED6  0E01     MOVLW 0x1
5ED8  20F4     ADDWFC PRODH, W, ACCESS
5EDA  6EDA     MOVWF FSR2H, ACCESS
5EDC  06DE     DECF POSTINC2, F, ACCESS
5EDE  0E00     MOVLW 0x0
5EE0  5ADD     SUBWFB POSTDEC2, F, ACCESS
53:            		}
54:            	}
5EE2  2A0B     INCF i, F, ACCESS
5EE4  D7E3     BRA 0x5EAC
55:            	IO_RA1_Toggle();
5EE6  A289     BTFSS LATA, 1, ACCESS
5EE8  D002     BRA 0x5EEE
5EEA  0E01     MOVLW 0x1
5EEC  D001     BRA 0x5EF0
5EEE  0E00     MOVLW 0x0
5EF0  0AFF     XORLW 0xFF
5EF2  6E09     MOVWF timerVal, ACCESS
5EF4  4609     RLNCF timerVal, F, ACCESS
5EF6  5089     MOVF LATA, W, ACCESS
5EF8  1809     XORWF timerVal, W, ACCESS
5EFA  0BFD     ANDLW 0xFD
5EFC  1809     XORWF timerVal, W, ACCESS
5EFE  6E89     MOVWF LATA, ACCESS
5F00  0012     RETURN 0
56:            }
0008  824B     BSF btemp, 1, ACCESS
57:            
---  /fred/mphase_v80/mphase.X/pfb.c  -------------------------------------------------------------------
1:             #include "pfb.h"
2:             
3:             // resolver angle data from controller parser
4:             
5:             uint16_t get_pfb(const char * buf)
6:             {
7:             	float offset, mphase, offset_whole;
8:             	char *token, pfb_ascii[MC_RX_PKT_SZ + 2], s[2] = " ";
47F0  C191     MOVFF F13317, s
47F2  F34C     NOP
47F4  C192     MOVFF 0x192, 0x34D
47F6  F34D     NOP
9:             
10:            	strcpy(pfb_ascii, buf); // make a local copy of the data
47F8  0E00     MOVLW 0x0
47FA  6E15     MOVWF dividend, ACCESS
47FC  0E03     MOVLW 0x3
47FE  6E16     MOVWF Message, ACCESS
4800  C0B4     MOVFF s, _r
4802  F017     NOP
4804  C0B5     MOVFF 0xB5, 0x18
4806  F018     NOP
4808  EC9C     CALL 0x6538, 0
480A  F032     NOP
11:            	token = strtok(pfb_ascii, s); // start token search
480C  0E00     MOVLW 0x0
480E  6E21     MOVWF s, ACCESS
4810  0E03     MOVLW 0x3
4812  6E22     MOVWF s, ACCESS
4814  0E4C     MOVLW 0x4C
4816  6E23     MOVWF sep, ACCESS
4818  0E03     MOVLW 0x3
481A  6E24     MOVWF n, ACCESS
481C  EC98     CALL 0x5930, 0
481E  F02C     NOP
4820  C021     MOVFF s, token
4822  F34A     NOP
4824  C022     MOVFF s, 0x34B
4826  F34B     NOP
12:            	token = strtok(NULL, s); // look for the second number
4828  0E00     MOVLW 0x0
482A  6E21     MOVWF s, ACCESS
482C  0E00     MOVLW 0x0
482E  6E22     MOVWF s, ACCESS
4830  0E4C     MOVLW 0x4C
4832  6E23     MOVWF sep, ACCESS
4834  0E03     MOVLW 0x3
4836  6E24     MOVWF n, ACCESS
4838  EC98     CALL 0x5930, 0
483A  F02C     NOP
483C  C021     MOVFF s, token
483E  F34A     NOP
4840  C022     MOVFF s, 0x34B
4842  F34B     NOP
13:            
14:            	if (token != NULL) {
4844  0103     MOVLB 0x3
4846  514A     MOVF 0x4A, W, BANKED
4848  114B     IORWF btemp, W, BANKED
484A  B4D8     BTFSC STATUS, 2, ACCESS
484C  D09C     BRA 0x4986
15:            		mphase = atof(token);
484E  C34A     MOVFF token, ap
4850  F0B0     NOP
4852  C34B     MOVFF 0x34B, 0xB1
4854  F0B1     NOP
4856  EC30     CALL 0x6860, 0
4858  F034     NOP
485A  C0B0     MOVFF ap, mphase
485C  F342     NOP
485E  C0B1     MOVFF 0xB1, 0x343
4860  F343     NOP
4862  C0B2     MOVFF cfmt, 0x344
4864  F344     NOP
4866  C0B3     MOVFF 0xB3, 0x345
4868  F345     NOP
16:            		offset = ((MOTOR_POLES / MOTOR_PAIRS) * mphase) / 360.0;
486A  0E00     MOVLW 0x0
486C  6E31     MOVWF a, ACCESS
486E  0E00     MOVLW 0x0
4870  6E32     MOVWF p, ACCESS
4872  0E40     MOVLW 0x40
4874  6E33     MOVWF 0x33, ACCESS
4876  0E41     MOVLW 0x41
4878  6E34     MOVWF l, ACCESS
487A  C342     MOVFF mphase, counter
487C  F02D     NOP
487E  C343     MOVFF 0x343, w
4880  F02E     NOP
4882  C344     MOVFF 0x344, 0x2F
4884  F02F     NOP
4886  C345     MOVFF 0x345, cp
4888  F030     NOP
488A  EC2B     CALL 0x3856, 0
488C  F01C     NOP
488E  C02D     MOVFF counter, b
4890  F071     NOP
4892  C02E     MOVFF w, p
4894  F072     NOP
4896  C02F     MOVFF 0x2F, 0x73
4898  F073     NOP
489A  C030     MOVFF cp, w
489C  F074     NOP
489E  0E00     MOVLW 0x0
48A0  0100     MOVLB 0x0
48A2  6F75     MOVWF a, BANKED
48A4  0E00     MOVLW 0x0
48A6  6F76     MOVWF n, BANKED
48A8  0EB4     MOVLW 0xB4
48AA  6F77     MOVWF p, BANKED
48AC  0E43     MOVLW 0x43
48AE  6F78     MOVWF n, BANKED
48B0  EC71     CALL 0x3EE2, 0
48B2  F01F     NOP
48B4  C071     MOVFF b, offset
48B6  F34E     NOP
48B8  C072     MOVFF p, 0x34F
48BA  F34F     NOP
48BC  C073     MOVFF 0x73, 0x350
48BE  F350     NOP
48C0  C074     MOVFF w, 0x351
48C2  F351     NOP
17:            		offset_whole = trunc(offset); // get the whole part with no rounding
48C4  C34E     MOVFF offset, dividend
48C6  F015     NOP
48C8  C34F     MOVFF 0x34F, Message
48CA  F016     NOP
48CC  C350     MOVFF 0x350, _r
48CE  F017     NOP
48D0  C351     MOVFF 0x351, 0x18
48D2  F018     NOP
48D4  EC1C     CALL 0x5038, 0
48D6  F028     NOP
48D8  C015     MOVFF dividend, offset_whole
48DA  F346     NOP
48DC  C016     MOVFF Message, 0x347
48DE  F347     NOP
48E0  C017     MOVFF _r, 0x348
48E2  F348     NOP
48E4  C018     MOVFF 0x18, 0x349
48E6  F349     NOP
18:            		offset = (offset - offset_whole)*360.0; // extract fractional part for angle offset calc
48E8  C34E     MOVFF offset, divisor
48EA  F01D     NOP
48EC  C34F     MOVFF 0x34F, l
48EE  F01E     NOP
48F0  C350     MOVFF 0x350, i
48F2  F01F     NOP
48F4  C351     MOVFF 0x351, r
48F6  F020     NOP
48F8  C346     MOVFF offset_whole, dividend
48FA  F015     NOP
48FC  C347     MOVFF 0x347, Message
48FE  F016     NOP
4900  C348     MOVFF 0x348, _r
4902  F017     NOP
4904  C349     MOVFF 0x349, 0x18
4906  F018     NOP
4908  ECC3     CALL 0x6786, 0
490A  F033     NOP
490C  C015     MOVFF dividend, multiplicand
490E  F019     NOP
4910  C016     MOVFF Message, s
4912  F01A     NOP
4914  C017     MOVFF _r, c
4916  F01B     NOP
4918  C018     MOVFF 0x18, c
491A  F01C     NOP
491C  ECD4     CALL 0x3BA8, 0
491E  F01D     NOP
4920  C019     MOVFF multiplicand, counter
4922  F02D     NOP
4924  C01A     MOVFF s, w
4926  F02E     NOP
4928  C01B     MOVFF c, 0x2F
492A  F02F     NOP
492C  C01C     MOVFF c, cp
492E  F030     NOP
4930  0E00     MOVLW 0x0
4932  6E31     MOVWF a, ACCESS
4934  0E00     MOVLW 0x0
4936  6E32     MOVWF p, ACCESS
4938  0EB4     MOVLW 0xB4
493A  6E33     MOVWF 0x33, ACCESS
493C  0E43     MOVLW 0x43
493E  6E34     MOVWF l, ACCESS
4940  EC2B     CALL 0x3856, 0
4942  F01C     NOP
4944  C02D     MOVFF counter, offset
4946  F34E     NOP
4948  C02E     MOVFF w, 0x34F
494A  F34F     NOP
494C  C02F     MOVFF 0x2F, 0x350
494E  F350     NOP
4950  C030     MOVFF cp, 0x351
4952  F351     NOP
19:            		/* need to round and convert data to integer */
20:            		return(uint16_t) roundf(offset);
4954  C34E     MOVFF offset, b
4956  F071     NOP
4958  C34F     MOVFF 0x34F, p
495A  F072     NOP
495C  C350     MOVFF 0x350, 0x73
495E  F073     NOP
4960  C351     MOVFF 0x351, w
4962  F074     NOP
4964  EC67     CALL 0x34CE, 0
4966  F01A     NOP
4968  C071     MOVFF b, ap
496A  F08B     NOP
496C  C072     MOVFF p, res
496E  F08C     NOP
4970  C073     MOVFF 0x73, 0x8D
4972  F08D     NOP
4974  C074     MOVFF w, 0x8E
4976  F08E     NOP
4978  ECC2     CALL 0x5784, 0
497A  F02B     NOP
497C  C08B     MOVFF ap, s
497E  F0B4     NOP
4980  C08C     MOVFF res, 0xB5
4982  F0B5     NOP
21:            	} else
4984  0012     RETURN 0
22:            		return(BADNUM);
4986  0E02     MOVLW 0x2
4988  0100     MOVLB 0x0
498A  6FB5     MOVWF 0xB5, BANKED
498C  0E9A     MOVLW 0x9A
498E  6FB4     MOVWF s, BANKED
4990  0012     RETURN 0
23:            }
---  /fred/mphase_v80/mphase.X/mcc_generated_files/tmr3.c  ----------------------------------------------
1:             /**
2:               TMR3 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr3.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR3 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR3.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F45K80
18:            	Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                :0:: error: (500) undefined symbols:
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include "tmr3.h"
53:            #include "pin_manager.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:             */
58:            volatile uint16_t timer3ReloadVal;
59:            void (*TMR3_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR3 APIs
63:             */
64:            
65:            void TMR3_Initialize(void)
66:            {
67:            	//Set the Timer to the options selected in the GUI
68:            
69:            	//T3GSS T3G_pin; TMR3GE disabled; T3GTM disabled; T3GPOL low; T3GGO done; T3GSPM disabled; 
70:            	T3GCON = 0x00;
63E6  0E00     MOVLW 0x0
63E8  6EB0     MOVWF T3GCON, ACCESS
71:            
72:            	//TMR3H 240; 
73:            	TMR3H = 0xF0;
63EA  0EF0     MOVLW 0xF0
63EC  6EB3     MOVWF TMR3H, ACCESS
74:            
75:            	//TMR3L 96; 
76:            	TMR3L = 0x60;
63EE  0E60     MOVLW 0x60
63F0  6EB2     MOVWF TMR3, ACCESS
77:            
78:            	// Load the TMR value to reload variable
79:            	timer3ReloadVal = (uint16_t) ((TMR3H << 8) | TMR3L);
63F2  50B2     MOVF TMR3, W, ACCESS
63F4  CFB3     MOVFF TMR3H, _r
63F6  F017     NOP
63F8  6A18     CLRF 0x18, ACCESS
63FA  C017     MOVFF _r, 0x18
63FC  F018     NOP
63FE  6A17     CLRF _r, ACCESS
6400  1017     IORWF _r, W, ACCESS
6402  0101     MOVLB 0x1
6404  6FEB     MOVWF 0xEB, BANKED
6406  5018     MOVF 0x18, W, ACCESS
6408  6FEC     MOVWF 0xEC, BANKED
80:            
81:            	// Clearing IF flag before enabling the interrupt.
82:            	PIR2bits.TMR3IF = 0;
640A  92A1     BCF PIR2, 1, ACCESS
83:            
84:            	// Enabling TMR3 interrupt.
85:            	PIE2bits.TMR3IE = 1;
640C  82A0     BSF PIE2, 1, ACCESS
86:            
87:            	// Set Default Interrupt Handler
88:            	TMR3_SetInterruptHandler(TMR3_DefaultInterruptHandler);
640E  0E30     MOVLW 0x30
6410  6E15     MOVWF dividend, ACCESS
6412  0E6A     MOVLW 0x6A
6414  6E16     MOVWF Message, ACCESS
6416  EC88     CALL 0x6B10, 0
6418  F035     NOP
89:            
90:            	// T3CKPS 1:1; RD16 disabled; SOSCEN disabled; nT3SYNC synchronize; TMR3CS FOSC/4; TMR3ON enabled; 
91:            	T3CON = 0x01;
641A  0E01     MOVLW 0x1
641C  6EB1     MOVWF T3CON, ACCESS
92:            }
641E  0012     RETURN 0
93:            
94:            void TMR3_StartTimer(void)
95:            {
96:            	// Start the Timer by writing to TMRxON bit
97:            	T3CONbits.TMR3ON = 1;
6BCE  80B1     BSF T3CON, 0, ACCESS
98:            }
6BD0  0012     RETURN 0
99:            
100:           void TMR3_StopTimer(void)
101:           {
102:           	// Stop the Timer by writing to TMRxON bit
103:           	T3CONbits.TMR3ON = 0;
6BCA  90B1     BCF T3CON, 0, ACCESS
104:           }
6BCC  0012     RETURN 0
105:           
106:           uint16_t TMR3_ReadTimer(void)
107:           {
108:           	uint16_t readVal;
109:           	uint8_t readValHigh;
110:           	uint8_t readValLow;
111:           
112:           
113:           	readValLow = TMR3L;
114:           	readValHigh = TMR3H;
115:           
116:           	readVal = ((uint16_t) readValHigh << 8) | readValLow;
117:           
118:           	return readVal;
119:           }
120:           
121:           void TMR3_WriteTimer(uint16_t timerVal)
122:           {
123:           	if (T3CONbits.nT3SYNC == 1) {
6A86  A4B1     BTFSS T3CON, 2, ACCESS
6A88  D007     BRA 0x6A98
124:           		// Stop the Timer by writing to TMRxON bit
125:           		T3CONbits.TMR3ON = 0;
6A8A  90B1     BCF T3CON, 0, ACCESS
126:           
127:           		// Write to the Timer3 register
128:           		TMR3H = (timerVal >> 8);
6A8C  5002     MOVF 0x2, W, ACCESS
6A8E  6EB3     MOVWF TMR3H, ACCESS
129:           		TMR3L = timerVal;
6A90  C001     MOVFF __pcstackCOMRAM, TMR3
6A92  FFB2     NOP
130:           
131:           		// Start the Timer after writing to the register
132:           		T3CONbits.TMR3ON = 1;
6A94  80B1     BSF T3CON, 0, ACCESS
133:           	} else {
6A96  0012     RETURN 0
134:           		// Write to the Timer3 register
135:           		TMR3H = (timerVal >> 8);
6A98  5002     MOVF 0x2, W, ACCESS
6A9A  6EB3     MOVWF TMR3H, ACCESS
136:           		TMR3L = timerVal;
6A9C  C001     MOVFF __pcstackCOMRAM, TMR3
6A9E  FFB2     NOP
6AA0  0012     RETURN 0
137:           	}
138:           }
139:           
140:           void TMR3_Reload(void)
141:           {
142:           	TMR3_WriteTimer(timer3ReloadVal);
143:           }
144:           
145:           void TMR3_StartSinglePulseAcquisition(void)
146:           {
147:           	T3GCONbits.T3GGO = 1;
148:           }
149:           
150:           uint8_t TMR3_CheckGateValueStatus(void)
151:           {
152:           	return(T3GCONbits.T3GVAL);
153:           }
154:           
155:           void TMR3_ISR(void)
156:           {
157:           	static uint8_t	chirp=0;
158:           	// Clear the TMR3 interrupt flag
159:           	PIR2bits.TMR3IF = 0;
64CA  92A1     BCF PIR2, 1, ACCESS
160:           	TMR3_WriteTimer(timer3ReloadVal+chirp++); // sweep the sound a bit
64CC  0101     MOVLB 0x1
64CE  5127     MOVF quotient, W, BANKED
64D0  25EB     ADDWF 0xEB, W, BANKED
64D2  6E01     MOVWF __pcstackCOMRAM, ACCESS
64D4  0E00     MOVLW 0x0
64D6  21EC     ADDWFC 0xEC, W, BANKED
64D8  6E02     MOVWF 0x2, ACCESS
64DA  EC43     CALL 0x6A86, 0
64DC  F035     NOP
64DE  0101     MOVLB 0x1
64E0  2B27     INCF quotient, F, BANKED
161:           
162:           	if (TMR3_InterruptHandler) {
64E2  51E9     MOVF 0xE9, W, BANKED
64E4  11EA     IORWF 0xEA, W, BANKED
64E6  B4D8     BTFSC STATUS, 2, ACCESS
64E8  0012     RETURN 0
163:           		TMR3_InterruptHandler();
64EA  D801     RCALL 0x64EE
64EC  0012     RETURN 0
64EE  0005     PUSH
64F0  6EFA     MOVWF PCLATH, ACCESS
64F2  51E9     MOVF 0xE9, W, BANKED
64F4  6EFD     MOVWF TOS, ACCESS
64F6  51EA     MOVF 0xEA, W, BANKED
64F8  6EFE     MOVWF TOSH, ACCESS
64FA  50F8     MOVF TBLPTRU, W, ACCESS
64FC  6EFF     MOVWF TOSU, ACCESS
64FE  50FA     MOVF PCLATH, W, ACCESS
6500  0012     RETURN 0
164:           	}
165:           }
166:           
167:           void TMR3_SetInterruptHandler(void (* InterruptHandler)(void))
168:           {
169:           	TMR3_InterruptHandler = InterruptHandler;
6B10  C015     MOVFF dividend, TMR3_InterruptHandler
6B12  F1E9     NOP
6B14  C016     MOVFF Message, 0x1EA
6B16  F1EA     NOP
170:           }
6B18  0012     RETURN 0
171:           
172:           void TMR3_DefaultInterruptHandler(void)
173:           {
174:           	// add your TMR3 interrupt custom code
175:           	// or set custom function using TMR3_SetInterruptHandler()
176:           	IO_RA5_Toggle(); // speaker
6A30  AA89     BTFSS LATA, 5, ACCESS
6A32  D002     BRA 0x6A38
6A34  0E01     MOVLW 0x1
6A36  D001     BRA 0x6A3A
6A38  0E00     MOVLW 0x0
6A3A  0AFF     XORLW 0xFF
6A3C  6E01     MOVWF __pcstackCOMRAM, ACCESS
6A3E  3A01     SWAPF __pcstackCOMRAM, F, ACCESS
6A40  4601     RLNCF __pcstackCOMRAM, F, ACCESS
6A42  5089     MOVF LATA, W, ACCESS
6A44  1801     XORWF __pcstackCOMRAM, W, ACCESS
6A46  0BDF     ANDLW 0xDF
6A48  1801     XORWF __pcstackCOMRAM, W, ACCESS
6A4A  6E89     MOVWF LATA, ACCESS
6A4C  0012     RETURN 0
177:           }
178:           
179:           /**
180:             End of File
181:            */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/tmr1.c  ----------------------------------------------
1:             /**
2:               TMR1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F45K80
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr1.h"
53:            #include "../timers.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:            */
58:            volatile uint16_t timer1ReloadVal;
59:            void (*TMR1_InterruptHandler)(void);
60:            
61:            /**
62:              Section: TMR1 APIs
63:            */
64:            
65:            void TMR1_Initialize(void)
66:            {
67:                //Set the Timer to the options selected in the GUI
68:            
69:                //T1GSS T1G_pin; TMR1GE disabled; T1GTM disabled; T1GPOL low; T1GGO done; T1GSPM disabled; 
70:                T1GCON = 0x00;
6420  0E00     MOVLW 0x0
6422  6EAA     MOVWF T1GCON, ACCESS
71:            
72:                //TMR1H 224; 
73:                TMR1H = 0xE0;
6424  0EE0     MOVLW 0xE0
6426  6ECF     MOVWF TMR1H, ACCESS
74:            
75:                //TMR1L 192; 
76:                TMR1L = 0xC0;
6428  0EC0     MOVLW 0xC0
642A  6ECE     MOVWF TMR1, ACCESS
77:            
78:                // Load the TMR value to reload variable
79:                timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
642C  50CE     MOVF TMR1, W, ACCESS
642E  CFCF     MOVFF TMR1H, _r
6430  F017     NOP
6432  6A18     CLRF 0x18, ACCESS
6434  C017     MOVFF _r, 0x18
6436  F018     NOP
6438  6A17     CLRF _r, ACCESS
643A  1017     IORWF _r, W, ACCESS
643C  0101     MOVLB 0x1
643E  6FEF     MOVWF 0xEF, BANKED
6440  5018     MOVF 0x18, W, ACCESS
6442  6FF0     MOVWF 0xF0, BANKED
80:            
81:                // Clearing IF flag before enabling the interrupt.
82:                PIR1bits.TMR1IF = 0;
6444  909E     BCF PIR1, 0, ACCESS
83:            
84:                // Enabling TMR1 interrupt.
85:                PIE1bits.TMR1IE = 1;
6446  809D     BSF PIE1, 0, ACCESS
86:            
87:                // Set Default Interrupt Handler
88:                TMR1_SetInterruptHandler(TMR1_DefaultInterruptHandler);
6448  0EC0     MOVLW 0xC0
644A  6E15     MOVWF dividend, ACCESS
644C  0E6B     MOVLW 0x6B
644E  6E16     MOVWF Message, ACCESS
6450  EC8D     CALL 0x6B1A, 0
6452  F035     NOP
89:            
90:                // T1CKPS 1:1; RD16 disabled; SOSCEN disabled; nT1SYNC synchronize; TMR1CS FOSC/4; TMR1ON enabled; 
91:                T1CON = 0x01;
6454  0E01     MOVLW 0x1
6456  6ECD     MOVWF T1CON, ACCESS
92:            }
6458  0012     RETURN 0
93:            
94:            void TMR1_StartTimer(void)
95:            {
96:                // Start the Timer by writing to TMRxON bit
97:                T1CONbits.TMR1ON = 1;
6BD6  80CD     BSF T1CON, 0, ACCESS
98:            }
6BD8  0012     RETURN 0
99:            
100:           void TMR1_StopTimer(void)
101:           {
102:               // Stop the Timer by writing to TMRxON bit
103:               T1CONbits.TMR1ON = 0;
104:           }
105:           
106:           uint16_t TMR1_ReadTimer(void)
107:           {
108:               uint16_t readVal;
109:               uint8_t readValHigh;
110:               uint8_t readValLow;
111:               
112:           	
113:               readValLow = TMR1L;
114:               readValHigh = TMR1H;
115:               
116:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
117:           
118:               return readVal;
119:           }
120:           
121:           void TMR1_WriteTimer(uint16_t timerVal)
122:           {
123:               if (T1CONbits.nT1SYNC == 1)
6A6A  A4CD     BTFSS T1CON, 2, ACCESS
6A6C  D007     BRA 0x6A7C
124:               {
125:                   // Stop the Timer by writing to TMRxON bit
126:                   T1CONbits.TMR1ON = 0;
6A6E  90CD     BCF T1CON, 0, ACCESS
127:           
128:                   // Write to the Timer1 register
129:                   TMR1H = (timerVal >> 8);
6A70  500A     MOVF 0xA, W, ACCESS
6A72  6ECF     MOVWF TMR1H, ACCESS
130:                   TMR1L = timerVal;
6A74  C009     MOVFF timerVal, TMR1
6A76  FFCE     NOP
131:           
132:                   // Start the Timer after writing to the register
133:                   T1CONbits.TMR1ON =1;
6A78  80CD     BSF T1CON, 0, ACCESS
134:               }
6A7A  0012     RETURN 0
135:               else
136:               {
137:                   // Write to the Timer1 register
138:                   TMR1H = (timerVal >> 8);
6A7C  500A     MOVF 0xA, W, ACCESS
6A7E  6ECF     MOVWF TMR1H, ACCESS
139:                   TMR1L = timerVal;
6A80  C009     MOVFF timerVal, TMR1
6A82  FFCE     NOP
6A84  0012     RETURN 0
140:               }
141:           }
142:           
143:           void TMR1_Reload(void)
144:           {
145:               TMR1_WriteTimer(timer1ReloadVal);
146:           }
147:           
148:           void TMR1_StartSinglePulseAcquisition(void)
149:           {
150:               T1GCONbits.T1GGO = 1;
151:           }
152:           
153:           uint8_t TMR1_CheckGateValueStatus(void)
154:           {
155:               return (T1GCONbits.T1GVAL);
156:           }
157:           
158:           void TMR1_ISR(void)
159:           {
160:           
161:               // Clear the TMR1 interrupt flag
162:               PIR1bits.TMR1IF = 0;
66F6  909E     BCF PIR1, 0, ACCESS
163:               TMR1_WriteTimer(timer1ReloadVal);
66F8  C1EF     MOVFF timer1ReloadVal, timerVal
66FA  F009     NOP
66FC  C1F0     MOVFF 0x1F0, 0xA
66FE  F00A     NOP
6700  EC35     CALL 0x6A6A, 0
6702  F035     NOP
164:           
165:               if(TMR1_InterruptHandler)
6704  0101     MOVLB 0x1
6706  51ED     MOVF 0xED, W, BANKED
6708  11EE     IORWF 0xEE, W, BANKED
670A  B4D8     BTFSC STATUS, 2, ACCESS
670C  0012     RETURN 0
166:               {
167:                   TMR1_InterruptHandler();
670E  D801     RCALL 0x6712
6710  0012     RETURN 0
6712  0005     PUSH
6714  6EFA     MOVWF PCLATH, ACCESS
6716  51ED     MOVF 0xED, W, BANKED
6718  6EFD     MOVWF TOS, ACCESS
671A  51EE     MOVF 0xEE, W, BANKED
671C  6EFE     MOVWF TOSH, ACCESS
671E  50F8     MOVF TBLPTRU, W, ACCESS
6720  6EFF     MOVWF TOSU, ACCESS
6722  50FA     MOVF PCLATH, W, ACCESS
6724  0012     RETURN 0
168:               }
169:           }
170:           
171:           
172:           void TMR1_SetInterruptHandler(void (* InterruptHandler)(void)){
173:               TMR1_InterruptHandler = InterruptHandler;
6B1A  C015     MOVFF dividend, TMR1_InterruptHandler
6B1C  F1ED     NOP
6B1E  C016     MOVFF Message, 0x1EE
6B20  F1EE     NOP
174:           }
6B22  0012     RETURN 0
175:           
176:           void TMR1_DefaultInterruptHandler(void){
177:               // add your TMR1 interrupt custom code
178:               // or set custom function using TMR1_SetInterruptHandler()
179:               _T1Interrupt();
6BC0  EC54     CALL 0x5EA8, 0
6BC2  F02F     NOP
180:           }
6BC4  0012     RETURN 0
181:           
182:           /**
183:             End of File
184:           */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/tmr0.c  ----------------------------------------------
1:             /**
2:               TMR0 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr0.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR0 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR0.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F45K80
18:            	Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            
51:            #include <xc.h>
52:            #include <stdlib.h>
53:            #include "tmr0.h"
54:            
55:            /**
56:              Section: Global Variables Definitions
57:             */
58:            
59:            extern APP_DATA appData;
60:            void (*TMR0_InterruptHandler)(void);
61:            
62:            volatile uint16_t timer0ReloadVal;
63:            
64:            /**
65:              Section: TMR0 APIs
66:             */
67:            
68:            
69:            void TMR0_Initialize(void)
70:            {
71:            	// Set TMR0 to the options selected in the User Interface
72:            
73:            	//Enable 16bit timer mode before assigning value to TMR0H
74:            	T0CONbits.T08BIT = 0;
62B6  9CD5     BCF T0CON, 6, ACCESS
75:            
76:            	// TMR0H 231; 
77:            	TMR0H = 0xE7;
62B8  0EE7     MOVLW 0xE7
62BA  6ED7     MOVWF TMR0H, ACCESS
78:            
79:            	// TMR0L 149; 
80:            	TMR0L = 0x95;
62BC  0E95     MOVLW 0x95
62BE  6ED6     MOVWF TMR0, ACCESS
81:            
82:            	// Load TMR0 value to the 8-bit reload variable
83:            	timer0ReloadVal = 96;
62C0  0E00     MOVLW 0x0
62C2  6E4A     MOVWF 0x4A, ACCESS
62C4  0E60     MOVLW 0x60
62C6  6E49     MOVWF timer0ReloadVal, ACCESS
84:            
85:            	// Load TMR0 value to the 16-bit reload variable
86:            	timer0ReloadVal = (uint16_t) ((TMR0H << 8) | TMR0L);
62C8  50D6     MOVF TMR0, W, ACCESS
62CA  CFD7     MOVFF TMR0H, _r
62CC  F017     NOP
62CE  6A18     CLRF 0x18, ACCESS
62D0  C017     MOVFF _r, 0x18
62D2  F018     NOP
62D4  6A17     CLRF _r, ACCESS
62D6  1017     IORWF _r, W, ACCESS
62D8  6E49     MOVWF timer0ReloadVal, ACCESS
62DA  5018     MOVF 0x18, W, ACCESS
62DC  6E4A     MOVWF 0x4A, ACCESS
87:            
88:            	// Clear Interrupt flag before enabling the interrupt
89:            	INTCONbits.TMR0IF = 0;
62DE  94F2     BCF INTCON, 2, ACCESS
90:            
91:            	// Enabling TMR0 interrupt.
92:            	INTCONbits.TMR0IE = 1;
62E0  8AF2     BSF INTCON, 5, ACCESS
93:            
94:            	// Set Default Interrupt Handler
95:            	TMR0_SetInterruptHandler(TMR0_DefaultInterruptHandler);
62E2  0EAA     MOVLW 0xAA
62E4  6E15     MOVWF dividend, ACCESS
62E6  0E63     MOVLW 0x63
62E8  6E16     MOVWF Message, ACCESS
62EA  EC92     CALL 0x6B24, 0
62EC  F035     NOP
96:            
97:            	// T0PS 1:256; T08BIT 16-bit; T0SE Increment_hi_lo; T0CS FOSC/4; TMR0ON enabled; PSA assigned; 
98:            	T0CON = 0x97;
62EE  0E97     MOVLW 0x97
62F0  6ED5     MOVWF T0CON, ACCESS
99:            }
62F2  0012     RETURN 0
100:           
101:           void TMR0_StartTimer(void)
102:           {
103:           	// Start the Timer by writing to TMR0ON bit
104:           	T0CONbits.TMR0ON = 1;
6BDA  8ED5     BSF T0CON, 7, ACCESS
105:           }
0018  804B     BSF btemp, 0, ACCESS
6BDC  0012     RETURN 0
106:           
107:           void TMR0_StopTimer(void)
108:           {
109:           	// Stop the Timer by writing to TMR0ON bit
110:           	T0CONbits.TMR0ON = 0;
111:           }
112:           
113:           uint16_t TMR0_ReadTimer(void)
114:           {
115:           	uint16_t readVal;
116:           	uint8_t readValLow;
117:           	uint8_t readValHigh;
118:           
119:           	readValLow = TMR0L;
120:           	readValHigh = TMR0H;
121:           	readVal = ((uint16_t) readValHigh << 8) + readValLow;
122:           
123:           	return readVal;
124:           }
125:           
126:           void TMR0_WriteTimer(uint16_t timerVal)
127:           {
128:           	// Write to the Timer0 register
129:           	TMR0H = timerVal >> 8;
130:           	TMR0L = (uint8_t) timerVal;
131:           }
132:           
133:           void TMR0_Reload(void)
134:           {
135:           	// Write to the Timer0 register
136:           	TMR0H = timer0ReloadVal >> 8;
137:           	TMR0L = (uint8_t) timer0ReloadVal;
138:           }
139:           
140:           void TMR0_ISR(void)
141:           {
142:           
143:           	// clear the TMR0 interrupt flag
144:           	INTCONbits.TMR0IF = 0;
67B4  94F2     BCF INTCON, 2, ACCESS
145:           
146:           	// reload TMR0
147:           	// Write to the Timer0 register
148:           	TMR0H = timer0ReloadVal >> 8;
67B6  504A     MOVF 0x4A, W, ACCESS
67B8  6ED7     MOVWF TMR0H, ACCESS
149:           	TMR0L = (uint8_t) timer0ReloadVal;
67BA  C049     MOVFF timer0ReloadVal, TMR0
67BC  FFD6     NOP
150:           
151:           	if (TMR0_InterruptHandler) {
67BE  0101     MOVLB 0x1
67C0  51F9     MOVF 0xF9, W, BANKED
67C2  11FA     IORWF 0xFA, W, BANKED
67C4  B4D8     BTFSC STATUS, 2, ACCESS
67C6  0012     RETURN 0
152:           		TMR0_InterruptHandler();
67C8  D801     RCALL 0x67CC
67CA  0012     RETURN 0
67CC  0005     PUSH
67CE  6EFA     MOVWF PCLATH, ACCESS
67D0  51F9     MOVF 0xF9, W, BANKED
67D2  6EFD     MOVWF TOS, ACCESS
67D4  51FA     MOVF 0xFA, W, BANKED
67D6  6EFE     MOVWF TOSH, ACCESS
67D8  50F8     MOVF TBLPTRU, W, ACCESS
67DA  6EFF     MOVWF TOSU, ACCESS
67DC  50FA     MOVF PCLATH, W, ACCESS
67DE  0012     RETURN 0
153:           	}
154:           
155:           	// add your TMR0 interrupt custom code
156:           }
157:           
158:           void TMR0_SetInterruptHandler(void (* InterruptHandler)(void))
159:           {
160:           	TMR0_InterruptHandler = InterruptHandler;
6B24  C015     MOVFF dividend, TMR0_InterruptHandler
6B26  F1F9     NOP
6B28  C016     MOVFF Message, 0x1FA
6B2A  F1FA     NOP
161:           }
6B2C  0012     RETURN 0
162:           
163:           // switch pressed time delays
164:           void TMR0_DefaultInterruptHandler(void)
165:           {
166:           	// add your TMR0 interrupt custom code
167:           	// or set custom function using TMR0_SetInterruptHandler()
168:           
169:           	if (appData.sw1Changed) {
63AA  0101     MOVLB 0x1
63AC  51DD     MOVF 0xDD, W, BANKED
63AE  B4D8     BTFSC STATUS, 2, ACCESS
63B0  D004     BRA 0x63BA
170:           		if (!(--appData.sw1Changed))
63B2  2FDD     DECFSZ 0xDD, F, BANKED
63B4  D002     BRA 0x63BA
171:           			appData.sw1 = true;
63B6  0E01     MOVLW 0x1
63B8  6FD9     MOVWF 0xD9, BANKED
172:           	}
173:           
174:           	if (appData.sw2Changed) {
63BA  51DE     MOVF 0xDE, W, BANKED
63BC  B4D8     BTFSC STATUS, 2, ACCESS
63BE  D004     BRA 0x63C8
175:           		if (!(--appData.sw2Changed))
63C0  2FDE     DECFSZ 0xDE, F, BANKED
63C2  D002     BRA 0x63C8
176:           			appData.sw2 = true;
63C4  0E01     MOVLW 0x1
63C6  6FDA     MOVWF 0xDA, BANKED
177:           	}
178:           
179:           	if (appData.sw3Changed) {
63C8  51DF     MOVF 0xDF, W, BANKED
63CA  B4D8     BTFSC STATUS, 2, ACCESS
63CC  D004     BRA 0x63D6
180:           		if (!(--appData.sw3Changed))
63CE  2FDF     DECFSZ 0xDF, F, BANKED
63D0  D002     BRA 0x63D6
181:           			appData.sw3 = true;
63D2  0E01     MOVLW 0x1
63D4  6FDB     MOVWF 0xDB, BANKED
182:           	}
183:           
184:           	if (appData.sw4Changed) {
63D6  51E0     MOVF 0xE0, W, BANKED
63D8  B4D8     BTFSC STATUS, 2, ACCESS
63DA  0012     RETURN 0
185:           		if (!(--appData.sw4Changed))
63DC  2FE0     DECFSZ 0xE0, F, BANKED
63DE  0012     RETURN 0
186:           			appData.sw4 = true;
63E0  0E01     MOVLW 0x1
63E2  6FDC     MOVWF 0xDC, BANKED
63E4  0012     RETURN 0
187:           	}
188:           }
189:           
190:           /**
191:             End of File
192:            */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/spi.c  -----------------------------------------------
1:             /**
2:               MSSP Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 spi.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the MSSP driver using 
12:                PIC10 / PIC12 / PIC16 / PIC18 MCUs
13:            
14:              @Description
15:                This source file provides APIs SPI.
16:                Generation Information :
17:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
18:                    Device            :  PIC18F45K80
19:                    Driver Version    :  2.02
20:                The generated drivers are tested against the following:
21:                    Compiler          :  XC8 1.45
22:                    MPLAB 	          :  MPLAB X 4.15
23:            */
24:            
25:            /*
26:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
27:                
28:                Subject to your compliance with these terms, you may use Microchip software and any 
29:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
30:                license terms applicable to your use of third party software (including open source software) that 
31:                may accompany Microchip software.
32:                
33:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
34:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
35:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
36:                FOR A PARTICULAR PURPOSE.
37:                
38:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
39:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
40:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
41:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
42:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
43:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
44:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
45:                SOFTWARE.
46:            */
47:            
48:            /**
49:              Section: Included Files
50:            */
51:            
52:            #include <xc.h>
53:            #include "spi.h"
54:            
55:            /**
56:              Section: Macro Declarations
57:            */
58:            
59:            #define SPI_RX_IN_PROGRESS 0x0
60:            
61:            /**
62:              Section: Module APIs
63:            */
64:            
65:            void SPI_Initialize(void)
66:            {
67:                // Set the SPI module to the options selected in the User Interface
68:                
69:                // SMP Middle; CKE Idle to Active; 
70:                SSPSTAT = 0x00;
6AF4  0E00     MOVLW 0x0
6AF6  6EC7     MOVWF SSPSTAT, ACCESS
71:                
72:                // SSPEN enabled; WCOL no_collision; CKP Idle:Low, Active:High; SSPM FOSC/4; SSPOV no_overflow; 
73:                SSPCON1 = 0x20;
6AF8  0E20     MOVLW 0x20
6AFA  6EC6     MOVWF SSPCON1, ACCESS
74:                
75:                // SSPADD 0; 
76:                SSPADD = 0x00;
6AFC  0E00     MOVLW 0x0
6AFE  6EC8     MOVWF SSPADD, ACCESS
77:            }
6B00  0012     RETURN 0
78:            
79:            uint8_t SPI_Exchange8bit(uint8_t data)
80:            {
81:                // Clear the Write Collision flag, to allow writing
82:                SSPCON1bits.WCOL = 0;
83:            
84:                SSPBUF = data;
85:            
86:                while(SSPSTATbits.BF == SPI_RX_IN_PROGRESS)
87:                {
88:                }
89:            
90:                return (SSPBUF);
91:            }
92:            
93:            uint8_t SPI_Exchange8bitBuffer(uint8_t *dataIn, uint8_t bufLen, uint8_t *dataOut)
94:            {
95:                uint8_t bytesWritten = 0;
96:            
97:                if(bufLen != 0)
98:                {
99:                    if(dataIn != NULL)
100:                   {
101:                       while(bytesWritten < bufLen)
102:                       {
103:                           if(dataOut == NULL)
104:                           {
105:                               SPI_Exchange8bit(dataIn[bytesWritten]);
106:                           }
107:                           else
108:                           {
109:                               dataOut[bytesWritten] = SPI_Exchange8bit(dataIn[bytesWritten]);
110:                           }
111:           
112:                           bytesWritten++;
113:                       }
114:                   }
115:                   else
116:                   {
117:                       if(dataOut != NULL)
118:                       {
119:                           while(bytesWritten < bufLen )
120:                           {
121:                               dataOut[bytesWritten] = SPI_Exchange8bit(SPI_DUMMY_DATA);
122:           
123:                               bytesWritten++;
124:                           }
125:                       }
126:                   }
127:               }
128:           
129:               return bytesWritten;
130:           }
131:           
132:           bool SPI_IsBufferFull(void)
133:           {
134:               return (SSPSTATbits.BF);
135:           }
136:           
137:           bool SPI_HasWriteCollisionOccured(void)
138:           {
139:               return (SSPCON1bits.WCOL);
140:           }
141:           
142:           void SPI_ClearWriteCollisionStatus(void)
143:           {
144:               SSPCON1bits.WCOL = 0;
145:           }
146:           /**
147:            End of File
148:           */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/pin_manager.c  ---------------------------------------
1:             /**
2:               Generated Pin Manager File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 pin_manager.c
9:             
10:              Summary:
11:                This is the Pin Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for pin APIs for all pins selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F45K80
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB             :  MPLAB X 4.15
22:            
23:                Copyright (c) 2013 - 2015 released Microchip Technology Inc.  All rights reserved.
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include <xc.h>
50:            #include "pin_manager.h"
51:            #include "stdbool.h"
52:            
53:            
54:            
55:            
56:            
57:            void PIN_MANAGER_Initialize(void)
58:            {
59:                /**
60:                LATx registers
61:                */
62:                LATE = 0x00;
645A  0E00     MOVLW 0x0
645C  6E8D     MOVWF LATE, ACCESS
63:                LATD = 0x00;
645E  0E00     MOVLW 0x0
6460  6E8C     MOVWF LATD, ACCESS
64:                LATA = 0x0F;
6462  0E0F     MOVLW 0xF
6464  6E89     MOVWF LATA, ACCESS
65:                LATB = 0x00;
6466  0E00     MOVLW 0x0
6468  6E8A     MOVWF LATB, ACCESS
66:                LATC = 0x00;
646A  0E00     MOVLW 0x0
646C  6E8B     MOVWF LATC, ACCESS
67:            
68:                /**
69:                TRISx registers
70:                */
71:                TRISE = 0x07;
646E  0E07     MOVLW 0x7
6470  6E96     MOVWF TRISE, ACCESS
72:                TRISA = 0x80;
6472  0E80     MOVLW 0x80
6474  6E92     MOVWF TRISA, ACCESS
73:                TRISB = 0xFF;
6476  6893     SETF TRISB, ACCESS
74:                TRISC = 0x97;
6478  0E97     MOVLW 0x97
647A  6E94     MOVWF TRISC, ACCESS
75:                TRISD = 0xBF;
647C  0EBF     MOVLW 0xBF
647E  6E95     MOVWF TRISD, ACCESS
76:            
77:                /**
78:                ANSELx registers
79:                */
80:                ANCON0 = 0xE0;
6480  0EE0     MOVLW 0xE0
6482  010F     MOVLB 0xF
6484  6F5D     MOVWF 0x5D, BANKED
81:                ANCON1 = 0x7A;
6486  0E7A     MOVLW 0x7A
6488  6F5C     MOVWF 0x5C, BANKED
82:            
83:                /**
84:                WPUx registers
85:                */
86:                WPUB = 0x01;
648A  0E01     MOVLW 0x1
648C  6F5B     MOVWF 0x5B, BANKED
87:                INTCON2bits.nRBPU = 0;
648E  9EF1     BCF INTCON2, 7, ACCESS
88:            
89:            
90:            
91:            
92:            
93:            
94:            
95:               
96:                
97:            }
6490  0012     RETURN 0
98:              
99:            void PIN_MANAGER_IOC(void)
100:           {   
101:           	// Clear global Interrupt-On-Change flag
102:               INTCONbits.RBIF = 0;
6BC6  90F2     BCF INTCON, 0, ACCESS
103:           }
6BC8  0012     RETURN 0
104:           
105:           /**
106:            End of File
107:           */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/mcc.c  -----------------------------------------------
1:             /**
2:               @Generated PIC10 / PIC12 / PIC16 / PIC18 MCUs Source File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 mcc.c
9:             
10:              @Summary:
11:                This is the mcc.c file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F45K80
18:                    Driver Version    :  2.00
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45 or later
21:                    MPLAB             :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            #include "mcc.h"
48:            
49:            
50:            void SYSTEM_Initialize(void)
51:            {
52:            
53:                INTERRUPT_Initialize();
680C  EC51     CALL 0x6AA2, 0
680E  F035     NOP
54:                PIN_MANAGER_Initialize();
6810  EC2D     CALL 0x645A, 0
6812  F032     NOP
55:                OSCILLATOR_Initialize();
6814  EC69     CALL 0x6AD2, 0
6816  F035     NOP
56:                SPI_Initialize();
6818  EC7A     CALL 0x6AF4, 0
681A  F035     NOP
57:                TMR3_Initialize();
681C  ECF3     CALL 0x63E6, 0
681E  F031     NOP
58:                EXT_INT_Initialize();
6820  ECF1     CALL 0x61E2, 0
6822  F030     NOP
59:                TMR1_Initialize();
6824  EC10     CALL 0x6420, 0
6826  F032     NOP
60:                TMR0_Initialize();
6828  EC5B     CALL 0x62B6, 0
682A  F031     NOP
61:                EUSART1_Initialize();
682C  ECA3     CALL 0x6146, 0
682E  F030     NOP
62:                EUSART2_Initialize();
6830  EC7C     CALL 0x60F8, 0
6832  F030     NOP
63:            }
6834  0012     RETURN 0
64:            
65:            void OSCILLATOR_Initialize(void)
66:            {
67:                // SCS FOSC; HFIOFS not stable; IDLEN disabled; IRCF 16MHz_HF; 
68:                OSCCON = 0x70;
6AD2  0E70     MOVLW 0x70
6AD4  6ED3     MOVWF OSCCON, ACCESS
69:                // SOSCGO disabled; MFIOSEL disabled; SOSCDRV Low Power; 
70:                OSCCON2 = 0x00;
6AD6  0E00     MOVLW 0x0
6AD8  6ED2     MOVWF OSCCON2, ACCESS
71:                // INTSRC INTRC; PLLEN enabled; TUN 0; 
72:                OSCTUNE = 0x40;
6ADA  0E40     MOVLW 0x40
6ADC  6E9B     MOVWF OSCTUNE, ACCESS
73:                // ROSEL System Clock(FOSC); ROON disabled; ROSSLP Disabled in Sleep mode; RODIV Fosc; 
74:                REFOCON = 0x00;
6ADE  0E00     MOVLW 0x0
6AE0  6E9A     MOVWF REFOCON, ACCESS
75:            }
6AE2  0012     RETURN 0
76:            
77:            
78:            /**
79:             End of File
80:            */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/interrupt_manager.c  ---------------------------------
1:             /**
2:               Generated Interrupt Manager Header File
3:             
4:               @Company:
5:                 Microchip Technology Inc.
6:             
7:               @File Name:
8:                 interrupt_manager.h
9:             
10:              @Summary:
11:                This is the Interrupt Manager file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description:
14:                This header file provides implementations for global interrupt handling.
15:                For individual peripheral handlers please see the peripheral driver for
16:                all modules selected in the GUI.
17:                Generation Information :
18:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
19:                    Device            :  PIC18F45K80
20:                    Driver Version    :  2.12
21:                The generated drivers are tested against the following:
22:                    Compiler          :  XC8 1.45 or later
23:                    MPLAB 	          :  MPLAB X 4.15
24:            */
25:            
26:            /*
27:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
28:                
29:                Subject to your compliance with these terms, you may use Microchip software and any 
30:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
31:                license terms applicable to your use of third party software (including open source software) that 
32:                may accompany Microchip software.
33:                
34:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
35:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
36:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
37:                FOR A PARTICULAR PURPOSE.
38:                
39:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
40:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
41:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
42:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
43:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
44:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
45:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
46:                SOFTWARE.
47:            */
48:            
49:            #include "interrupt_manager.h"
50:            #include "mcc.h"
51:            
52:            void  INTERRUPT_Initialize (void)
53:            {
54:                // Enable Interrupt Priority Vectors
55:                RCONbits.IPEN = 1;
6AA2  8ED0     BSF RCON, 7, ACCESS
56:            
57:                // Assign peripheral interrupt priority vectors
58:            
59:                // TMRI - high priority
60:                INTCON2bits.TMR0IP = 1;
6AA4  84F1     BSF INTCON2, 2, ACCESS
61:            
62:                // Interrupt INT0I has no priority bit. It will always be called from the High Interrupt Vector
63:            
64:                // INT3I - high priority
65:                INTCON2bits.INT3IP = 1;
6AA6  82F1     BSF INTCON2, 1, ACCESS
66:            
67:                // INT1I - high priority
68:                INTCON3bits.INT1IP = 1;
6AA8  8CF0     BSF INTCON3, 6, ACCESS
69:            
70:                // INT2I - high priority
71:                INTCON3bits.INT2IP = 1;
6AAA  8EF0     BSF INTCON3, 7, ACCESS
72:            
73:                // TXI - high priority
74:                IPR3bits.TX2IP = 1;
6AAC  88A5     BSF IPR3, 4, ACCESS
75:            
76:                // RCI - high priority
77:                IPR3bits.RC2IP = 1;
6AAE  8AA5     BSF IPR3, 5, ACCESS
78:            
79:                // TXI - high priority
80:                IPR1bits.TX1IP = 1;
6AB0  889F     BSF IPR1, 4, ACCESS
81:            
82:                // RCI - high priority
83:                IPR1bits.RC1IP = 1;
6AB2  8A9F     BSF IPR1, 5, ACCESS
84:            
85:                // TMRI - high priority
86:                IPR2bits.TMR3IP = 1;
6AB4  82A2     BSF IPR2, 1, ACCESS
87:            
88:            
89:                // TMRI - low priority
90:                IPR1bits.TMR1IP = 0;    
6AB6  909F     BCF IPR1, 0, ACCESS
91:            
92:            }
6AB8  0012     RETURN 0
93:            
94:            void __interrupt() INTERRUPT_InterruptManagerHigh (void)
0008  824B     BSF btemp, 1, ACCESS
56A2  CFFA     MOVFF PCLATH, 0x3
95:            {
96:               // interrupt handler
97:                if(INTCONbits.TMR0IE == 1 && INTCONbits.TMR0IF == 1)
56BA  BAF2     BTFSC INTCON, 5, ACCESS
98:                {
99:                    TMR0_ISR();
56C0  ECDA     CALL 0x67B4, 0
100:               }
56C4  D051     BRA 0x5768
101:               else if(INTCONbits.INT0IE == 1 && INTCONbits.INT0IF == 1)
56C6  B8F2     BTFSC INTCON, 4, ACCESS
102:               {
103:                   INT0_ISR();
56CC  ECDC     CALL 0x6BB8, 0
104:               }
56D0  D04B     BRA 0x5768
105:               else if(INTCON3bits.INT3IE == 1 && INTCON3bits.INT3IF == 1)
56D2  BAF0     BTFSC INTCON3, 5, ACCESS
106:               {
107:                   INT3_ISR();
56D8  ECC4     CALL 0x6B88, 0
108:               }
56DC  D045     BRA 0x5768
109:               else if(INTCON3bits.INT1IE == 1 && INTCON3bits.INT1IF == 1)
56DE  B6F0     BTFSC INTCON3, 3, ACCESS
110:               {
111:                   INT1_ISR();
56E4  ECD4     CALL 0x6BA8, 0
112:               }
56E8  D03F     BRA 0x5768
113:               else if(INTCON3bits.INT2IE == 1 && INTCON3bits.INT2IF == 1)
56EA  B8F0     BTFSC INTCON3, 4, ACCESS
114:               {
115:                   INT2_ISR();
56F0  ECCC     CALL 0x6B98, 0
116:               }
56F4  D039     BRA 0x5768
117:               else if(PIE3bits.TX2IE == 1 && PIR3bits.TX2IF == 1)
56F6  B8A3     BTFSC PIE3, 4, ACCESS
118:               {
119:                   EUSART2_TxDefaultInterruptHandler();
56FC  D801     RCALL 0x5700
120:               }
121:               else if(PIE3bits.RC2IE == 1 && PIR3bits.RC2IF == 1)
570E  BAA3     BTFSC PIE3, 5, ACCESS
122:               {
123:                   EUSART2_RxDefaultInterruptHandler();
5714  D801     RCALL 0x5718
124:               }
125:               else if(PIE1bits.TX1IE == 1 && PIR1bits.TX1IF == 1)
5726  B89D     BTFSC PIE1, 4, ACCESS
126:               {
127:                   EUSART1_TxDefaultInterruptHandler();
572C  D801     RCALL 0x5730
128:               }
129:               else if(PIE1bits.RC1IE == 1 && PIR1bits.RC1IF == 1)
573E  BA9D     BTFSC PIE1, 5, ACCESS
130:               {
131:                   EUSART1_RxDefaultInterruptHandler();
5744  D801     RCALL 0x5748
132:               }
133:               else if(PIE2bits.TMR3IE == 1 && PIR2bits.TMR3IF == 1)
575E  B2A0     BTFSC PIE2, 1, ACCESS
134:               {
135:                   TMR3_ISR();
5764  EC65     CALL 0x64CA, 0
136:               }
137:               else
138:               {
139:                   //Unhandled Interrupt
140:               }
141:           }
5768  C008     MOVFF 0x8, PRODH
142:           
143:           void __interrupt(low_priority) INTERRUPT_InterruptManagerLow (void)
0018  804B     BSF btemp, 0, ACCESS
001A  CFD8     MOVFF STATUS, 0xC
001C  F00C     NOP
001E  CFE8     MOVFF WREG, 0xD
0020  F00D     NOP
0022  CFE0     MOVFF BSR, 0xE
0024  F00E     NOP
0026  CFFA     MOVFF PCLATH, 0xF
0028  F00F     NOP
002A  CFFB     MOVFF PCLATU, 0x10
002C  F010     NOP
002E  CFD9     MOVFF FSR2, 0x11
0030  F011     NOP
0032  CFDA     MOVFF FSR2H, 0x12
0034  F012     NOP
0036  CFF3     MOVFF PROD, 0x13
0038  F013     NOP
003A  CFF4     MOVFF PRODH, 0x14
003C  F014     NOP
144:           {
145:               // interrupt handler
146:               if(PIE1bits.TMR1IE == 1 && PIR1bits.TMR1IF == 1)
003E  B09D     BTFSC PIE1, 0, ACCESS
0040  A09E     BTFSS PIR1, 0, ACCESS
0042  D002     BRA 0x48
147:               {
148:                   TMR1_ISR();
0044  EC7B     CALL 0x66F6, 0
0046  F033     NOP
149:               }
150:               else
151:               {
152:                   //Unhandled Interrupt
153:               }
154:           }
0048  C014     MOVFF 0x14, PRODH
004A  FFF4     NOP
004C  C013     MOVFF 0x13, PROD
004E  FFF3     NOP
0050  C012     MOVFF 0x12, FSR2H
0052  FFDA     NOP
0054  C011     MOVFF 0x11, FSR2
0056  FFD9     NOP
0058  C010     MOVFF 0x10, PCLATU
005A  FFFB     NOP
005C  C00F     MOVFF 0xF, PCLATH
005E  FFFA     NOP
0060  C00E     MOVFF 0xE, BSR
0062  FFE0     NOP
0064  C00D     MOVFF 0xD, WREG
0066  FFE8     NOP
0068  C00C     MOVFF 0xC, STATUS
006A  FFD8     NOP
006C  904B     BCF btemp, 0, ACCESS
006E  0010     RETFIE 0
155:           /**
156:            End of File
157:           */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/ext_int.c  -------------------------------------------
1:             /**
2:                EXT_INT Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  ext_int.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the EXT_INT driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for EXT_INT.
15:                 Generation Information :
16:            	 Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	 Device            :  PIC18F45K80
18:            	 Driver Version    :  1.11
19:                 The generated drivers are tested against the following:
20:            	 Compiler          :  XC8 1.45
21:            	 MPLAB             :  MPLAB X 4.15
22:             */
23:            
24:            /**
25:              Section: Includes
26:             */
27:            #include <xc.h>
28:            #include <stdlib.h>
29:            #include "ext_int.h"
30:            
31:            extern APP_DATA appData;
32:            
33:            void (*INT0_InterruptHandler)(void);
34:            void (*INT1_InterruptHandler)(void);
35:            void (*INT2_InterruptHandler)(void);
36:            void (*INT3_InterruptHandler)(void);
37:            
38:            void INT0_ISR(void)
39:            {
40:            	EXT_INT0_InterruptFlagClear();
6BB8  92F2     BCF INTCON, 1, ACCESS
41:            
42:            	// Callback function gets called everytime this ISR executes
43:            	INT0_CallBack();
6BBA  EC07     CALL 0x6A0E, 0
6BBC  F035     NOP
44:            }
6BBE  0012     RETURN 0
45:            
46:            void INT0_CallBack(void)
47:            {
48:            	// Add your custom callback code here
49:            	if (INT0_InterruptHandler) {
6A0E  0101     MOVLB 0x1
6A10  51E7     MOVF 0xE7, W, BANKED
6A12  11E8     IORWF 0xE8, W, BANKED
6A14  B4D8     BTFSC STATUS, 2, ACCESS
6A16  0012     RETURN 0
50:            		INT0_InterruptHandler();
6A18  D801     RCALL 0x6A1C
6A1A  0012     RETURN 0
6A1C  0005     PUSH
6A1E  6EFA     MOVWF PCLATH, ACCESS
6A20  51E7     MOVF 0xE7, W, BANKED
6A22  6EFD     MOVWF TOS, ACCESS
6A24  51E8     MOVF 0xE8, W, BANKED
6A26  6EFE     MOVWF TOSH, ACCESS
6A28  50F8     MOVF TBLPTRU, W, ACCESS
6A2A  6EFF     MOVWF TOSU, ACCESS
6A2C  50FA     MOVF PCLATH, W, ACCESS
6A2E  0012     RETURN 0
51:            	}
52:            }
53:            
54:            void INT0_SetInterruptHandler(void (* InterruptHandler)(void))
55:            {
56:            	INT0_InterruptHandler = InterruptHandler;
6B4C  C015     MOVFF dividend, INT0_InterruptHandler
6B4E  F1E7     NOP
6B50  C016     MOVFF Message, 0x1E8
6B52  F1E8     NOP
57:            }
6B54  0012     RETURN 0
58:            
59:            void INT0_DefaultInterruptHandler(void)
60:            {
61:            	// add your INT0 interrupt custom code
62:            	// or set custom function using INT0_SetInterruptHandler()
63:            	appData.sw1Changed = SW_D_S;
6AE4  0E02     MOVLW 0x2
6AE6  0101     MOVLB 0x1
6AE8  6FDD     MOVWF 0xDD, BANKED
64:            	if (appData.sw2Changed) {
6AEA  51DE     MOVF 0xDE, W, BANKED
6AEC  B4D8     BTFSC STATUS, 2, ACCESS
6AEE  0012     RETURN 0
65:            		// reboot sequence
66:            		RESET();
6AF0  00FF     RESET
6AF2  0012     RETURN 0
67:            	}
68:            }
69:            
70:            void INT1_ISR(void)
71:            {
72:            	EXT_INT1_InterruptFlagClear();
6BA8  90F0     BCF INTCON3, 0, ACCESS
73:            
74:            	// Callback function gets called everytime this ISR executes
75:            	INT1_CallBack();
6BAA  ECF6     CALL 0x69EC, 0
6BAC  F034     NOP
76:            }
6BAE  0012     RETURN 0
77:            
78:            void INT1_CallBack(void)
79:            {
80:            	// Add your custom callback code here
81:            	if (INT1_InterruptHandler) {
69EC  0101     MOVLB 0x1
69EE  51E5     MOVF 0xE5, W, BANKED
69F0  11E6     IORWF 0xE6, W, BANKED
69F2  B4D8     BTFSC STATUS, 2, ACCESS
69F4  0012     RETURN 0
82:            		INT1_InterruptHandler();
69F6  D801     RCALL 0x69FA
69F8  0012     RETURN 0
69FA  0005     PUSH
69FC  6EFA     MOVWF PCLATH, ACCESS
69FE  51E5     MOVF 0xE5, W, BANKED
6A00  6EFD     MOVWF TOS, ACCESS
6A02  51E6     MOVF 0xE6, W, BANKED
6A04  6EFE     MOVWF TOSH, ACCESS
6A06  50F8     MOVF TBLPTRU, W, ACCESS
6A08  6EFF     MOVWF TOSU, ACCESS
6A0A  50FA     MOVF PCLATH, W, ACCESS
6A0C  0012     RETURN 0
83:            	}
84:            }
85:            
86:            void INT1_SetInterruptHandler(void (* InterruptHandler)(void))
87:            {
88:            	INT1_InterruptHandler = InterruptHandler;
6B42  C015     MOVFF dividend, INT1_InterruptHandler
6B44  F1E5     NOP
6B46  C016     MOVFF Message, 0x1E6
6B48  F1E6     NOP
89:            }
6B4A  0012     RETURN 0
90:            
91:            void INT1_DefaultInterruptHandler(void)
92:            {
93:            	// add your INT1 interrupt custom code
94:            	// or set custom function using INT1_SetInterruptHandler()
95:            	appData.sw2Changed = SW_D_L;
6BB0  0E06     MOVLW 0x6
6BB2  0101     MOVLB 0x1
6BB4  6FDE     MOVWF 0xDE, BANKED
96:            }
6BB6  0012     RETURN 0
97:            
98:            void INT2_ISR(void)
99:            {
100:           	EXT_INT2_InterruptFlagClear();
6B98  92F0     BCF INTCON3, 1, ACCESS
101:           
102:           	// Callback function gets called everytime this ISR executes
103:           	INT2_CallBack();
6B9A  ECE5     CALL 0x69CA, 0
6B9C  F034     NOP
104:           }
6B9E  0012     RETURN 0
105:           
106:           void INT2_CallBack(void)
107:           {
108:           	// Add your custom callback code here
109:           	if (INT2_InterruptHandler) {
69CA  0101     MOVLB 0x1
69CC  51E3     MOVF 0xE3, W, BANKED
69CE  11E4     IORWF 0xE4, W, BANKED
69D0  B4D8     BTFSC STATUS, 2, ACCESS
69D2  0012     RETURN 0
110:           		INT2_InterruptHandler();
69D4  D801     RCALL 0x69D8
69D6  0012     RETURN 0
69D8  0005     PUSH
69DA  6EFA     MOVWF PCLATH, ACCESS
69DC  51E3     MOVF 0xE3, W, BANKED
69DE  6EFD     MOVWF TOS, ACCESS
69E0  51E4     MOVF 0xE4, W, BANKED
69E2  6EFE     MOVWF TOSH, ACCESS
69E4  50F8     MOVF TBLPTRU, W, ACCESS
69E6  6EFF     MOVWF TOSU, ACCESS
69E8  50FA     MOVF PCLATH, W, ACCESS
69EA  0012     RETURN 0
111:           	}
112:           }
113:           
114:           void INT2_SetInterruptHandler(void (* InterruptHandler)(void))
115:           {
116:           	INT2_InterruptHandler = InterruptHandler;
6B38  C015     MOVFF dividend, INT2_InterruptHandler
6B3A  F1E3     NOP
6B3C  C016     MOVFF Message, 0x1E4
6B3E  F1E4     NOP
117:           }
6B40  0012     RETURN 0
118:           
119:           void INT2_DefaultInterruptHandler(void)
120:           {
121:           	// add your INT2 interrupt custom code
122:           	// or set custom function using INT2_SetInterruptHandler()
123:           	appData.sw3Changed = SW_D_S;
6BA0  0E02     MOVLW 0x2
6BA2  0101     MOVLB 0x1
6BA4  6FDF     MOVWF 0xDF, BANKED
124:           }
6BA6  0012     RETURN 0
125:           
126:           void INT3_ISR(void)
127:           {
128:           	EXT_INT3_InterruptFlagClear();
6B88  94F0     BCF INTCON3, 2, ACCESS
129:           
130:           	// Callback function gets called everytime this ISR executes
131:           	INT3_CallBack();
6B8A  ECD4     CALL 0x69A8, 0
6B8C  F034     NOP
132:           }
6B8E  0012     RETURN 0
133:           
134:           void INT3_CallBack(void)
135:           {
136:           	// Add your custom callback code here
137:           	if (INT3_InterruptHandler) {
69A8  0101     MOVLB 0x1
69AA  51E1     MOVF 0xE1, W, BANKED
69AC  11E2     IORWF 0xE2, W, BANKED
69AE  B4D8     BTFSC STATUS, 2, ACCESS
69B0  0012     RETURN 0
138:           		INT3_InterruptHandler();
69B2  D801     RCALL 0x69B6
69B4  0012     RETURN 0
69B6  0005     PUSH
69B8  6EFA     MOVWF PCLATH, ACCESS
69BA  51E1     MOVF 0xE1, W, BANKED
69BC  6EFD     MOVWF TOS, ACCESS
69BE  51E2     MOVF 0xE2, W, BANKED
69C0  6EFE     MOVWF TOSH, ACCESS
69C2  50F8     MOVF TBLPTRU, W, ACCESS
69C4  6EFF     MOVWF TOSU, ACCESS
69C6  50FA     MOVF PCLATH, W, ACCESS
69C8  0012     RETURN 0
139:           	}
140:           }
141:           
142:           void INT3_SetInterruptHandler(void (* InterruptHandler)(void))
143:           {
144:           	INT3_InterruptHandler = InterruptHandler;
6B2E  C015     MOVFF dividend, INT3_InterruptHandler
6B30  F1E1     NOP
6B32  C016     MOVFF Message, 0x1E2
6B34  F1E2     NOP
145:           }
6B36  0012     RETURN 0
146:           
147:           void INT3_DefaultInterruptHandler(void)
148:           {
149:           	// add your INT3 interrupt custom code
150:           	// or set custom function using INT3_SetInterruptHandler()
151:           	appData.sw4Changed = SW_D_S;
6B90  0E02     MOVLW 0x2
6B92  0101     MOVLB 0x1
6B94  6FE0     MOVWF 0xE0, BANKED
152:           }
6B96  0012     RETURN 0
153:           
154:           void EXT_INT_Initialize(void)
155:           {
156:           
157:           	// Clear the interrupt flag
158:           	// Set the external interrupt edge detect
159:           	EXT_INT0_InterruptFlagClear();
61E2  92F2     BCF INTCON, 1, ACCESS
160:           	EXT_INT0_fallingEdgeSet();
61E4  9CF1     BCF INTCON2, 6, ACCESS
161:           	// Set Default Interrupt Handler
162:           	INT0_SetInterruptHandler(INT0_DefaultInterruptHandler);
61E6  0EE4     MOVLW 0xE4
61E8  6E15     MOVWF dividend, ACCESS
61EA  0E6A     MOVLW 0x6A
61EC  6E16     MOVWF Message, ACCESS
61EE  ECA6     CALL 0x6B4C, 0
61F0  F035     NOP
163:           	EXT_INT0_InterruptEnable();
61F2  88F2     BSF INTCON, 4, ACCESS
164:           
165:           
166:           	// Clear the interrupt flag
167:           	// Set the external interrupt edge detect
168:           	EXT_INT1_InterruptFlagClear();
61F4  90F0     BCF INTCON3, 0, ACCESS
169:           	EXT_INT1_fallingEdgeSet();
61F6  9AF1     BCF INTCON2, 5, ACCESS
170:           	// Set Default Interrupt Handler
171:           	INT1_SetInterruptHandler(INT1_DefaultInterruptHandler);
61F8  0EB0     MOVLW 0xB0
61FA  6E15     MOVWF dividend, ACCESS
61FC  0E6B     MOVLW 0x6B
61FE  6E16     MOVWF Message, ACCESS
6200  ECA1     CALL 0x6B42, 0
6202  F035     NOP
172:           	EXT_INT1_InterruptEnable();
6204  86F0     BSF INTCON3, 3, ACCESS
173:           
174:           
175:           	// Clear the interrupt flag
176:           	// Set the external interrupt edge detect
177:           	EXT_INT2_InterruptFlagClear();
6206  92F0     BCF INTCON3, 1, ACCESS
178:           	EXT_INT2_fallingEdgeSet();
6208  98F1     BCF INTCON2, 4, ACCESS
179:           	// Set Default Interrupt Handler
180:           	INT2_SetInterruptHandler(INT2_DefaultInterruptHandler);
620A  0EA0     MOVLW 0xA0
620C  6E15     MOVWF dividend, ACCESS
620E  0E6B     MOVLW 0x6B
6210  6E16     MOVWF Message, ACCESS
6212  EC9C     CALL 0x6B38, 0
6214  F035     NOP
181:           	EXT_INT2_InterruptEnable();
6216  88F0     BSF INTCON3, 4, ACCESS
182:           
183:           
184:           	// Clear the interrupt flag
185:           	// Set the external interrupt edge detect
186:           	EXT_INT3_InterruptFlagClear();
6218  94F0     BCF INTCON3, 2, ACCESS
187:           	EXT_INT3_fallingEdgeSet();
621A  96F1     BCF INTCON2, 3, ACCESS
188:           	// Set Default Interrupt Handler
189:           	INT3_SetInterruptHandler(INT3_DefaultInterruptHandler);
621C  0E90     MOVLW 0x90
621E  6E15     MOVWF dividend, ACCESS
6220  0E6B     MOVLW 0x6B
6222  6E16     MOVWF Message, ACCESS
6224  EC97     CALL 0x6B2E, 0
6226  F035     NOP
190:           	EXT_INT3_InterruptEnable();
6228  8AF0     BSF INTCON3, 5, ACCESS
191:           
192:           }
622A  0012     RETURN 0
193:           
---  /fred/mphase_v80/mphase.X/mcc_generated_files/eusart2.c  -------------------------------------------
1:             /**
2:               EUSART2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for EUSART2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:                    Device            :  PIC18F45K80
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 1.45
21:                    MPLAB 	          :  MPLAB X 4.15
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            #include "eusart2.h"
51:            
52:            /**
53:              Section: Macro Declarations
54:            */
55:            
56:            #define EUSART2_TX_BUFFER_SIZE 64
57:            #define EUSART2_RX_BUFFER_SIZE 8
58:            
59:            /**
60:              Section: Global Variables
61:            */
62:            volatile uint8_t eusart2TxHead = 0;
63:            volatile uint8_t eusart2TxTail = 0;
64:            volatile uint8_t eusart2TxBuffer[EUSART2_TX_BUFFER_SIZE];
65:            volatile uint8_t eusart2TxBufferRemaining;
66:            
67:            volatile uint8_t eusart2RxHead = 0;
68:            volatile uint8_t eusart2RxTail = 0;
69:            volatile uint8_t eusart2RxBuffer[EUSART2_RX_BUFFER_SIZE];
70:            volatile uint8_t eusart2RxCount;
71:            
72:            /**
73:              Section: EUSART2 APIs
74:            */
75:            void EUSART2_Initialize(void)
76:            {
77:                // disable interrupts before changing states
78:                PIE3bits.RC2IE = 0;
60F8  9AA3     BCF PIE3, 5, ACCESS
79:                EUSART2_SetRxInterruptHandler(EUSART2_Receive_ISR);
60FA  0EE0     MOVLW 0xE0
60FC  6E15     MOVWF dividend, ACCESS
60FE  0E67     MOVLW 0x67
6100  6E16     MOVWF Message, ACCESS
6102  ECB0     CALL 0x6B60, 0
6104  F035     NOP
80:                PIE3bits.TX2IE = 0;
6106  98A3     BCF PIE3, 4, ACCESS
81:                EUSART2_SetTxInterruptHandler(EUSART2_Transmit_ISR);
6108  0E26     MOVLW 0x26
610A  6E15     MOVWF dividend, ACCESS
610C  0E67     MOVLW 0x67
610E  6E16     MOVWF Message, ACCESS
6110  ECAB     CALL 0x6B56, 0
6112  F035     NOP
82:                // Set the EUSART2 module to the options selected in the user interface.
83:            
84:                // ABDOVF no_overflow; TXCKP async_noninverted_sync_fallingedge; BRG16 16bit_generator; WUE disabled; ABDEN disabled; RXDTP not_inverted; 
85:                BAUDCON2 = 0x08;
6114  0E08     MOVLW 0x8
6116  6EB9     MOVWF BAUDCON2, ACCESS
86:            
87:                // SPEN enabled; RX9 8-bit; CREN enabled; ADDEN disabled; SREN disabled; 
88:                RCSTA2 = 0x90;
6118  0E90     MOVLW 0x90
611A  6EA6     MOVWF RCSTA2, ACCESS
89:            
90:                // TRMT TSR_empty; TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave_mode; 
91:                TXSTA2 = 0x26;
611C  0E26     MOVLW 0x26
611E  6EBA     MOVWF TXSTA2, ACCESS
92:            
93:                // 
94:                SPBRG2 = 0x82;
6120  0E82     MOVLW 0x82
6122  6E7B     MOVWF SPBRG2, ACCESS
95:            
96:                // 
97:                SPBRGH2 = 0x06;
6124  0E06     MOVLW 0x6
6126  6E7C     MOVWF SPBRGH2, ACCESS
98:            
99:            
100:               // initializing the driver state
101:               eusart2TxHead = 0;
6128  0E00     MOVLW 0x0
612A  6E48     MOVWF eusart2TxHead, ACCESS
102:               eusart2TxTail = 0;
612C  0E00     MOVLW 0x0
612E  6E47     MOVWF eusart2TxTail, ACCESS
103:               eusart2TxBufferRemaining = sizeof(eusart2TxBuffer);
6130  0E40     MOVLW 0x40
6132  0101     MOVLB 0x1
6134  6FFC     MOVWF 0xFC, BANKED
104:           
105:               eusart2RxHead = 0;
6136  0E00     MOVLW 0x0
6138  6E46     MOVWF eusart2RxHead, ACCESS
106:               eusart2RxTail = 0;
613A  0E00     MOVLW 0x0
613C  6E45     MOVWF eusart2RxTail, ACCESS
107:               eusart2RxCount = 0;
613E  0E00     MOVLW 0x0
6140  6E44     MOVWF eusart2RxCount, ACCESS
108:           
109:               // enable receive interrupt
110:               PIE3bits.RC2IE = 1;
6142  8AA3     BSF PIE3, 5, ACCESS
111:           }
6144  0012     RETURN 0
112:           
113:           uint8_t EUSART2_is_tx_ready(void)
114:           {
115:               return eusart2TxBufferRemaining;
116:           }
117:           
118:           uint8_t EUSART2_is_rx_ready(void)
119:           {
120:               return eusart2RxCount;
121:           }
122:           
123:           bool EUSART2_is_tx_done(void)
124:           {
125:               return TXSTA2bits.TRMT;
126:           }
127:           
128:           uint8_t EUSART2_Read(void)
129:           {
130:               uint8_t readValue  = 0;
131:               
132:               while(0 == eusart2RxCount)
133:               {
134:               }
135:           
136:               readValue = eusart2RxBuffer[eusart2RxTail++];
137:               if(sizeof(eusart2RxBuffer) <= eusart2RxTail)
138:               {
139:                   eusart2RxTail = 0;
140:               }
141:               PIE3bits.RC2IE = 0;
142:               eusart2RxCount--;
143:               PIE3bits.RC2IE = 1;
144:           
145:               return readValue;
146:           }
147:           
148:           void EUSART2_Write(uint8_t txData)
6332  6E15     MOVWF dividend, ACCESS
149:           {
150:               while(0 == eusart2TxBufferRemaining)
6334  0101     MOVLB 0x1
6336  51FC     MOVF 0xFC, W, BANKED
6338  B4D8     BTFSC STATUS, 2, ACCESS
633A  D7FC     BRA 0x6334
151:               {
152:               }
153:           
154:               if(0 == PIE3bits.TX2IE)
633C  B8A3     BTFSC PIE3, 4, ACCESS
633E  D003     BRA 0x6346
155:               {
156:                   TXREG2 = txData;
6340  C015     MOVFF dividend, TXREG2
6342  FF79     NOP
157:               }
6344  D012     BRA 0x636A
158:               else
159:               {
160:                   PIE3bits.TX2IE = 0;
6346  98A3     BCF PIE3, 4, ACCESS
161:                   eusart2TxBuffer[eusart2TxHead++] = txData;
6348  5048     MOVF eusart2TxHead, W, ACCESS
634A  0D01     MULLW 0x1
634C  0E80     MOVLW 0x80
634E  24F3     ADDWF PROD, W, ACCESS
6350  6ED9     MOVWF FSR2, ACCESS
6352  0E02     MOVLW 0x2
6354  20F4     ADDWFC PRODH, W, ACCESS
6356  6EDA     MOVWF FSR2H, ACCESS
6358  C015     MOVFF dividend, INDF2
635A  FFDF     NOP
635C  2A48     INCF eusart2TxHead, F, ACCESS
162:                   if(sizeof(eusart2TxBuffer) <= eusart2TxHead)
635E  0E3F     MOVLW 0x3F
6360  6448     CPFSGT eusart2TxHead, ACCESS
6362  D002     BRA 0x6368
163:                   {
164:                       eusart2TxHead = 0;
6364  0E00     MOVLW 0x0
6366  6E48     MOVWF eusart2TxHead, ACCESS
165:                   }
166:                   eusart2TxBufferRemaining--;
6368  07FC     DECF 0xFC, F, BANKED
167:               }
168:               PIE3bits.TX2IE = 1;
636A  88A3     BSF PIE3, 4, ACCESS
169:           }
636C  0012     RETURN 0
170:           
171:           //char getch(void)
172:           //{
173:           //    return EUSART2_Read();
174:           //}
175:           
176:           void putch(char txData)
6B7E  6E16     MOVWF Message, ACCESS
177:           {
178:               EUSART2_Write(txData);
6B80  5016     MOVF Message, W, ACCESS
6B82  EC99     CALL 0x6332, 0
6B84  F031     NOP
179:           }
6B86  0012     RETURN 0
180:           
181:           void EUSART2_Transmit_ISR(void)
182:           {
183:           
184:               // add your EUSART2 interrupt custom code
185:               if(sizeof(eusart2TxBuffer) > eusart2TxBufferRemaining)
6726  0E40     MOVLW 0x40
6728  0101     MOVLB 0x1
672A  61FC     CPFSLT 0xFC, BANKED
672C  D012     BRA 0x6752
186:               {
187:                   TXREG2 = eusart2TxBuffer[eusart2TxTail++];
672E  5047     MOVF eusart2TxTail, W, ACCESS
6730  0D01     MULLW 0x1
6732  0E80     MOVLW 0x80
6734  24F3     ADDWF PROD, W, ACCESS
6736  6ED9     MOVWF FSR2, ACCESS
6738  0E02     MOVLW 0x2
673A  20F4     ADDWFC PRODH, W, ACCESS
673C  6EDA     MOVWF FSR2H, ACCESS
673E  50DF     MOVF INDF2, W, ACCESS
6740  6E79     MOVWF TXREG2, ACCESS
6742  2A47     INCF eusart2TxTail, F, ACCESS
188:                   if(sizeof(eusart2TxBuffer) <= eusart2TxTail)
6744  0E3F     MOVLW 0x3F
6746  6447     CPFSGT eusart2TxTail, ACCESS
6748  D002     BRA 0x674E
189:                   {
190:                       eusart2TxTail = 0;
674A  0E00     MOVLW 0x0
674C  6E47     MOVWF eusart2TxTail, ACCESS
191:                   }
192:                   eusart2TxBufferRemaining++;
674E  2BFC     INCF 0xFC, F, BANKED
193:               }
6750  0012     RETURN 0
194:               else
195:               {
196:                   PIE3bits.TX2IE = 0;
6752  98A3     BCF PIE3, 4, ACCESS
6754  0012     RETURN 0
197:               }
198:           }
199:           
200:           void EUSART2_Receive_ISR(void)
201:           {
202:               
203:               if(1 == RCSTA2bits.OERR)
67E0  A2A6     BTFSS RCSTA2, 1, ACCESS
67E2  D002     BRA 0x67E8
204:               {
205:                   // EUSART2 error - restart
206:           
207:                   RCSTA2bits.CREN = 0;
67E4  98A6     BCF RCSTA2, 4, ACCESS
208:                   RCSTA2bits.CREN = 1;
67E6  88A6     BSF RCSTA2, 4, ACCESS
209:               }
210:           
211:               // buffer overruns are ignored
212:               eusart2RxBuffer[eusart2RxHead++] = RCREG2;
67E8  5046     MOVF eusart2RxHead, W, ACCESS
67EA  0D01     MULLW 0x1
67EC  0E0E     MOVLW 0xE
67EE  24F3     ADDWF PROD, W, ACCESS
67F0  6ED9     MOVWF FSR2, ACCESS
67F2  0E01     MOVLW 0x1
67F4  20F4     ADDWFC PRODH, W, ACCESS
67F6  6EDA     MOVWF FSR2H, ACCESS
67F8  CF7A     MOVFF RCREG2, INDF2
67FA  FFDF     NOP
67FC  2A46     INCF eusart2RxHead, F, ACCESS
213:               if(sizeof(eusart2RxBuffer) <= eusart2RxHead)
67FE  0E07     MOVLW 0x7
6800  6446     CPFSGT eusart2RxHead, ACCESS
6802  D002     BRA 0x6808
214:               {
215:                   eusart2RxHead = 0;
6804  0E00     MOVLW 0x0
6806  6E46     MOVWF eusart2RxHead, ACCESS
216:               }
217:               eusart2RxCount++;
6808  2A44     INCF eusart2RxCount, F, ACCESS
218:           }
680A  0012     RETURN 0
219:           
220:           void EUSART2_SetTxInterruptHandler(void (* interruptHandler)(void)){
221:               EUSART2_TxDefaultInterruptHandler = interruptHandler;
6B56  C015     MOVFF dividend, EUSART2_TxDefaultInterruptHandler
6B58  F1F7     NOP
6B5A  C016     MOVFF Message, 0x1F8
6B5C  F1F8     NOP
222:           }
6B5E  0012     RETURN 0
223:           
224:           void EUSART2_SetRxInterruptHandler(void (* interruptHandler)(void)){
225:               EUSART2_RxDefaultInterruptHandler = interruptHandler;
6B60  C015     MOVFF dividend, EUSART2_RxDefaultInterruptHandler
6B62  F1F5     NOP
6B64  C016     MOVFF Message, 0x1F6
6B66  F1F6     NOP
226:           }
6B68  0012     RETURN 0
227:           /**
228:             End of File
229:           */
---  /fred/mphase_v80/mphase.X/mcc_generated_files/eusart1.c  -------------------------------------------
1:             /**
2:               EUSART1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 eusart1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the EUSART1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for EUSART1.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F45K80
18:            	Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:            	Compiler          :  XC8 1.45
21:            	MPLAB 	          :  MPLAB X 4.15
22:             */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:             */
46:            
47:            /**
48:              Section: Included Files
49:             */
50:            #include "eusart1.h"
51:            #include "pin_manager.h"
52:            #include "../config.h"
53:            
54:            /**
55:              Section: Macro Declarations
56:             */
57:            
58:            #define EUSART1_TX_BUFFER_SIZE 64
59:            #define EUSART1_RX_BUFFER_SIZE 64
60:            
61:            /**
62:              Section: Global Variables
63:             */
64:            volatile uint8_t eusart1TxHead = 0;
65:            volatile uint8_t eusart1TxTail = 0;
66:            volatile uint8_t eusart1TxBuffer[EUSART1_TX_BUFFER_SIZE];
67:            volatile uint8_t eusart1TxBufferRemaining;
68:            
69:            volatile uint8_t eusart1RxHead = 0;
70:            volatile uint8_t eusart1RxTail = 0;
71:            volatile uint8_t eusart1RxBuffer[EUSART1_RX_BUFFER_SIZE];
72:            volatile uint8_t eusart1RxCount;
73:            
74:            /**
75:              Section: EUSART1 APIs
76:             */
77:            void EUSART1_Initialize(void)
78:            {
79:            	// disable interrupts before changing states
80:            	PIE1bits.RC1IE = 0;
6146  9A9D     BCF PIE1, 5, ACCESS
81:            	EUSART1_SetRxInterruptHandler(EUSART1_Receive_ISR);
6148  0E76     MOVLW 0x76
614A  6E15     MOVWF dividend, ACCESS
614C  0E62     MOVLW 0x62
614E  6E16     MOVWF Message, ACCESS
6150  ECBA     CALL 0x6B74, 0
6152  F035     NOP
82:            	PIE1bits.TX1IE = 0;
6154  989D     BCF PIE1, 4, ACCESS
83:            	EUSART1_SetTxInterruptHandler(EUSART1_Transmit_ISR);
6156  0E56     MOVLW 0x56
6158  6E15     MOVWF dividend, ACCESS
615A  0E67     MOVLW 0x67
615C  6E16     MOVWF Message, ACCESS
615E  ECB5     CALL 0x6B6A, 0
6160  F035     NOP
84:            	// Set the EUSART1 module to the options selected in the user interface.
85:            
86:            	// ABDOVF no_overflow; TXCKP async_noninverted_sync_fallingedge; BRG16 16bit_generator; WUE disabled; ABDEN disabled; RXDTP not_inverted; 
87:            	BAUDCON1 = 0x08;
6162  0E08     MOVLW 0x8
6164  6EA7     MOVWF BAUDCON1, ACCESS
88:            
89:            	// SPEN enabled; RX9 8-bit; RX9D 0; CREN enabled; ADDEN disabled; SREN disabled; 
90:            	RCSTA1 = 0x90;
6166  0E90     MOVLW 0x90
6168  6EAB     MOVWF RCSTA1, ACCESS
91:            
92:            	// TX9 8-bit; TX9D 0; SENDB sync_break_complete; TXEN enabled; SYNC asynchronous; BRGH hi_speed; CSRC slave_mode; 
93:            	TXSTA1 = 0x24;
616A  0E24     MOVLW 0x24
616C  6EAC     MOVWF TXSTA1, ACCESS
94:            
95:            	// 
96:            	SPBRG1 = 0x82;
616E  0E82     MOVLW 0x82
6170  6EAF     MOVWF SPBRG1, ACCESS
97:            
98:            	// 
99:            	SPBRGH1 = 0x06;
6172  0E06     MOVLW 0x6
6174  6E7D     MOVWF SPBRGH1, ACCESS
100:           
101:           
102:           	// initializing the driver state
103:           	eusart1TxHead = 0;
6176  0E00     MOVLW 0x0
6178  6E43     MOVWF eusart1TxHead, ACCESS
104:           	eusart1TxTail = 0;
617A  0E00     MOVLW 0x0
617C  6E42     MOVWF eusart1TxTail, ACCESS
105:           	eusart1TxBufferRemaining = sizeof(eusart1TxBuffer);
617E  0E40     MOVLW 0x40
6180  0101     MOVLB 0x1
6182  6FFB     MOVWF 0xFB, BANKED
106:           
107:           	eusart1RxHead = 0;
6184  0E00     MOVLW 0x0
6186  6E41     MOVWF eusart1RxHead, ACCESS
108:           	eusart1RxTail = 0;
6188  0E00     MOVLW 0x0
618A  6E40     MOVWF eusart1RxTail, ACCESS
109:           	eusart1RxCount = 0;
618C  0E00     MOVLW 0x0
618E  6E3F     MOVWF eusart1RxCount, ACCESS
110:           
111:           	// enable receive interrupt
112:           	PIE1bits.RC1IE = 1;
6190  8A9D     BSF PIE1, 5, ACCESS
113:           }
6192  0012     RETURN 0
114:           
115:           uint8_t EUSART1_is_tx_ready(void)
116:           {
117:           	return eusart1TxBufferRemaining;
118:           }
119:           
120:           uint8_t EUSART1_is_rx_ready(void)
121:           {
122:           
123:           	return eusart1RxCount;
6BD2  503F     MOVF eusart1RxCount, W, ACCESS
6BD4  0012     RETURN 0
124:           }
125:           
126:           bool EUSART1_is_tx_done(void)
127:           {
128:           	return TXSTA1bits.TRMT;
129:           }
130:           
131:           uint8_t EUSART1_Read(void)
132:           {
133:           	uint8_t readValue = 0;
65A0  0E00     MOVLW 0x0
65A2  6E15     MOVWF dividend, ACCESS
134:           
135:           	while (0 == eusart1RxCount) {
65A4  503F     MOVF eusart1RxCount, W, ACCESS
65A6  B4D8     BTFSC STATUS, 2, ACCESS
65A8  D7FD     BRA 0x65A4
136:           	}
137:           
138:           	readValue = eusart1RxBuffer[eusart1RxTail++];
65AA  5040     MOVF eusart1RxTail, W, ACCESS
65AC  0D01     MULLW 0x1
65AE  0E00     MOVLW 0x0
65B0  24F3     ADDWF PROD, W, ACCESS
65B2  6ED9     MOVWF FSR2, ACCESS
65B4  0E02     MOVLW 0x2
65B6  20F4     ADDWFC PRODH, W, ACCESS
65B8  6EDA     MOVWF FSR2H, ACCESS
65BA  50DF     MOVF INDF2, W, ACCESS
65BC  6E15     MOVWF dividend, ACCESS
65BE  2A40     INCF eusart1RxTail, F, ACCESS
139:           	if (sizeof(eusart1RxBuffer) <= eusart1RxTail) {
65C0  0E3F     MOVLW 0x3F
65C2  6440     CPFSGT eusart1RxTail, ACCESS
65C4  D002     BRA 0x65CA
140:           		eusart1RxTail = 0;
65C6  0E00     MOVLW 0x0
65C8  6E40     MOVWF eusart1RxTail, ACCESS
141:           	}
142:           	PIE1bits.RC1IE = 0;
65CA  9A9D     BCF PIE1, 5, ACCESS
143:           	eusart1RxCount--;
65CC  063F     DECF eusart1RxCount, F, ACCESS
144:           	PIE1bits.RC1IE = 1;
65CE  8A9D     BSF PIE1, 5, ACCESS
145:           
146:           	return readValue;
65D0  5015     MOVF dividend, W, ACCESS
65D2  0012     RETURN 0
147:           }
148:           
149:           void EUSART1_Write(uint8_t txData)
636E  6E15     MOVWF dividend, ACCESS
150:           {
151:           	while (0 == eusart1TxBufferRemaining) {
6370  0101     MOVLB 0x1
6372  51FB     MOVF 0xFB, W, BANKED
6374  B4D8     BTFSC STATUS, 2, ACCESS
6376  D7FC     BRA 0x6370
152:           	}
153:           
154:           	if (0 == PIE1bits.TX1IE) {
6378  B89D     BTFSC PIE1, 4, ACCESS
637A  D003     BRA 0x6382
155:           		TXREG1 = txData;
637C  C015     MOVFF dividend, TXREG1
637E  FFAD     NOP
156:           	} else {
6380  D012     BRA 0x63A6
157:           		PIE1bits.TX1IE = 0;
6382  989D     BCF PIE1, 4, ACCESS
158:           		eusart1TxBuffer[eusart1TxHead++] = txData;
6384  5043     MOVF eusart1TxHead, W, ACCESS
6386  0D01     MULLW 0x1
6388  0E40     MOVLW 0x40
638A  24F3     ADDWF PROD, W, ACCESS
638C  6ED9     MOVWF FSR2, ACCESS
638E  0E02     MOVLW 0x2
6390  20F4     ADDWFC PRODH, W, ACCESS
6392  6EDA     MOVWF FSR2H, ACCESS
6394  C015     MOVFF dividend, INDF2
6396  FFDF     NOP
6398  2A43     INCF eusart1TxHead, F, ACCESS
159:           		if (sizeof(eusart1TxBuffer) <= eusart1TxHead) {
639A  0E3F     MOVLW 0x3F
639C  6443     CPFSGT eusart1TxHead, ACCESS
639E  D002     BRA 0x63A4
160:           			eusart1TxHead = 0;
63A0  0E00     MOVLW 0x0
63A2  6E43     MOVWF eusart1TxHead, ACCESS
161:           		}
162:           		eusart1TxBufferRemaining--;
63A4  07FB     DECF 0xFB, F, BANKED
163:           	}
164:           	PIE1bits.TX1IE = 1;
63A6  889D     BSF PIE1, 4, ACCESS
165:           }
63A8  0012     RETURN 0
166:           
167:           void EUSART1_Transmit_ISR(void)
168:           {
169:           
170:           	// add your EUSART1 interrupt custom code
171:           	if (sizeof(eusart1TxBuffer) > eusart1TxBufferRemaining) {
6756  0E40     MOVLW 0x40
6758  0101     MOVLB 0x1
675A  61FB     CPFSLT 0xFB, BANKED
675C  D012     BRA 0x6782
172:           		TXREG1 = eusart1TxBuffer[eusart1TxTail++];
675E  5042     MOVF eusart1TxTail, W, ACCESS
6760  0D01     MULLW 0x1
6762  0E40     MOVLW 0x40
6764  24F3     ADDWF PROD, W, ACCESS
6766  6ED9     MOVWF FSR2, ACCESS
6768  0E02     MOVLW 0x2
676A  20F4     ADDWFC PRODH, W, ACCESS
676C  6EDA     MOVWF FSR2H, ACCESS
676E  50DF     MOVF INDF2, W, ACCESS
6770  6EAD     MOVWF TXREG1, ACCESS
6772  2A42     INCF eusart1TxTail, F, ACCESS
173:           		if (sizeof(eusart1TxBuffer) <= eusart1TxTail) {
6774  0E3F     MOVLW 0x3F
6776  6442     CPFSGT eusart1TxTail, ACCESS
6778  D002     BRA 0x677E
174:           			eusart1TxTail = 0;
677A  0E00     MOVLW 0x0
677C  6E42     MOVWF eusart1TxTail, ACCESS
175:           		}
176:           		eusart1TxBufferRemaining++;
677E  2BFB     INCF 0xFB, F, BANKED
177:           	} else {
6780  0012     RETURN 0
178:           		PIE1bits.TX1IE = 0;
6782  989D     BCF PIE1, 4, ACCESS
6784  0012     RETURN 0
179:           	}
180:           }
181:           
182:           void EUSART1_Receive_ISR(void)
183:           {
184:           	uint8_t treg;
185:           	if (1 == RCSTA1bits.OERR) {
6276  A2AB     BTFSS RCSTA1, 1, ACCESS
6278  D002     BRA 0x627E
186:           		// EUSART1 error - restart
187:           
188:           		RCSTA1bits.CREN = 0;
627A  98AB     BCF RCSTA1, 4, ACCESS
189:           		RCSTA1bits.CREN = 1;
627C  88AB     BSF RCSTA1, 4, ACCESS
190:           	}
191:           
192:           	// buffer overruns are ignored
193:           	treg = RCREG1;
627E  CFAE     MOVFF RCREG1, __pcstackCOMRAM
6280  F001     NOP
194:           	/*
195:           	 * ignore MC prompt chars
196:           	 */
197:           #ifdef	COOKED_MC
198:           	if ((treg != '-') && (treg != '>')) {
6282  0E2D     MOVLW 0x2D
6284  1801     XORWF __pcstackCOMRAM, W, ACCESS
6286  B4D8     BTFSC STATUS, 2, ACCESS
6288  0012     RETURN 0
628A  0E3E     MOVLW 0x3E
628C  1801     XORWF __pcstackCOMRAM, W, ACCESS
628E  B4D8     BTFSC STATUS, 2, ACCESS
6290  0012     RETURN 0
199:           #endif
200:           		eusart1RxBuffer[eusart1RxHead++] = treg;
6292  5041     MOVF eusart1RxHead, W, ACCESS
6294  0D01     MULLW 0x1
6296  0E00     MOVLW 0x0
6298  24F3     ADDWF PROD, W, ACCESS
629A  6ED9     MOVWF FSR2, ACCESS
629C  0E02     MOVLW 0x2
629E  20F4     ADDWFC PRODH, W, ACCESS
62A0  6EDA     MOVWF FSR2H, ACCESS
62A2  C001     MOVFF __pcstackCOMRAM, INDF2
62A4  FFDF     NOP
62A6  2A41     INCF eusart1RxHead, F, ACCESS
201:           		if (sizeof(eusart1RxBuffer) <= eusart1RxHead) {
62A8  0E3F     MOVLW 0x3F
62AA  6441     CPFSGT eusart1RxHead, ACCESS
62AC  D002     BRA 0x62B2
202:           			eusart1RxHead = 0;
62AE  0E00     MOVLW 0x0
62B0  6E41     MOVWF eusart1RxHead, ACCESS
203:           		}
204:           		eusart1RxCount++;
62B2  2A3F     INCF eusart1RxCount, F, ACCESS
62B4  0012     RETURN 0
205:           #ifdef	COOKED_MC
206:           	}
207:           #endif
208:           }
209:           
210:           void EUSART1_SetTxInterruptHandler(void (* interruptHandler)(void))
211:           {
212:           	EUSART1_TxDefaultInterruptHandler = interruptHandler;
6B6A  C015     MOVFF dividend, EUSART1_TxDefaultInterruptHandler
6B6C  F1F3     NOP
6B6E  C016     MOVFF Message, 0x1F4
6B70  F1F4     NOP
213:           }
6B72  0012     RETURN 0
214:           
215:           void EUSART1_SetRxInterruptHandler(void (* interruptHandler)(void))
216:           {
217:           	EUSART1_RxDefaultInterruptHandler = interruptHandler;
6B74  C015     MOVFF dividend, EUSART1_RxDefaultInterruptHandler
6B76  F1F1     NOP
6B78  C016     MOVFF Message, 0x1F2
6B7A  F1F2     NOP
218:           }
6B7C  0012     RETURN 0
219:           /**
220:             End of File
221:            */
---  /fred/mphase_v80/mphase.X/main.c  ------------------------------------------------------------------
1:             /**
2:               Generated Main Source File
3:             
4:               Company:
5:                 Microchip Technology Inc.
6:             
7:               File Name:
8:                 main.c
9:             
10:              Summary:
11:                This is the main file generated using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              Description:
14:                This header file provides implementations for driver APIs for all modules selected in the GUI.
15:                Generation Information :
16:            	Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.65.2
17:            	Device            :  PIC18F45K80
18:            	Driver Version    :  2.00
19:             */
20:            
21:            /*
22:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
23:                
24:                Subject to your compliance with these terms, you may use Microchip software and any 
25:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
26:                license terms applicable to your use of third party software (including open source software) that 
27:                may accompany Microchip software.
28:                
29:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
30:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
31:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
32:                FOR A PARTICULAR PURPOSE.
33:                
34:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
35:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
36:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
37:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
38:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
39:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
40:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
41:                SOFTWARE.
42:             */
43:            
44:            // XC8 bogus warnings from MCC code
45:            #pragma warning disable 520
46:            #pragma warning disable 1498 
47:            
48:            #include "mcc_generated_files/mcc.h"
49:            #include "app.h"
50:            #include "config.h"
51:            
52:            /*
53:             *	Main application MPHASE
54:             *	A simple command, response parser that generates the proper offset angle
55:             *	to program a direct drive servo motor system with a resolver for the
56:             *	drive angle rotation/speed feedback. Serial port 1 sends and receives data on the
57:             *	servo control port. Serial port 2 updates a 4*20 LCD display.
58:             *	Both serial ports are 9600 baud with no flow control.
59:             * 
60:             *	There are two control buttons for the operator interface LCD. The top button near the
61:             *	display is the 'OK' that should be pressed after the required action on the
62:             *	LCD display has been executed. The second smaller button near the bottom is
63:             *	the 'BOOT' button that allows the operator to bypass the wait for the
64:             *	servo controller auto boot sequence so the operator can program an already running
65:             *	motor control system. The 'BOOT' button can also reboot the MHPASE box by quickly pressing 
66:             *	the 'BOOT' button and then the 'OK' button in sequence.
67:             * 
68:             *	Normally the servo controller is powered off first for a resolver calibration.
69:             *	The MPHASE box serial cable with DB9 connector is attached to the servo DB9 serial port,
70:             *	power is supplied to the MPHASE box via the attached power brick and
71:             *	then 'RUN' power is switched on to the servo controller and motor.
72:             *	The MPHASE box display should display a series of prompts with audio beeps 
73:             *	if the serial connection is correct and the servo responds in the expected manner.
74:             */
75:            
76:            typedef struct card {
77:            	int Valid, Lenght, Offset, Array[16];
78:            } card;
79:            
80:            struct card Card={
81:            	.Lenght=15,
82:            	.Offset=1,
83:            	.Valid=0,
84:            };
85:            
86:            int Buff_In = 0, i;
87:            
88:            void main(void)
89:            {
90:            	// Initialize the device
91:            	SYSTEM_Initialize();
53A8  EC06     CALL 0x680C, 0
53AA  F034     NOP
92:            	PIN_MANAGER_IOC();
53AC  ECE3     CALL 0x6BC6, 0
53AE  F035     NOP
93:            
94:            	// If using interrupts in PIC18 High/Low Priority Mode you need to enable the Global High and Low Interrupts
95:            	// If using interrupts in PIC Mid-Range Compatibility Mode you need to enable the Global and Peripheral Interrupts
96:            	// Use the following macros to:
97:            
98:            	// Enable high priority global interrupts
99:            	INTERRUPT_GlobalInterruptHighEnable();
53B0  8EF2     BSF INTCON, 7, ACCESS
100:           
101:           	// Enable low priority global interrupts.
102:           	INTERRUPT_GlobalInterruptLowEnable();
53B2  8CF2     BSF INTCON, 6, ACCESS
103:           
104:           	// Disable high priority global interrupts
105:           	//INTERRUPT_GlobalInterruptHighDisable();
106:           
107:           	// Disable low priority global interrupts.
108:           	//INTERRUPT_GlobalInterruptLowDisable();
109:           
110:           	// Enable the Peripheral Interrupts
111:           	INTERRUPT_PeripheralInterruptEnable();
53B4  8CF2     BSF INTCON, 6, ACCESS
112:           
113:           	// Disable the Peripheral Interrupts
114:           	//INTERRUPT_PeripheralInterruptDisable();
115:           
116:           	for (i = 0; i <= Card.Lenght; i++) {
53B6  0E00     MOVLW 0x0
53B8  0101     MOVLB 0x1
53BA  6F23     MOVWF sep, BANKED
53BC  0E00     MOVLW 0x0
53BE  6F22     MOVWF s, BANKED
53C0  D029     BRA 0x5414
117:           		Card.Valid += (unsigned int) (Card.Array[i + Card.Offset * Card.Lenght] == Buff_In);
53C2  C2C4     MOVFF 0x2C4, dividend
53C4  F015     NOP
53C6  C2C5     MOVFF 0x2C5, Message
53C8  F016     NOP
53CA  C2C2     MOVFF 0x2C2, _r
53CC  F017     NOP
53CE  C2C3     MOVFF 0x2C3, 0x18
53D0  F018     NOP
53D2  EC57     CALL 0x68AE, 0
53D4  F034     NOP
53D6  0101     MOVLB 0x1
53D8  5122     MOVF s, W, BANKED
53DA  2615     ADDWF dividend, F, ACCESS
53DC  5123     MOVF sep, W, BANKED
53DE  2216     ADDWFC Message, F, ACCESS
53E0  90D8     BCF STATUS, 0, ACCESS
53E2  3615     RLCF dividend, F, ACCESS
53E4  3616     RLCF Message, F, ACCESS
53E6  0EC6     MOVLW 0xC6
53E8  2415     ADDWF dividend, W, ACCESS
53EA  6ED9     MOVWF FSR2, ACCESS
53EC  0E02     MOVLW 0x2
53EE  2016     ADDWFC Message, W, ACCESS
53F0  6EDA     MOVWF FSR2H, ACCESS
53F2  5124     MOVF n, W, BANKED
53F4  18DE     XORWF POSTINC2, W, ACCESS
53F6  E106     BNZ 0x5404
53F8  5125     MOVF quotient, W, BANKED
53FA  18DE     XORWF POSTINC2, W, ACCESS
53FC  A4D8     BTFSS STATUS, 2, ACCESS
53FE  D002     BRA 0x5404
5400  0E01     MOVLW 0x1
5402  D001     BRA 0x5406
5404  0E00     MOVLW 0x0
5406  0102     MOVLB 0x2
5408  27C0     ADDWF 0xC0, F, BANKED
540A  0E00     MOVLW 0x0
540C  23C1     ADDWFC 0xC1, F, BANKED
118:           	}
540E  0101     MOVLB 0x1
5410  4B22     INFSNZ s, F, BANKED
5412  2B23     INCF sep, F, BANKED
5414  5122     MOVF s, W, BANKED
5416  0102     MOVLB 0x2
5418  5DC2     SUBWF 0xC2, W, BANKED
541A  51C3     MOVF 0xC3, W, BANKED
541C  0A80     XORLW 0x80
541E  0100     MOVLB 0x0
5420  6FCD     MOVWF 0xCD, BANKED
5422  0101     MOVLB 0x1
5424  5123     MOVF sep, W, BANKED
5426  0A80     XORLW 0x80
5428  0100     MOVLB 0x0
542A  59CD     SUBWFB 0xCD, W, BANKED
542C  B0D8     BTFSC STATUS, 0, ACCESS
542E  D7C9     BRA 0x53C2
119:           
120:           	for (i = 0; i <= Card.Lenght; i++) {
5430  0E00     MOVLW 0x0
5432  0101     MOVLB 0x1
5434  6F23     MOVWF sep, BANKED
5436  0E00     MOVLW 0x0
5438  6F22     MOVWF s, BANKED
543A  D029     BRA 0x548E
121:           		Card.Valid += (Card.Array[i + Card.Offset * Card.Lenght] == Buff_In) ? 1 : 0;
543C  C2C4     MOVFF 0x2C4, dividend
543E  F015     NOP
5440  C2C5     MOVFF 0x2C5, Message
5442  F016     NOP
5444  C2C2     MOVFF 0x2C2, _r
5446  F017     NOP
5448  C2C3     MOVFF 0x2C3, 0x18
544A  F018     NOP
544C  EC57     CALL 0x68AE, 0
544E  F034     NOP
5450  0101     MOVLB 0x1
5452  5122     MOVF s, W, BANKED
5454  2615     ADDWF dividend, F, ACCESS
5456  5123     MOVF sep, W, BANKED
5458  2216     ADDWFC Message, F, ACCESS
545A  90D8     BCF STATUS, 0, ACCESS
545C  3615     RLCF dividend, F, ACCESS
545E  3616     RLCF Message, F, ACCESS
5460  0EC6     MOVLW 0xC6
5462  2415     ADDWF dividend, W, ACCESS
5464  6ED9     MOVWF FSR2, ACCESS
5466  0E02     MOVLW 0x2
5468  2016     ADDWFC Message, W, ACCESS
546A  6EDA     MOVWF FSR2H, ACCESS
546C  5124     MOVF n, W, BANKED
546E  18DE     XORWF POSTINC2, W, ACCESS
5470  E106     BNZ 0x547E
5472  5125     MOVF quotient, W, BANKED
5474  18DE     XORWF POSTINC2, W, ACCESS
5476  A4D8     BTFSS STATUS, 2, ACCESS
5478  D002     BRA 0x547E
547A  0E01     MOVLW 0x1
547C  D001     BRA 0x5480
547E  0E00     MOVLW 0x0
5480  0102     MOVLB 0x2
5482  27C0     ADDWF 0xC0, F, BANKED
5484  0E00     MOVLW 0x0
5486  23C1     ADDWFC 0xC1, F, BANKED
122:           	}
5488  0101     MOVLB 0x1
548A  4B22     INFSNZ s, F, BANKED
548C  2B23     INCF sep, F, BANKED
548E  5122     MOVF s, W, BANKED
5490  0102     MOVLB 0x2
5492  5DC2     SUBWF 0xC2, W, BANKED
5494  51C3     MOVF 0xC3, W, BANKED
5496  0A80     XORLW 0x80
5498  0100     MOVLB 0x0
549A  6FCD     MOVWF 0xCD, BANKED
549C  0101     MOVLB 0x1
549E  5123     MOVF sep, W, BANKED
54A0  0A80     XORLW 0x80
54A2  0100     MOVLB 0x0
54A4  59CD     SUBWFB 0xCD, W, BANKED
54A6  B0D8     BTFSC STATUS, 0, ACCESS
54A8  D7C9     BRA 0x543C
123:           
124:           	while (true) {
125:           		APP_Tasks();
54AA  ECEE     CALL 0x13DC, 0
54AC  F009     NOP
126:           	}
54AE  D7FD     BRA 0x54AA
127:           }
128:           /**
129:            End of File
130:            */
---  /fred/mphase_v80/mphase.X/board/ea_display.c  ------------------------------------------------------
1:             #include "ea_display.h"
2:             
3:             static const char d_reset[] = "\eR";
4:             static const char d_version[] = "\eV";
5:             static const char d_ff[] = "\x0C";
6:             static const char d_cur_off[] = "\eC0";
7:             
8:             void display_ea_init(uint16_t pause)
9:             {
10:            	printf("%s", d_reset);
68F8  0E92     MOVLW 0x92
68FA  0100     MOVLB 0x0
68FC  6FB4     MOVWF s, BANKED
68FE  0E7F     MOVLW 0x7F
6900  6FB5     MOVWF 0xB5, BANKED
6902  0EB7     MOVLW 0xB7
6904  6FB6     MOVWF fmt, BANKED
6906  0E7D     MOVLW 0x7D
6908  6FB7     MOVWF 0xB7, BANKED
690A  EC03     CALL 0x6606, 0
690C  F033     NOP
11:            	WaitMs(pause);
690E  C0BC     MOVFF ret, s
6910  F01A     NOP
6912  C0BD     MOVFF 0xBD, c
6914  F01B     NOP
6916  EC27     CALL 0x6A4E, 0
6918  F035     NOP
12:            }
691A  0012     RETURN 0
13:            
14:            void display_ea_version(uint16_t pause)
15:            {
16:            	printf("%s", d_version);
68D4  0E92     MOVLW 0x92
68D6  0100     MOVLB 0x0
68D8  6FB4     MOVWF s, BANKED
68DA  0E7F     MOVLW 0x7F
68DC  6FB5     MOVWF 0xB5, BANKED
68DE  0EB4     MOVLW 0xB4
68E0  6FB6     MOVWF fmt, BANKED
68E2  0E7D     MOVLW 0x7D
68E4  6FB7     MOVWF 0xB7, BANKED
68E6  EC03     CALL 0x6606, 0
68E8  F033     NOP
17:            	WaitMs(pause);
68EA  C0BC     MOVFF ret, s
68EC  F01A     NOP
68EE  C0BD     MOVFF 0xBD, c
68F0  F01B     NOP
68F2  EC27     CALL 0x6A4E, 0
68F4  F035     NOP
18:            }
68F6  0012     RETURN 0
19:            
20:            void display_ea_ff(uint16_t pause)
21:            {
22:            	printf("%s", d_ff);
691C  0E92     MOVLW 0x92
691E  0100     MOVLB 0x0
6920  6FB4     MOVWF s, BANKED
6922  0E7F     MOVLW 0x7F
6924  6FB5     MOVWF 0xB5, BANKED
6926  0EBA     MOVLW 0xBA
6928  6FB6     MOVWF fmt, BANKED
692A  0E7D     MOVLW 0x7D
692C  6FB7     MOVWF 0xB7, BANKED
692E  EC03     CALL 0x6606, 0
6930  F033     NOP
23:            	WaitMs(pause);
6932  C0BC     MOVFF ret, s
6934  F01A     NOP
6936  C0BD     MOVFF 0xBD, c
6938  F01B     NOP
693A  EC27     CALL 0x6A4E, 0
693C  F035     NOP
24:            }
693E  0012     RETURN 0
25:            
26:            void display_ea_cursor_off(uint16_t pause)
27:            {
28:            	printf("%s", d_cur_off);
6940  0E92     MOVLW 0x92
6942  0100     MOVLB 0x0
6944  6FB4     MOVWF s, BANKED
6946  0E7F     MOVLW 0x7F
6948  6FB5     MOVWF 0xB5, BANKED
694A  0EB0     MOVLW 0xB0
694C  6FB6     MOVWF fmt, BANKED
694E  0E7D     MOVLW 0x7D
6950  6FB7     MOVWF 0xB7, BANKED
6952  EC03     CALL 0x6606, 0
6954  F033     NOP
29:            	WaitMs(pause);
6956  C0BC     MOVFF ret, s
6958  F01A     NOP
695A  C0BD     MOVFF 0xBD, c
695C  F01B     NOP
695E  EC27     CALL 0x6A4E, 0
6960  F035     NOP
30:            }
6962  0012     RETURN 0
31:            
32:            void display_ea_line(char * line)
33:            {
34:            	printf("%s", line);
6ABA  0E92     MOVLW 0x92
6ABC  0100     MOVLB 0x0
6ABE  6FB4     MOVWF s, BANKED
6AC0  0E7F     MOVLW 0x7F
6AC2  6FB5     MOVWF 0xB5, BANKED
6AC4  C0BC     MOVFF ret, fmt
6AC6  F0B6     NOP
6AC8  C0BD     MOVFF 0xBD, 0xB7
6ACA  F0B7     NOP
6ACC  EC03     CALL 0x6606, 0
6ACE  F033     NOP
35:            }
6AD0  0012     RETURN 0
---  /fred/mphase_v80/mphase.X/app.c  -------------------------------------------------------------------
1:             
2:             #include <xc.h>
3:             #include <stdint.h>
4:             #include <stdbool.h>
5:             #include <stdio.h>
6:             #include <string.h>
7:             #include "app.h"
8:             #include "config.h"
9:             #include "timers.h"
10:            #include "pfb.h"
11:            #include "mcc_generated_files/tmr0.h"
12:            #include "mcc_generated_files/tmr1.h"
13:            #include "board/ea_display.h"
14:            #include "mcc_generated_files/eusart1.h"
15:            
16:            /*
17:             * application data structures, state machine variables
18:             */
19:            APP_DATA appData = {
20:            	.error_code = ERROR_NONE,
21:            	.got_packet = false,
22:            	.state = APP_INITIALIZE,
23:            	.mc = MC_INITIALIZE,
24:            	.sw1 = false,
25:            	.sw2 = false,
26:            	.sw3 = false,
27:            	.sw4 = false,
28:            	.sw1Changed = 0,
29:            	.sw2Changed = 0,
30:            	.sw3Changed = 0,
31:            	.sw4Changed = 0,
32:            };
33:            
34:            extern const struct CR_DATA *cr_text;
35:            extern const struct RS_DATA *rs_text;
36:            const char build_date[] = __DATE__, build_time[] = __TIME__;
37:            
38:            static bool APP_Initialize(void)
39:            {
40:            	TMR1_StartTimer();
6B02  ECEB     CALL 0x6BD6, 0
6B04  F035     NOP
41:            	TMR0_StartTimer();
6B06  ECED     CALL 0x6BDA, 0
6B08  F035     NOP
42:            
43:            	SLED = 1; // init completed
6B0A  8089     BSF LATA, 0, ACCESS
44:            	return true;
6B0C  0E01     MOVLW 0x1
6B0E  0012     RETURN 0
45:            }
46:            
47:            // dump serial buffer and clean possible lockup flags
48:            
49:            void clear_MC_port(void)
50:            {
51:            	while (EUSART1_is_rx_ready()) { //While buffer contains old data
66C6  D00D     BRA 0x66E2
52:            		EUSART1_Read(); //Keep reading until empty
66C8  ECD0     CALL 0x65A0, 0
66CA  F032     NOP
53:            		if (!EUSART1_is_rx_ready()) {
66CC  ECE9     CALL 0x6BD2, 0
66CE  F035     NOP
66D0  0900     IORLW 0x0
66D2  A4D8     BTFSS STATUS, 2, ACCESS
66D4  D006     BRA 0x66E2
54:            			WaitMs(1);
66D6  0E00     MOVLW 0x0
66D8  6E1B     MOVWF c, ACCESS
66DA  0E01     MOVLW 0x1
66DC  6E1A     MOVWF s, ACCESS
66DE  EC27     CALL 0x6A4E, 0
66E0  F035     NOP
55:            		}
66E2  ECE9     CALL 0x6BD2, 0
66E4  F035     NOP
66E6  0900     IORLW 0x0
66E8  A4D8     BTFSS STATUS, 2, ACCESS
66EA  D7EE     BRA 0x66C8
56:            	}
57:            	//Clear any UART error bits
58:            	if (1 == RCSTA1bits.OERR) {
66EC  A2AB     BTFSS RCSTA1, 1, ACCESS
66EE  0012     RETURN 0
59:            		// EUSART1 error - restart
60:            		RCSTA1bits.CREN = 0;
66F0  98AB     BCF RCSTA1, 4, ACCESS
61:            		RCSTA1bits.CREN = 1;
66F2  88AB     BSF RCSTA1, 4, ACCESS
66F4  0012     RETURN 0
62:            	}
63:            }
64:            
65:            //Primary application state machine
66:            
67:            void APP_Tasks(void)
68:            {
69:            	static char mc_response[MC_RX_PKT_SZ + 2];
70:            	int16_t offset;
71:            	uint8_t c_down;
72:            	static char *m_start;
73:            
74:            	if (TimerDone(TMR_LEDS)) {
13DC  0E01     MOVLW 0x1
13DE  ECC3     CALL 0x6986, 0
13E0  F034     NOP
13E2  0900     IORLW 0x0
13E4  B4D8     BTFSC STATUS, 2, ACCESS
13E6  EF06     GOTO 0x260C
13E8  F013     NOP
75:            		SLED ^= 1;
13EA  7089     BTG LATA, 0, ACCESS
76:            		StartTimer(TMR_LEDS, LED_BLINK_MS);
13EC  0E03     MOVLW 0x3
13EE  6E16     MOVWF Message, ACCESS
13F0  0E84     MOVLW 0x84
13F2  6E15     MOVWF dividend, ACCESS
13F4  0E01     MOVLW 0x1
13F6  EC1B     CALL 0x6836, 0
13F8  F034     NOP
77:            	}
78:            
79:            	switch (appData.state) {
13FA  EF06     GOTO 0x260C
13FC  F013     NOP
80:            		//Initial state
81:            	case APP_INITIALIZE:
82:            		if (APP_Initialize()) {
13FE  EC81     CALL 0x6B02, 0
1400  F035     NOP
1402  0900     IORLW 0x0
1404  B4D8     BTFSC STATUS, 2, ACCESS
1406  D02A     BRA 0x145C
83:            			appData.state = APP_CONNECT;
1408  0E02     MOVLW 0x2
140A  0101     MOVLB 0x1
140C  6F95     MOVWF 0x95, BANKED
84:            			display_ea_init(700);
140E  0E02     MOVLW 0x2
1410  0100     MOVLB 0x0
1412  6FBD     MOVWF 0xBD, BANKED
1414  0EBC     MOVLW 0xBC
1416  6FBC     MOVWF ret, BANKED
1418  EC7C     CALL 0x68F8, 0
141A  F034     NOP
85:            			BUZZER_OFF;
141C  ECE5     CALL 0x6BCA, 0
141E  F035     NOP
86:            			display_ea_ff(1);
1420  0E00     MOVLW 0x0
1422  0100     MOVLB 0x0
1424  6FBD     MOVWF 0xBD, BANKED
1426  0E01     MOVLW 0x1
1428  6FBC     MOVWF ret, BANKED
142A  EC8E     CALL 0x691C, 0
142C  F034     NOP
87:            			display_ea_cursor_off(1);
142E  0E00     MOVLW 0x0
1430  0100     MOVLB 0x0
1432  6FBD     MOVWF 0xBD, BANKED
1434  0E01     MOVLW 0x1
1436  6FBC     MOVWF ret, BANKED
1438  ECA0     CALL 0x6940, 0
143A  F034     NOP
88:            			display_ea_version(1000);
143C  0E03     MOVLW 0x3
143E  0100     MOVLB 0x0
1440  6FBD     MOVWF 0xBD, BANKED
1442  0EE8     MOVLW 0xE8
1444  6FBC     MOVWF ret, BANKED
1446  EC6A     CALL 0x68D4, 0
1448  F034     NOP
89:            			StartTimer(TMR_DIS, DIS_REFRESH_MS);
144A  0E00     MOVLW 0x0
144C  6E16     MOVWF Message, ACCESS
144E  0E46     MOVLW 0x46
1450  6E15     MOVWF dividend, ACCESS
1452  0E03     MOVLW 0x3
1454  EC1B     CALL 0x6836, 0
1456  F034     NOP
90:            		} else {
1458  EF23     GOTO 0x2646
145A  F013     NOP
91:            			appData.state = APP_INITIALIZATION_ERROR;
145C  0E01     MOVLW 0x1
145E  0101     MOVLB 0x1
1460  6F95     MOVWF 0x95, BANKED
92:            		}
93:            		break;
1462  EF23     GOTO 0x2646
1464  F013     NOP
94:            		//Initialization failed
95:            	case APP_INITIALIZATION_ERROR:
96:            		appData.error_code = ERROR_INITIALIZATION;
1466  0EFE     MOVLW 0xFE
1468  0101     MOVLB 0x1
146A  6FD8     MOVWF 0xD8, BANKED
97:            		BUZZER_ON;
146C  ECE7     CALL 0x6BCE, 0
146E  F035     NOP
98:            		break;
1470  EF23     GOTO 0x2646
1472  F013     NOP
99:            	case APP_CONNECT:
100:           		appData.state = APP_COMMUNICATE;
1474  0E03     MOVLW 0x3
1476  0101     MOVLB 0x1
1478  6F95     MOVWF 0x95, BANKED
101:           		if (MC_ReceivePacket(appData.receive_packet)) { // received data from controller
147A  0E97     MOVLW 0x97
147C  6E16     MOVWF Message, ACCESS
147E  0E01     MOVLW 0x1
1480  6E17     MOVWF _r, ACCESS
1482  EC58     CALL 0x54B0, 0
1484  F02A     NOP
1486  0900     IORLW 0x0
1488  B4D8     BTFSC STATUS, 2, ACCESS
148A  EF23     GOTO 0x2646
148C  F013     NOP
102:           			clear_MC_port();
148E  EC63     CALL 0x66C6, 0
1490  F033     NOP
103:           			BUZZER_ON;
1492  ECE7     CALL 0x6BCE, 0
1494  F035     NOP
104:           			appData.got_packet = false;
1496  0E00     MOVLW 0x0
1498  0101     MOVLB 0x1
149A  6FD7     MOVWF 0xD7, BANKED
105:           			if (strstr(appData.receive_packet, cr_text->r1)) { // power restart
149C  0E97     MOVLW 0x97
149E  6E22     MOVWF s, ACCESS
14A0  0E01     MOVLW 0x1
14A2  6E23     MOVWF sep, ACCESS
14A4  0E0A     MOVLW 0xA
14A6  0100     MOVLB 0x0
14A8  25D1     ADDWF cr_text, W, BANKED
14AA  6FC6     MOVWF 0xC6, BANKED
14AC  0E00     MOVLW 0x0
14AE  21D2     ADDWFC 0xD2, W, BANKED
14B0  6FC7     MOVWF 0xC7, BANKED
14B2  C0C6     MOVFF 0xC6, TBLPTR
14B4  FFF6     NOP
14B6  C0C7     MOVFF 0xC7, TBLPTRH
14B8  FFF7     NOP
14BA  0009     TBLRD*+
14BC  CFF5     MOVFF TABLAT, n
14BE  F024     NOP
14C0  000A     TBLRD*-
14C2  CFF5     MOVFF TABLAT, quotient
14C4  F025     NOP
14C6  ECE4     CALL 0x5BC8, 0
14C8  F02D     NOP
14CA  5022     MOVF s, W, ACCESS
14CC  1023     IORWF sep, W, ACCESS
14CE  B4D8     BTFSC STATUS, 2, ACCESS
14D0  D005     BRA 0x14DC
106:           				appData.mc = MC_BOOT;
14D2  0E02     MOVLW 0x2
14D4  0101     MOVLB 0x1
14D6  6F96     MOVWF 0x96, BANKED
107:           				appData.got_packet = true;
14D8  0E01     MOVLW 0x1
14DA  6FD7     MOVWF 0xD7, BANKED
108:           			}
109:           			if (strstr(appData.receive_packet, cr_text->r2)) { // hardware version
14DC  0E97     MOVLW 0x97
14DE  6E22     MOVWF s, ACCESS
14E0  0E01     MOVLW 0x1
14E2  6E23     MOVWF sep, ACCESS
14E4  0E0E     MOVLW 0xE
14E6  0100     MOVLB 0x0
14E8  25D1     ADDWF cr_text, W, BANKED
14EA  6FC6     MOVWF 0xC6, BANKED
14EC  0E00     MOVLW 0x0
14EE  21D2     ADDWFC 0xD2, W, BANKED
14F0  6FC7     MOVWF 0xC7, BANKED
14F2  C0C6     MOVFF 0xC6, TBLPTR
14F4  FFF6     NOP
14F6  C0C7     MOVFF 0xC7, TBLPTRH
14F8  FFF7     NOP
14FA  0009     TBLRD*+
14FC  CFF5     MOVFF TABLAT, n
14FE  F024     NOP
1500  000A     TBLRD*-
1502  CFF5     MOVFF TABLAT, quotient
1504  F025     NOP
1506  ECE4     CALL 0x5BC8, 0
1508  F02D     NOP
150A  5022     MOVF s, W, ACCESS
150C  1023     IORWF sep, W, ACCESS
150E  B4D8     BTFSC STATUS, 2, ACCESS
1510  D00B     BRA 0x1528
110:           				if (appData.mc == MC_BOOT) {
1512  0E02     MOVLW 0x2
1514  0101     MOVLB 0x1
1516  1996     XORWF 0x96, W, BANKED
1518  A4D8     BTFSS STATUS, 2, ACCESS
151A  D002     BRA 0x1520
111:           					appData.mc = MC_DRIVE;
151C  0E03     MOVLW 0x3
151E  D001     BRA 0x1522
112:           				} else {
113:           					appData.mc = MC_INITIALIZE;
1520  0E00     MOVLW 0x0
1522  6F96     MOVWF 0x96, BANKED
114:           				}
115:           				appData.got_packet = true;
1524  0E01     MOVLW 0x1
1526  6FD7     MOVWF 0xD7, BANKED
116:           			}
117:           			if (strstr(appData.receive_packet, cr_text->r3)) { // motor poles
1528  0E97     MOVLW 0x97
152A  6E22     MOVWF s, ACCESS
152C  0E01     MOVLW 0x1
152E  6E23     MOVWF sep, ACCESS
1530  0E12     MOVLW 0x12
1532  0100     MOVLB 0x0
1534  25D1     ADDWF cr_text, W, BANKED
1536  6FC6     MOVWF 0xC6, BANKED
1538  0E00     MOVLW 0x0
153A  21D2     ADDWFC 0xD2, W, BANKED
153C  6FC7     MOVWF 0xC7, BANKED
153E  C0C6     MOVFF 0xC6, TBLPTR
1540  FFF6     NOP
1542  C0C7     MOVFF 0xC7, TBLPTRH
1544  FFF7     NOP
1546  0009     TBLRD*+
1548  CFF5     MOVFF TABLAT, n
154A  F024     NOP
154C  000A     TBLRD*-
154E  CFF5     MOVFF TABLAT, quotient
1550  F025     NOP
1552  ECE4     CALL 0x5BC8, 0
1554  F02D     NOP
1556  5022     MOVF s, W, ACCESS
1558  1023     IORWF sep, W, ACCESS
155A  B4D8     BTFSC STATUS, 2, ACCESS
155C  EF23     GOTO 0x2646
155E  F013     NOP
118:           				if (appData.mc == MC_DRIVE) {
1560  0E03     MOVLW 0x3
1562  0101     MOVLB 0x1
1564  1996     XORWF 0x96, W, BANKED
1566  A4D8     BTFSS STATUS, 2, ACCESS
1568  D002     BRA 0x156E
119:           					appData.mc = MC_SETUP;
156A  0E05     MOVLW 0x5
156C  D001     BRA 0x1570
120:           				} else {
121:           					appData.mc = MC_INITIALIZE;
156E  0E00     MOVLW 0x0
1570  6F96     MOVWF 0x96, BANKED
122:           				}
123:           				appData.got_packet = true;
1572  0E01     MOVLW 0x1
1574  6FD7     MOVWF 0xD7, BANKED
124:           			}
125:           		}
126:           		break;
1576  EF23     GOTO 0x2646
1578  F013     NOP
127:           	case APP_COMMUNICATE:
128:           		appData.state = APP_CONNECT;
157A  0E02     MOVLW 0x2
157C  0101     MOVLB 0x1
157E  6F95     MOVWF 0x95, BANKED
129:           		if (TimerDone(TMR_DIS)) {
1580  0E03     MOVLW 0x3
1582  ECC3     CALL 0x6986, 0
1584  F034     NOP
1586  0900     IORLW 0x0
1588  B4D8     BTFSC STATUS, 2, ACCESS
158A  EF23     GOTO 0x2646
158C  F013     NOP
130:           			IO_RA2_Toggle();
158E  A489     BTFSS LATA, 2, ACCESS
1590  D002     BRA 0x1596
1592  0E01     MOVLW 0x1
1594  D001     BRA 0x1598
1596  0E00     MOVLW 0x0
1598  0AFF     XORLW 0xFF
159A  0100     MOVLB 0x0
159C  6FC6     MOVWF 0xC6, BANKED
159E  47C6     RLNCF 0xC6, F, BANKED
15A0  47C6     RLNCF 0xC6, F, BANKED
15A2  5089     MOVF LATA, W, ACCESS
15A4  19C6     XORWF 0xC6, W, BANKED
15A6  0BFB     ANDLW 0xFB
15A8  19C6     XORWF 0xC6, W, BANKED
15AA  6E89     MOVWF LATA, ACCESS
131:           			if (appData.got_packet) {
15AC  0101     MOVLB 0x1
15AE  51D7     MOVF 0xD7, W, BANKED
15B0  B4D8     BTFSC STATUS, 2, ACCESS
15B2  EF53     GOTO 0x24A6
15B4  F012     NOP
132:           				sprintf(mc_response, cr_text->line1, cr_text->blank);
15B6  0E28     MOVLW 0x28
15B8  0100     MOVLB 0x0
15BA  6FB4     MOVWF s, BANKED
15BC  0E01     MOVLW 0x1
15BE  6FB5     MOVWF 0xB5, BANKED
15C0  0E3E     MOVLW 0x3E
15C2  25D1     ADDWF cr_text, W, BANKED
15C4  6FC6     MOVWF 0xC6, BANKED
15C6  0E00     MOVLW 0x0
15C8  21D2     ADDWFC 0xD2, W, BANKED
15CA  6FC7     MOVWF 0xC7, BANKED
15CC  C0C6     MOVFF 0xC6, TBLPTR
15CE  FFF6     NOP
15D0  C0C7     MOVFF 0xC7, TBLPTRH
15D2  FFF7     NOP
15D4  0009     TBLRD*+
15D6  CFF5     MOVFF TABLAT, fmt
15D8  F0B6     NOP
15DA  000A     TBLRD*-
15DC  CFF5     MOVFF TABLAT, 0xB7
15DE  F0B7     NOP
15E0  0E06     MOVLW 0x6
15E2  25D1     ADDWF cr_text, W, BANKED
15E4  6FC8     MOVWF 0xC8, BANKED
15E6  0E00     MOVLW 0x0
15E8  21D2     ADDWFC 0xD2, W, BANKED
15EA  6FC9     MOVWF 0xC9, BANKED
15EC  C0C8     MOVFF 0xC8, TBLPTR
15EE  FFF6     NOP
15F0  C0C9     MOVFF 0xC9, TBLPTRH
15F2  FFF7     NOP
15F4  0009     TBLRD*+
15F6  CFF5     MOVFF TABLAT, ret
15F8  F0B8     NOP
15FA  000A     TBLRD*-
15FC  CFF5     MOVFF TABLAT, 0xB9
15FE  F0B9     NOP
1600  EC27     CALL 0x5E4E, 0
1602  F02F     NOP
133:           				display_ea_line(mc_response);
1604  0E28     MOVLW 0x28
1606  0100     MOVLB 0x0
1608  6FBC     MOVWF ret, BANKED
160A  0E01     MOVLW 0x1
160C  6FBD     MOVWF 0xBD, BANKED
160E  EC5D     CALL 0x6ABA, 0
1610  F035     NOP
134:           				sprintf(mc_response, cr_text->line1, appData.receive_packet);
1612  0E28     MOVLW 0x28
1614  0100     MOVLB 0x0
1616  6FB4     MOVWF s, BANKED
1618  0E01     MOVLW 0x1
161A  6FB5     MOVWF 0xB5, BANKED
161C  0E3E     MOVLW 0x3E
161E  25D1     ADDWF cr_text, W, BANKED
1620  6FC6     MOVWF 0xC6, BANKED
1622  0E00     MOVLW 0x0
1624  21D2     ADDWFC 0xD2, W, BANKED
1626  6FC7     MOVWF 0xC7, BANKED
1628  C0C6     MOVFF 0xC6, TBLPTR
162A  FFF6     NOP
162C  C0C7     MOVFF 0xC7, TBLPTRH
162E  FFF7     NOP
1630  0009     TBLRD*+
1632  CFF5     MOVFF TABLAT, fmt
1634  F0B6     NOP
1636  000A     TBLRD*-
1638  CFF5     MOVFF TABLAT, 0xB7
163A  F0B7     NOP
163C  0E97     MOVLW 0x97
163E  6FB8     MOVWF ret, BANKED
1640  0E01     MOVLW 0x1
1642  6FB9     MOVWF 0xB9, BANKED
1644  EC27     CALL 0x5E4E, 0
1646  F02F     NOP
135:           				display_ea_line(mc_response);
1648  0E28     MOVLW 0x28
164A  0100     MOVLB 0x0
164C  6FBC     MOVWF ret, BANKED
164E  0E01     MOVLW 0x1
1650  6FBD     MOVWF 0xBD, BANKED
1652  EC5D     CALL 0x6ABA, 0
1654  F035     NOP
136:           				switch (appData.mc) {
1656  EF32     GOTO 0x2464
1658  F012     NOP
137:           					//Initial state
138:           				case MC_INITIALIZE:
139:           					sprintf(mc_response, cr_text->line2, cr_text->error);
165A  0E28     MOVLW 0x28
165C  0100     MOVLB 0x0
165E  6FB4     MOVWF s, BANKED
1660  0E01     MOVLW 0x1
1662  6FB5     MOVWF 0xB5, BANKED
1664  0E40     MOVLW 0x40
1666  25D1     ADDWF cr_text, W, BANKED
1668  6FC6     MOVWF 0xC6, BANKED
166A  0E00     MOVLW 0x0
166C  21D2     ADDWFC 0xD2, W, BANKED
166E  6FC7     MOVWF 0xC7, BANKED
1670  C0C6     MOVFF 0xC6, TBLPTR
1672  FFF6     NOP
1674  C0C7     MOVFF 0xC7, TBLPTRH
1676  FFF7     NOP
1678  0009     TBLRD*+
167A  CFF5     MOVFF TABLAT, fmt
167C  F0B6     NOP
167E  000A     TBLRD*-
1680  CFF5     MOVFF TABLAT, 0xB7
1682  F0B7     NOP
1684  0E3A     MOVLW 0x3A
1686  25D1     ADDWF cr_text, W, BANKED
1688  6FC8     MOVWF 0xC8, BANKED
168A  0E00     MOVLW 0x0
168C  21D2     ADDWFC 0xD2, W, BANKED
168E  6FC9     MOVWF 0xC9, BANKED
1690  C0C8     MOVFF 0xC8, TBLPTR
1692  FFF6     NOP
1694  C0C9     MOVFF 0xC9, TBLPTRH
1696  FFF7     NOP
1698  0009     TBLRD*+
169A  CFF5     MOVFF TABLAT, ret
169C  F0B8     NOP
169E  000A     TBLRD*-
16A0  CFF5     MOVFF TABLAT, 0xB9
16A2  F0B9     NOP
16A4  EC27     CALL 0x5E4E, 0
16A6  F02F     NOP
140:           					display_ea_line(mc_response);
16A8  0E28     MOVLW 0x28
16AA  0100     MOVLB 0x0
16AC  6FBC     MOVWF ret, BANKED
16AE  0E01     MOVLW 0x1
16B0  6FBD     MOVWF 0xBD, BANKED
16B2  EC5D     CALL 0x6ABA, 0
16B4  F035     NOP
141:           					break;
16B6  EF4F     GOTO 0x249E
16B8  F012     NOP
142:           				case MC_BOOT:
143:           					clear_MC_port();
16BA  EC63     CALL 0x66C6, 0
16BC  F033     NOP
144:           					MC_SendCommand(cr_text->c2, false);
16BE  0E0C     MOVLW 0xC
16C0  0100     MOVLB 0x0
16C2  25D1     ADDWF cr_text, W, BANKED
16C4  6FC6     MOVWF 0xC6, BANKED
16C6  0E00     MOVLW 0x0
16C8  21D2     ADDWFC 0xD2, W, BANKED
16CA  6FC7     MOVWF 0xC7, BANKED
16CC  C0C6     MOVFF 0xC6, TBLPTR
16CE  FFF6     NOP
16D0  C0C7     MOVFF 0xC7, TBLPTRH
16D2  FFF7     NOP
16D4  0009     TBLRD*+
16D6  CFF5     MOVFF TABLAT, c
16D8  F01C     NOP
16DA  000A     TBLRD*-
16DC  CFF5     MOVFF TABLAT, divisor
16DE  F01D     NOP
16E0  0E00     MOVLW 0x0
16E2  6E1E     MOVWF l, ACCESS
16E4  ECBB     CALL 0x5D76, 0
16E6  F02E     NOP
145:           					break;
16E8  EF4F     GOTO 0x249E
16EA  F012     NOP
146:           				case MC_DRIVE:
147:           					clear_MC_port();
16EC  EC63     CALL 0x66C6, 0
16EE  F033     NOP
148:           					MC_SendCommand(cr_text->c3, false);
16F0  0E10     MOVLW 0x10
16F2  0100     MOVLB 0x0
16F4  25D1     ADDWF cr_text, W, BANKED
16F6  6FC6     MOVWF 0xC6, BANKED
16F8  0E00     MOVLW 0x0
16FA  21D2     ADDWFC 0xD2, W, BANKED
16FC  6FC7     MOVWF 0xC7, BANKED
16FE  C0C6     MOVFF 0xC6, TBLPTR
1700  FFF6     NOP
1702  C0C7     MOVFF 0xC7, TBLPTRH
1704  FFF7     NOP
1706  0009     TBLRD*+
1708  CFF5     MOVFF TABLAT, c
170A  F01C     NOP
170C  000A     TBLRD*-
170E  CFF5     MOVFF TABLAT, divisor
1710  F01D     NOP
1712  0E00     MOVLW 0x0
1714  6E1E     MOVWF l, ACCESS
1716  ECBB     CALL 0x5D76, 0
1718  F02E     NOP
149:           					break;
171A  EF4F     GOTO 0x249E
171C  F012     NOP
150:           				case MC_SETUP:
151:           					BUZZER_OFF;
171E  ECE5     CALL 0x6BCA, 0
1720  F035     NOP
152:           					sprintf(mc_response, cr_text->line2, cr_text->s2);
1722  0E28     MOVLW 0x28
1724  0100     MOVLB 0x0
1726  6FB4     MOVWF s, BANKED
1728  0E01     MOVLW 0x1
172A  6FB5     MOVWF 0xB5, BANKED
172C  0E40     MOVLW 0x40
172E  25D1     ADDWF cr_text, W, BANKED
1730  6FC6     MOVWF 0xC6, BANKED
1732  0E00     MOVLW 0x0
1734  21D2     ADDWFC 0xD2, W, BANKED
1736  6FC7     MOVWF 0xC7, BANKED
1738  C0C6     MOVFF 0xC6, TBLPTR
173A  FFF6     NOP
173C  C0C7     MOVFF 0xC7, TBLPTRH
173E  FFF7     NOP
1740  0009     TBLRD*+
1742  CFF5     MOVFF TABLAT, fmt
1744  F0B6     NOP
1746  000A     TBLRD*-
1748  CFF5     MOVFF TABLAT, 0xB7
174A  F0B7     NOP
174C  0E16     MOVLW 0x16
174E  25D1     ADDWF cr_text, W, BANKED
1750  6FC8     MOVWF 0xC8, BANKED
1752  0E00     MOVLW 0x0
1754  21D2     ADDWFC 0xD2, W, BANKED
1756  6FC9     MOVWF 0xC9, BANKED
1758  C0C8     MOVFF 0xC8, TBLPTR
175A  FFF6     NOP
175C  C0C9     MOVFF 0xC9, TBLPTRH
175E  FFF7     NOP
1760  0009     TBLRD*+
1762  CFF5     MOVFF TABLAT, ret
1764  F0B8     NOP
1766  000A     TBLRD*-
1768  CFF5     MOVFF TABLAT, 0xB9
176A  F0B9     NOP
176C  EC27     CALL 0x5E4E, 0
176E  F02F     NOP
153:           					display_ea_line(mc_response);
1770  0E28     MOVLW 0x28
1772  0100     MOVLB 0x0
1774  6FBC     MOVWF ret, BANKED
1776  0E01     MOVLW 0x1
1778  6FBD     MOVWF 0xBD, BANKED
177A  EC5D     CALL 0x6ABA, 0
177C  F035     NOP
154:           					sprintf(mc_response, cr_text->line3, cr_text->w2);
177E  0E28     MOVLW 0x28
1780  0100     MOVLB 0x0
1782  6FB4     MOVWF s, BANKED
1784  0E01     MOVLW 0x1
1786  6FB5     MOVWF 0xB5, BANKED
1788  0E42     MOVLW 0x42
178A  25D1     ADDWF cr_text, W, BANKED
178C  6FC6     MOVWF 0xC6, BANKED
178E  0E00     MOVLW 0x0
1790  21D2     ADDWFC 0xD2, W, BANKED
1792  6FC7     MOVWF 0xC7, BANKED
1794  C0C6     MOVFF 0xC6, TBLPTR
1796  FFF6     NOP
1798  C0C7     MOVFF 0xC7, TBLPTRH
179A  FFF7     NOP
179C  0009     TBLRD*+
179E  CFF5     MOVFF TABLAT, fmt
17A0  F0B6     NOP
17A2  000A     TBLRD*-
17A4  CFF5     MOVFF TABLAT, 0xB7
17A6  F0B7     NOP
17A8  0E1C     MOVLW 0x1C
17AA  25D1     ADDWF cr_text, W, BANKED
17AC  6FC8     MOVWF 0xC8, BANKED
17AE  0E00     MOVLW 0x0
17B0  21D2     ADDWFC 0xD2, W, BANKED
17B2  6FC9     MOVWF 0xC9, BANKED
17B4  C0C8     MOVFF 0xC8, TBLPTR
17B6  FFF6     NOP
17B8  C0C9     MOVFF 0xC9, TBLPTRH
17BA  FFF7     NOP
17BC  0009     TBLRD*+
17BE  CFF5     MOVFF TABLAT, ret
17C0  F0B8     NOP
17C2  000A     TBLRD*-
17C4  CFF5     MOVFF TABLAT, 0xB9
17C6  F0B9     NOP
17C8  EC27     CALL 0x5E4E, 0
17CA  F02F     NOP
155:           					display_ea_line(mc_response);
17CC  0E28     MOVLW 0x28
17CE  0100     MOVLB 0x0
17D0  6FBC     MOVWF ret, BANKED
17D2  0E01     MOVLW 0x1
17D4  6FBD     MOVWF 0xBD, BANKED
17D6  EC5D     CALL 0x6ABA, 0
17D8  F035     NOP
156:           					while (!appData.sw1) {
17DA  D02E     BRA 0x1838
157:           						sprintf(mc_response, cr_text->line4, cr_text->buttonp);
17DC  0E28     MOVLW 0x28
17DE  0100     MOVLB 0x0
17E0  6FB4     MOVWF s, BANKED
17E2  0E01     MOVLW 0x1
17E4  6FB5     MOVWF 0xB5, BANKED
17E6  0E44     MOVLW 0x44
17E8  25D1     ADDWF cr_text, W, BANKED
17EA  6FC6     MOVWF 0xC6, BANKED
17EC  0E00     MOVLW 0x0
17EE  21D2     ADDWFC 0xD2, W, BANKED
17F0  6FC7     MOVWF 0xC7, BANKED
17F2  C0C6     MOVFF 0xC6, TBLPTR
17F4  FFF6     NOP
17F6  C0C7     MOVFF 0xC7, TBLPTRH
17F8  FFF7     NOP
17FA  0009     TBLRD*+
17FC  CFF5     MOVFF TABLAT, fmt
17FE  F0B6     NOP
1800  000A     TBLRD*-
1802  CFF5     MOVFF TABLAT, 0xB7
1804  F0B7     NOP
1806  0E04     MOVLW 0x4
1808  25D1     ADDWF cr_text, W, BANKED
180A  6FC8     MOVWF 0xC8, BANKED
180C  0E00     MOVLW 0x0
180E  21D2     ADDWFC 0xD2, W, BANKED
1810  6FC9     MOVWF 0xC9, BANKED
1812  C0C8     MOVFF 0xC8, TBLPTR
1814  FFF6     NOP
1816  C0C9     MOVFF 0xC9, TBLPTRH
1818  FFF7     NOP
181A  0009     TBLRD*+
181C  CFF5     MOVFF TABLAT, ret
181E  F0B8     NOP
1820  000A     TBLRD*-
1822  CFF5     MOVFF TABLAT, 0xB9
1824  F0B9     NOP
1826  EC27     CALL 0x5E4E, 0
1828  F02F     NOP
158:           						display_ea_line(mc_response);
182A  0E28     MOVLW 0x28
182C  0100     MOVLB 0x0
182E  6FBC     MOVWF ret, BANKED
1830  0E01     MOVLW 0x1
1832  6FBD     MOVWF 0xBD, BANKED
1834  EC5D     CALL 0x6ABA, 0
1836  F035     NOP
159:           					}
1838  0101     MOVLB 0x1
183A  51D9     MOVF 0xD9, W, BANKED
183C  B4D8     BTFSC STATUS, 2, ACCESS
183E  D7CE     BRA 0x17DC
160:           					sprintf(mc_response, cr_text->line1, cr_text->blank);
1840  0E28     MOVLW 0x28
1842  0100     MOVLB 0x0
1844  6FB4     MOVWF s, BANKED
1846  0E01     MOVLW 0x1
1848  6FB5     MOVWF 0xB5, BANKED
184A  0E3E     MOVLW 0x3E
184C  25D1     ADDWF cr_text, W, BANKED
184E  6FC6     MOVWF 0xC6, BANKED
1850  0E00     MOVLW 0x0
1852  21D2     ADDWFC 0xD2, W, BANKED
1854  6FC7     MOVWF 0xC7, BANKED
1856  C0C6     MOVFF 0xC6, TBLPTR
1858  FFF6     NOP
185A  C0C7     MOVFF 0xC7, TBLPTRH
185C  FFF7     NOP
185E  0009     TBLRD*+
1860  CFF5     MOVFF TABLAT, fmt
1862  F0B6     NOP
1864  000A     TBLRD*-
1866  CFF5     MOVFF TABLAT, 0xB7
1868  F0B7     NOP
186A  0E06     MOVLW 0x6
186C  25D1     ADDWF cr_text, W, BANKED
186E  6FC8     MOVWF 0xC8, BANKED
1870  0E00     MOVLW 0x0
1872  21D2     ADDWFC 0xD2, W, BANKED
1874  6FC9     MOVWF 0xC9, BANKED
1876  C0C8     MOVFF 0xC8, TBLPTR
1878  FFF6     NOP
187A  C0C9     MOVFF 0xC9, TBLPTRH
187C  FFF7     NOP
187E  0009     TBLRD*+
1880  CFF5     MOVFF TABLAT, ret
1882  F0B8     NOP
1884  000A     TBLRD*-
1886  CFF5     MOVFF TABLAT, 0xB9
1888  F0B9     NOP
188A  EC27     CALL 0x5E4E, 0
188C  F02F     NOP
161:           					display_ea_line(mc_response);
188E  0E28     MOVLW 0x28
1890  0100     MOVLB 0x0
1892  6FBC     MOVWF ret, BANKED
1894  0E01     MOVLW 0x1
1896  6FBD     MOVWF 0xBD, BANKED
1898  EC5D     CALL 0x6ABA, 0
189A  F035     NOP
162:           
163:           					BUZZER_ON;
189C  ECE7     CALL 0x6BCE, 0
189E  F035     NOP
164:           					appData.sw1 = false;
18A0  0E00     MOVLW 0x0
18A2  0101     MOVLB 0x1
18A4  6FD9     MOVWF 0xD9, BANKED
165:           					WaitMs(100);
18A6  0E00     MOVLW 0x0
18A8  6E1B     MOVWF c, ACCESS
18AA  0E64     MOVLW 0x64
18AC  6E1A     MOVWF s, ACCESS
18AE  EC27     CALL 0x6A4E, 0
18B0  F035     NOP
166:           					BUZZER_OFF;
18B2  ECE5     CALL 0x6BCA, 0
18B4  F035     NOP
167:           
168:           					clear_MC_port();
18B6  EC63     CALL 0x66C6, 0
18B8  F033     NOP
169:           					MC_SendCommand(cr_text->dis, true);
18BA  0E24     MOVLW 0x24
18BC  0100     MOVLB 0x0
18BE  25D1     ADDWF cr_text, W, BANKED
18C0  6FC6     MOVWF 0xC6, BANKED
18C2  0E00     MOVLW 0x0
18C4  21D2     ADDWFC 0xD2, W, BANKED
18C6  6FC7     MOVWF 0xC7, BANKED
18C8  C0C6     MOVFF 0xC6, TBLPTR
18CA  FFF6     NOP
18CC  C0C7     MOVFF 0xC7, TBLPTRH
18CE  FFF7     NOP
18D0  0009     TBLRD*+
18D2  CFF5     MOVFF TABLAT, c
18D4  F01C     NOP
18D6  000A     TBLRD*-
18D8  CFF5     MOVFF TABLAT, divisor
18DA  F01D     NOP
18DC  0E01     MOVLW 0x1
18DE  6E1E     MOVWF l, ACCESS
18E0  ECBB     CALL 0x5D76, 0
18E2  F02E     NOP
170:           					MC_SendCommand(cr_text->msg2, true);
18E4  0E26     MOVLW 0x26
18E6  0100     MOVLB 0x0
18E8  25D1     ADDWF cr_text, W, BANKED
18EA  6FC6     MOVWF 0xC6, BANKED
18EC  0E00     MOVLW 0x0
18EE  21D2     ADDWFC 0xD2, W, BANKED
18F0  6FC7     MOVWF 0xC7, BANKED
18F2  C0C6     MOVFF 0xC6, TBLPTR
18F4  FFF6     NOP
18F6  C0C7     MOVFF 0xC7, TBLPTRH
18F8  FFF7     NOP
18FA  0009     TBLRD*+
18FC  CFF5     MOVFF TABLAT, c
18FE  F01C     NOP
1900  000A     TBLRD*-
1902  CFF5     MOVFF TABLAT, divisor
1904  F01D     NOP
1906  0E01     MOVLW 0x1
1908  6E1E     MOVWF l, ACCESS
190A  ECBB     CALL 0x5D76, 0
190C  F02E     NOP
171:           					MC_SendCommand(cr_text->mpoles0, true);
190E  0E28     MOVLW 0x28
1910  0100     MOVLB 0x0
1912  25D1     ADDWF cr_text, W, BANKED
1914  6FC6     MOVWF 0xC6, BANKED
1916  0E00     MOVLW 0x0
1918  21D2     ADDWFC 0xD2, W, BANKED
191A  6FC7     MOVWF 0xC7, BANKED
191C  C0C6     MOVFF 0xC6, TBLPTR
191E  FFF6     NOP
1920  C0C7     MOVFF 0xC7, TBLPTRH
1922  FFF7     NOP
1924  0009     TBLRD*+
1926  CFF5     MOVFF TABLAT, c
1928  F01C     NOP
192A  000A     TBLRD*-
192C  CFF5     MOVFF TABLAT, divisor
192E  F01D     NOP
1930  0E01     MOVLW 0x1
1932  6E1E     MOVWF l, ACCESS
1934  ECBB     CALL 0x5D76, 0
1936  F02E     NOP
172:           					MC_SendCommand(cr_text->mphase90, true);
1938  0E2A     MOVLW 0x2A
193A  0100     MOVLB 0x0
193C  25D1     ADDWF cr_text, W, BANKED
193E  6FC6     MOVWF 0xC6, BANKED
1940  0E00     MOVLW 0x0
1942  21D2     ADDWFC 0xD2, W, BANKED
1944  6FC7     MOVWF 0xC7, BANKED
1946  C0C6     MOVFF 0xC6, TBLPTR
1948  FFF6     NOP
194A  C0C7     MOVFF 0xC7, TBLPTRH
194C  FFF7     NOP
194E  0009     TBLRD*+
1950  CFF5     MOVFF TABLAT, c
1952  F01C     NOP
1954  000A     TBLRD*-
1956  CFF5     MOVFF TABLAT, divisor
1958  F01D     NOP
195A  0E01     MOVLW 0x1
195C  6E1E     MOVWF l, ACCESS
195E  ECBB     CALL 0x5D76, 0
1960  F02E     NOP
173:           					MC_SendCommand(cr_text->opmode2, true);
1962  0E2C     MOVLW 0x2C
1964  0100     MOVLB 0x0
1966  25D1     ADDWF cr_text, W, BANKED
1968  6FC6     MOVWF 0xC6, BANKED
196A  0E00     MOVLW 0x0
196C  21D2     ADDWFC 0xD2, W, BANKED
196E  6FC7     MOVWF 0xC7, BANKED
1970  C0C6     MOVFF 0xC6, TBLPTR
1972  FFF6     NOP
1974  C0C7     MOVFF 0xC7, TBLPTRH
1976  FFF7     NOP
1978  0009     TBLRD*+
197A  CFF5     MOVFF TABLAT, c
197C  F01C     NOP
197E  000A     TBLRD*-
1980  CFF5     MOVFF TABLAT, divisor
1982  F01D     NOP
1984  0E01     MOVLW 0x1
1986  6E1E     MOVWF l, ACCESS
1988  ECBB     CALL 0x5D76, 0
198A  F02E     NOP
174:           
175:           					sprintf(mc_response, cr_text->line2, cr_text->s1);
198C  0E28     MOVLW 0x28
198E  0100     MOVLB 0x0
1990  6FB4     MOVWF s, BANKED
1992  0E01     MOVLW 0x1
1994  6FB5     MOVWF 0xB5, BANKED
1996  0E40     MOVLW 0x40
1998  25D1     ADDWF cr_text, W, BANKED
199A  6FC6     MOVWF 0xC6, BANKED
199C  0E00     MOVLW 0x0
199E  21D2     ADDWFC 0xD2, W, BANKED
19A0  6FC7     MOVWF 0xC7, BANKED
19A2  C0C6     MOVFF 0xC6, TBLPTR
19A4  FFF6     NOP
19A6  C0C7     MOVFF 0xC7, TBLPTRH
19A8  FFF7     NOP
19AA  0009     TBLRD*+
19AC  CFF5     MOVFF TABLAT, fmt
19AE  F0B6     NOP
19B0  000A     TBLRD*-
19B2  CFF5     MOVFF TABLAT, 0xB7
19B4  F0B7     NOP
19B6  0E14     MOVLW 0x14
19B8  25D1     ADDWF cr_text, W, BANKED
19BA  6FC8     MOVWF 0xC8, BANKED
19BC  0E00     MOVLW 0x0
19BE  21D2     ADDWFC 0xD2, W, BANKED
19C0  6FC9     MOVWF 0xC9, BANKED
19C2  C0C8     MOVFF 0xC8, TBLPTR
19C4  FFF6     NOP
19C6  C0C9     MOVFF 0xC9, TBLPTRH
19C8  FFF7     NOP
19CA  0009     TBLRD*+
19CC  CFF5     MOVFF TABLAT, ret
19CE  F0B8     NOP
19D0  000A     TBLRD*-
19D2  CFF5     MOVFF TABLAT, 0xB9
19D4  F0B9     NOP
19D6  EC27     CALL 0x5E4E, 0
19D8  F02F     NOP
176:           					display_ea_line(mc_response);
19DA  0E28     MOVLW 0x28
19DC  0100     MOVLB 0x0
19DE  6FBC     MOVWF ret, BANKED
19E0  0E01     MOVLW 0x1
19E2  6FBD     MOVWF 0xBD, BANKED
19E4  EC5D     CALL 0x6ABA, 0
19E6  F035     NOP
177:           					sprintf(mc_response, cr_text->line3, cr_text->w1);
19E8  0E28     MOVLW 0x28
19EA  0100     MOVLB 0x0
19EC  6FB4     MOVWF s, BANKED
19EE  0E01     MOVLW 0x1
19F0  6FB5     MOVWF 0xB5, BANKED
19F2  0E42     MOVLW 0x42
19F4  25D1     ADDWF cr_text, W, BANKED
19F6  6FC6     MOVWF 0xC6, BANKED
19F8  0E00     MOVLW 0x0
19FA  21D2     ADDWFC 0xD2, W, BANKED
19FC  6FC7     MOVWF 0xC7, BANKED
19FE  C0C6     MOVFF 0xC6, TBLPTR
1A00  FFF6     NOP
1A02  C0C7     MOVFF 0xC7, TBLPTRH
1A04  FFF7     NOP
1A06  0009     TBLRD*+
1A08  CFF5     MOVFF TABLAT, fmt
1A0A  F0B6     NOP
1A0C  000A     TBLRD*-
1A0E  CFF5     MOVFF TABLAT, 0xB7
1A10  F0B7     NOP
1A12  0E1A     MOVLW 0x1A
1A14  25D1     ADDWF cr_text, W, BANKED
1A16  6FC8     MOVWF 0xC8, BANKED
1A18  0E00     MOVLW 0x0
1A1A  21D2     ADDWFC 0xD2, W, BANKED
1A1C  6FC9     MOVWF 0xC9, BANKED
1A1E  C0C8     MOVFF 0xC8, TBLPTR
1A20  FFF6     NOP
1A22  C0C9     MOVFF 0xC9, TBLPTRH
1A24  FFF7     NOP
1A26  0009     TBLRD*+
1A28  CFF5     MOVFF TABLAT, ret
1A2A  F0B8     NOP
1A2C  000A     TBLRD*-
1A2E  CFF5     MOVFF TABLAT, 0xB9
1A30  F0B9     NOP
1A32  EC27     CALL 0x5E4E, 0
1A34  F02F     NOP
178:           					display_ea_line(mc_response);
1A36  0E28     MOVLW 0x28
1A38  0100     MOVLB 0x0
1A3A  6FBC     MOVWF ret, BANKED
1A3C  0E01     MOVLW 0x1
1A3E  6FBD     MOVWF 0xBD, BANKED
1A40  EC5D     CALL 0x6ABA, 0
1A42  F035     NOP
179:           					while (!appData.sw1) {
1A44  D02E     BRA 0x1AA2
180:           						sprintf(mc_response, cr_text->line4, cr_text->buttonp);
1A46  0E28     MOVLW 0x28
1A48  0100     MOVLB 0x0
1A4A  6FB4     MOVWF s, BANKED
1A4C  0E01     MOVLW 0x1
1A4E  6FB5     MOVWF 0xB5, BANKED
1A50  0E44     MOVLW 0x44
1A52  25D1     ADDWF cr_text, W, BANKED
1A54  6FC6     MOVWF 0xC6, BANKED
1A56  0E00     MOVLW 0x0
1A58  21D2     ADDWFC 0xD2, W, BANKED
1A5A  6FC7     MOVWF 0xC7, BANKED
1A5C  C0C6     MOVFF 0xC6, TBLPTR
1A5E  FFF6     NOP
1A60  C0C7     MOVFF 0xC7, TBLPTRH
1A62  FFF7     NOP
1A64  0009     TBLRD*+
1A66  CFF5     MOVFF TABLAT, fmt
1A68  F0B6     NOP
1A6A  000A     TBLRD*-
1A6C  CFF5     MOVFF TABLAT, 0xB7
1A6E  F0B7     NOP
1A70  0E04     MOVLW 0x4
1A72  25D1     ADDWF cr_text, W, BANKED
1A74  6FC8     MOVWF 0xC8, BANKED
1A76  0E00     MOVLW 0x0
1A78  21D2     ADDWFC 0xD2, W, BANKED
1A7A  6FC9     MOVWF 0xC9, BANKED
1A7C  C0C8     MOVFF 0xC8, TBLPTR
1A7E  FFF6     NOP
1A80  C0C9     MOVFF 0xC9, TBLPTRH
1A82  FFF7     NOP
1A84  0009     TBLRD*+
1A86  CFF5     MOVFF TABLAT, ret
1A88  F0B8     NOP
1A8A  000A     TBLRD*-
1A8C  CFF5     MOVFF TABLAT, 0xB9
1A8E  F0B9     NOP
1A90  EC27     CALL 0x5E4E, 0
1A92  F02F     NOP
181:           						display_ea_line(mc_response);
1A94  0E28     MOVLW 0x28
1A96  0100     MOVLB 0x0
1A98  6FBC     MOVWF ret, BANKED
1A9A  0E01     MOVLW 0x1
1A9C  6FBD     MOVWF 0xBD, BANKED
1A9E  EC5D     CALL 0x6ABA, 0
1AA0  F035     NOP
182:           					}
1AA2  0101     MOVLB 0x1
1AA4  51D9     MOVF 0xD9, W, BANKED
1AA6  B4D8     BTFSC STATUS, 2, ACCESS
1AA8  D7CE     BRA 0x1A46
183:           					sprintf(mc_response, cr_text->line4, cr_text->blank);
1AAA  0E28     MOVLW 0x28
1AAC  0100     MOVLB 0x0
1AAE  6FB4     MOVWF s, BANKED
1AB0  0E01     MOVLW 0x1
1AB2  6FB5     MOVWF 0xB5, BANKED
1AB4  0E44     MOVLW 0x44
1AB6  25D1     ADDWF cr_text, W, BANKED
1AB8  6FC6     MOVWF 0xC6, BANKED
1ABA  0E00     MOVLW 0x0
1ABC  21D2     ADDWFC 0xD2, W, BANKED
1ABE  6FC7     MOVWF 0xC7, BANKED
1AC0  C0C6     MOVFF 0xC6, TBLPTR
1AC2  FFF6     NOP
1AC4  C0C7     MOVFF 0xC7, TBLPTRH
1AC6  FFF7     NOP
1AC8  0009     TBLRD*+
1ACA  CFF5     MOVFF TABLAT, fmt
1ACC  F0B6     NOP
1ACE  000A     TBLRD*-
1AD0  CFF5     MOVFF TABLAT, 0xB7
1AD2  F0B7     NOP
1AD4  0E06     MOVLW 0x6
1AD6  25D1     ADDWF cr_text, W, BANKED
1AD8  6FC8     MOVWF 0xC8, BANKED
1ADA  0E00     MOVLW 0x0
1ADC  21D2     ADDWFC 0xD2, W, BANKED
1ADE  6FC9     MOVWF 0xC9, BANKED
1AE0  C0C8     MOVFF 0xC8, TBLPTR
1AE2  FFF6     NOP
1AE4  C0C9     MOVFF 0xC9, TBLPTRH
1AE6  FFF7     NOP
1AE8  0009     TBLRD*+
1AEA  CFF5     MOVFF TABLAT, ret
1AEC  F0B8     NOP
1AEE  000A     TBLRD*-
1AF0  CFF5     MOVFF TABLAT, 0xB9
1AF2  F0B9     NOP
1AF4  EC27     CALL 0x5E4E, 0
1AF6  F02F     NOP
184:           					display_ea_line(mc_response);
1AF8  0E28     MOVLW 0x28
1AFA  0100     MOVLB 0x0
1AFC  6FBC     MOVWF ret, BANKED
1AFE  0E01     MOVLW 0x1
1B00  6FBD     MOVWF 0xBD, BANKED
1B02  EC5D     CALL 0x6ABA, 0
1B04  F035     NOP
185:           					BUZZER_ON;
1B06  ECE7     CALL 0x6BCE, 0
1B08  F035     NOP
186:           					appData.sw1 = false;
1B0A  0E00     MOVLW 0x0
1B0C  0101     MOVLB 0x1
1B0E  6FD9     MOVWF 0xD9, BANKED
187:           					WaitMs(100);
1B10  0E00     MOVLW 0x0
1B12  6E1B     MOVWF c, ACCESS
1B14  0E64     MOVLW 0x64
1B16  6E1A     MOVWF s, ACCESS
1B18  EC27     CALL 0x6A4E, 0
1B1A  F035     NOP
188:           					BUZZER_OFF;
1B1C  ECE5     CALL 0x6BCA, 0
1B1E  F035     NOP
189:           
190:           					clear_MC_port();
1B20  EC63     CALL 0x66C6, 0
1B22  F033     NOP
191:           					MC_SendCommand(cr_text->en, true);
1B24  0E2E     MOVLW 0x2E
1B26  0100     MOVLB 0x0
1B28  25D1     ADDWF cr_text, W, BANKED
1B2A  6FC6     MOVWF 0xC6, BANKED
1B2C  0E00     MOVLW 0x0
1B2E  21D2     ADDWFC 0xD2, W, BANKED
1B30  6FC7     MOVWF 0xC7, BANKED
1B32  C0C6     MOVFF 0xC6, TBLPTR
1B34  FFF6     NOP
1B36  C0C7     MOVFF 0xC7, TBLPTRH
1B38  FFF7     NOP
1B3A  0009     TBLRD*+
1B3C  CFF5     MOVFF TABLAT, c
1B3E  F01C     NOP
1B40  000A     TBLRD*-
1B42  CFF5     MOVFF TABLAT, divisor
1B44  F01D     NOP
1B46  0E01     MOVLW 0x1
1B48  6E1E     MOVWF l, ACCESS
1B4A  ECBB     CALL 0x5D76, 0
1B4C  F02E     NOP
192:           					MC_SendCommand(cr_text->t35, true);
1B4E  0E30     MOVLW 0x30
1B50  0100     MOVLB 0x0
1B52  25D1     ADDWF cr_text, W, BANKED
1B54  6FC6     MOVWF 0xC6, BANKED
1B56  0E00     MOVLW 0x0
1B58  21D2     ADDWFC 0xD2, W, BANKED
1B5A  6FC7     MOVWF 0xC7, BANKED
1B5C  C0C6     MOVFF 0xC6, TBLPTR
1B5E  FFF6     NOP
1B60  C0C7     MOVFF 0xC7, TBLPTRH
1B62  FFF7     NOP
1B64  0009     TBLRD*+
1B66  CFF5     MOVFF TABLAT, c
1B68  F01C     NOP
1B6A  000A     TBLRD*-
1B6C  CFF5     MOVFF TABLAT, divisor
1B6E  F01D     NOP
1B70  0E01     MOVLW 0x1
1B72  6E1E     MOVWF l, ACCESS
1B74  ECBB     CALL 0x5D76, 0
1B76  F02E     NOP
193:           					sprintf(mc_response, cr_text->line1, cr_text->blank);
1B78  0E28     MOVLW 0x28
1B7A  0100     MOVLB 0x0
1B7C  6FB4     MOVWF s, BANKED
1B7E  0E01     MOVLW 0x1
1B80  6FB5     MOVWF 0xB5, BANKED
1B82  0E3E     MOVLW 0x3E
1B84  25D1     ADDWF cr_text, W, BANKED
1B86  6FC6     MOVWF 0xC6, BANKED
1B88  0E00     MOVLW 0x0
1B8A  21D2     ADDWFC 0xD2, W, BANKED
1B8C  6FC7     MOVWF 0xC7, BANKED
1B8E  C0C6     MOVFF 0xC6, TBLPTR
1B90  FFF6     NOP
1B92  C0C7     MOVFF 0xC7, TBLPTRH
1B94  FFF7     NOP
1B96  0009     TBLRD*+
1B98  CFF5     MOVFF TABLAT, fmt
1B9A  F0B6     NOP
1B9C  000A     TBLRD*-
1B9E  CFF5     MOVFF TABLAT, 0xB7
1BA0  F0B7     NOP
1BA2  0E06     MOVLW 0x6
1BA4  25D1     ADDWF cr_text, W, BANKED
1BA6  6FC8     MOVWF 0xC8, BANKED
1BA8  0E00     MOVLW 0x0
1BAA  21D2     ADDWFC 0xD2, W, BANKED
1BAC  6FC9     MOVWF 0xC9, BANKED
1BAE  C0C8     MOVFF 0xC8, TBLPTR
1BB0  FFF6     NOP
1BB2  C0C9     MOVFF 0xC9, TBLPTRH
1BB4  FFF7     NOP
1BB6  0009     TBLRD*+
1BB8  CFF5     MOVFF TABLAT, ret
1BBA  F0B8     NOP
1BBC  000A     TBLRD*-
1BBE  CFF5     MOVFF TABLAT, 0xB9
1BC0  F0B9     NOP
1BC2  EC27     CALL 0x5E4E, 0
1BC4  F02F     NOP
194:           					display_ea_line(mc_response);
1BC6  0E28     MOVLW 0x28
1BC8  0100     MOVLB 0x0
1BCA  6FBC     MOVWF ret, BANKED
1BCC  0E01     MOVLW 0x1
1BCE  6FBD     MOVWF 0xBD, BANKED
1BD0  EC5D     CALL 0x6ABA, 0
1BD2  F035     NOP
195:           					sprintf(mc_response, cr_text->line2, cr_text->blank);
1BD4  0E28     MOVLW 0x28
1BD6  0100     MOVLB 0x0
1BD8  6FB4     MOVWF s, BANKED
1BDA  0E01     MOVLW 0x1
1BDC  6FB5     MOVWF 0xB5, BANKED
1BDE  0E40     MOVLW 0x40
1BE0  25D1     ADDWF cr_text, W, BANKED
1BE2  6FC6     MOVWF 0xC6, BANKED
1BE4  0E00     MOVLW 0x0
1BE6  21D2     ADDWFC 0xD2, W, BANKED
1BE8  6FC7     MOVWF 0xC7, BANKED
1BEA  C0C6     MOVFF 0xC6, TBLPTR
1BEC  FFF6     NOP
1BEE  C0C7     MOVFF 0xC7, TBLPTRH
1BF0  FFF7     NOP
1BF2  0009     TBLRD*+
1BF4  CFF5     MOVFF TABLAT, fmt
1BF6  F0B6     NOP
1BF8  000A     TBLRD*-
1BFA  CFF5     MOVFF TABLAT, 0xB7
1BFC  F0B7     NOP
1BFE  0E06     MOVLW 0x6
1C00  25D1     ADDWF cr_text, W, BANKED
1C02  6FC8     MOVWF 0xC8, BANKED
1C04  0E00     MOVLW 0x0
1C06  21D2     ADDWFC 0xD2, W, BANKED
1C08  6FC9     MOVWF 0xC9, BANKED
1C0A  C0C8     MOVFF 0xC8, TBLPTR
1C0C  FFF6     NOP
1C0E  C0C9     MOVFF 0xC9, TBLPTRH
1C10  FFF7     NOP
1C12  0009     TBLRD*+
1C14  CFF5     MOVFF TABLAT, ret
1C16  F0B8     NOP
1C18  000A     TBLRD*-
1C1A  CFF5     MOVFF TABLAT, 0xB9
1C1C  F0B9     NOP
1C1E  EC27     CALL 0x5E4E, 0
1C20  F02F     NOP
196:           					display_ea_line(mc_response);
1C22  0E28     MOVLW 0x28
1C24  0100     MOVLB 0x0
1C26  6FBC     MOVWF ret, BANKED
1C28  0E01     MOVLW 0x1
1C2A  6FBD     MOVWF 0xBD, BANKED
1C2C  EC5D     CALL 0x6ABA, 0
1C2E  F035     NOP
197:           					sprintf(mc_response, cr_text->line3, cr_text->blank);
1C30  0E28     MOVLW 0x28
1C32  0100     MOVLB 0x0
1C34  6FB4     MOVWF s, BANKED
1C36  0E01     MOVLW 0x1
1C38  6FB5     MOVWF 0xB5, BANKED
1C3A  0E42     MOVLW 0x42
1C3C  25D1     ADDWF cr_text, W, BANKED
1C3E  6FC6     MOVWF 0xC6, BANKED
1C40  0E00     MOVLW 0x0
1C42  21D2     ADDWFC 0xD2, W, BANKED
1C44  6FC7     MOVWF 0xC7, BANKED
1C46  C0C6     MOVFF 0xC6, TBLPTR
1C48  FFF6     NOP
1C4A  C0C7     MOVFF 0xC7, TBLPTRH
1C4C  FFF7     NOP
1C4E  0009     TBLRD*+
1C50  CFF5     MOVFF TABLAT, fmt
1C52  F0B6     NOP
1C54  000A     TBLRD*-
1C56  CFF5     MOVFF TABLAT, 0xB7
1C58  F0B7     NOP
1C5A  0E06     MOVLW 0x6
1C5C  25D1     ADDWF cr_text, W, BANKED
1C5E  6FC8     MOVWF 0xC8, BANKED
1C60  0E00     MOVLW 0x0
1C62  21D2     ADDWFC 0xD2, W, BANKED
1C64  6FC9     MOVWF 0xC9, BANKED
1C66  C0C8     MOVFF 0xC8, TBLPTR
1C68  FFF6     NOP
1C6A  C0C9     MOVFF 0xC9, TBLPTRH
1C6C  FFF7     NOP
1C6E  0009     TBLRD*+
1C70  CFF5     MOVFF TABLAT, ret
1C72  F0B8     NOP
1C74  000A     TBLRD*-
1C76  CFF5     MOVFF TABLAT, 0xB9
1C78  F0B9     NOP
1C7A  EC27     CALL 0x5E4E, 0
1C7C  F02F     NOP
198:           					display_ea_line(mc_response);
1C7E  0E28     MOVLW 0x28
1C80  0100     MOVLB 0x0
1C82  6FBC     MOVWF ret, BANKED
1C84  0E01     MOVLW 0x1
1C86  6FBD     MOVWF 0xBD, BANKED
1C88  EC5D     CALL 0x6ABA, 0
1C8A  F035     NOP
199:           
200:           					c_down = 15;
1C8C  0E0F     MOVLW 0xF
1C8E  0100     MOVLB 0x0
1C90  6FCC     MOVWF c_down, BANKED
201:           					while (c_down--) {
1C92  D036     BRA 0x1D00
202:           						sprintf(mc_response, cr_text->line_d, cr_text->diskmove, c_down);
1C94  0E28     MOVLW 0x28
1C96  6FB4     MOVWF s, BANKED
1C98  0E01     MOVLW 0x1
1C9A  6FB5     MOVWF 0xB5, BANKED
1C9C  0E46     MOVLW 0x46
1C9E  25D1     ADDWF cr_text, W, BANKED
1CA0  6FC6     MOVWF 0xC6, BANKED
1CA2  0E00     MOVLW 0x0
1CA4  21D2     ADDWFC 0xD2, W, BANKED
1CA6  6FC7     MOVWF 0xC7, BANKED
1CA8  C0C6     MOVFF 0xC6, TBLPTR
1CAA  FFF6     NOP
1CAC  C0C7     MOVFF 0xC7, TBLPTRH
1CAE  FFF7     NOP
1CB0  0009     TBLRD*+
1CB2  CFF5     MOVFF TABLAT, fmt
1CB4  F0B6     NOP
1CB6  000A     TBLRD*-
1CB8  CFF5     MOVFF TABLAT, 0xB7
1CBA  F0B7     NOP
1CBC  0E22     MOVLW 0x22
1CBE  25D1     ADDWF cr_text, W, BANKED
1CC0  6FC8     MOVWF 0xC8, BANKED
1CC2  0E00     MOVLW 0x0
1CC4  21D2     ADDWFC 0xD2, W, BANKED
1CC6  6FC9     MOVWF 0xC9, BANKED
1CC8  C0C8     MOVFF 0xC8, TBLPTR
1CCA  FFF6     NOP
1CCC  C0C9     MOVFF 0xC9, TBLPTRH
1CCE  FFF7     NOP
1CD0  0009     TBLRD*+
1CD2  CFF5     MOVFF TABLAT, ret
1CD4  F0B8     NOP
1CD6  000A     TBLRD*-
1CD8  CFF5     MOVFF TABLAT, 0xB9
1CDA  F0B9     NOP
1CDC  C0CC     MOVFF c_down, ap
1CDE  F0BA     NOP
1CE0  6BBB     CLRF 0xBB, BANKED
1CE2  EC27     CALL 0x5E4E, 0
1CE4  F02F     NOP
203:           						display_ea_line(mc_response);
1CE6  0E28     MOVLW 0x28
1CE8  0100     MOVLB 0x0
1CEA  6FBC     MOVWF ret, BANKED
1CEC  0E01     MOVLW 0x1
1CEE  6FBD     MOVWF 0xBD, BANKED
1CF0  EC5D     CALL 0x6ABA, 0
1CF2  F035     NOP
204:           						WaitMs(1000); // wait while spin disk moves to motor locked position
1CF4  0E03     MOVLW 0x3
1CF6  6E1B     MOVWF c, ACCESS
1CF8  0EE8     MOVLW 0xE8
1CFA  6E1A     MOVWF s, ACCESS
1CFC  EC27     CALL 0x6A4E, 0
1CFE  F035     NOP
205:           					}
1D00  0100     MOVLB 0x0
1D02  07CC     DECF c_down, F, BANKED
1D04  29CC     INCF c_down, W, BANKED
1D06  A4D8     BTFSS STATUS, 2, ACCESS
1D08  D7C5     BRA 0x1C94
206:           					clear_MC_port();
1D0A  EC63     CALL 0x66C6, 0
1D0C  F033     NOP
207:           					MC_SendCommand(cr_text->pfb, true);
1D0E  0E32     MOVLW 0x32
1D10  0100     MOVLB 0x0
1D12  25D1     ADDWF cr_text, W, BANKED
1D14  6FC6     MOVWF 0xC6, BANKED
1D16  0E00     MOVLW 0x0
1D18  21D2     ADDWFC 0xD2, W, BANKED
1D1A  6FC7     MOVWF 0xC7, BANKED
1D1C  C0C6     MOVFF 0xC6, TBLPTR
1D1E  FFF6     NOP
1D20  C0C7     MOVFF 0xC7, TBLPTRH
1D22  FFF7     NOP
1D24  0009     TBLRD*+
1D26  CFF5     MOVFF TABLAT, c
1D28  F01C     NOP
1D2A  000A     TBLRD*-
1D2C  CFF5     MOVFF TABLAT, divisor
1D2E  F01D     NOP
1D30  0E01     MOVLW 0x1
1D32  6E1E     MOVWF l, ACCESS
1D34  ECBB     CALL 0x5D76, 0
1D36  F02E     NOP
208:           					WaitMs(300);
1D38  0E01     MOVLW 0x1
1D3A  6E1B     MOVWF c, ACCESS
1D3C  0E2C     MOVLW 0x2C
1D3E  6E1A     MOVWF s, ACCESS
1D40  EC27     CALL 0x6A4E, 0
1D42  F035     NOP
209:           
210:           					/* find PFB command echo from controller */
211:           					StartTimer(TMR_MC_COMMS, MC_COMMS_MS);
1D44  0E03     MOVLW 0x3
1D46  6E16     MOVWF Message, ACCESS
1D48  0EE8     MOVLW 0xE8
1D4A  6E15     MOVWF dividend, ACCESS
1D4C  0E02     MOVLW 0x2
1D4E  EC1B     CALL 0x6836, 0
1D50  F034     NOP
212:           					while (!MC_ReceivePacket(appData.receive_packet)) {
1D52  D00A     BRA 0x1D68
213:           						if (TimerDone(TMR_MC_COMMS)) {
1D54  0E02     MOVLW 0x2
1D56  ECC3     CALL 0x6986, 0
1D58  F034     NOP
1D5A  0900     IORLW 0x0
1D5C  B4D8     BTFSC STATUS, 2, ACCESS
1D5E  D004     BRA 0x1D68
214:           							appData.state = APP_INITIALIZATION_ERROR;
1D60  0E01     MOVLW 0x1
1D62  0101     MOVLB 0x1
1D64  6F95     MOVWF 0x95, BANKED
215:           							break;
1D66  D009     BRA 0x1D7A
216:           						}
1D68  0E97     MOVLW 0x97
1D6A  6E16     MOVWF Message, ACCESS
1D6C  0E01     MOVLW 0x1
1D6E  6E17     MOVWF _r, ACCESS
1D70  EC58     CALL 0x54B0, 0
1D72  F02A     NOP
1D74  0900     IORLW 0x0
1D76  B4D8     BTFSC STATUS, 2, ACCESS
1D78  D7ED     BRA 0x1D54
217:           					}
218:           
219:           					/* find PFB resolver data from controller */
220:           					StartTimer(TMR_MC_COMMS, MC_COMMS_MS);
1D7A  0E03     MOVLW 0x3
1D7C  6E16     MOVWF Message, ACCESS
1D7E  0EE8     MOVLW 0xE8
1D80  6E15     MOVWF dividend, ACCESS
1D82  0E02     MOVLW 0x2
1D84  EC1B     CALL 0x6836, 0
1D86  F034     NOP
221:           					while (!MC_ReceivePacket(appData.receive_packet)) {
1D88  D00A     BRA 0x1D9E
222:           						if (TimerDone(TMR_MC_COMMS)) {
1D8A  0E02     MOVLW 0x2
1D8C  ECC3     CALL 0x6986, 0
1D8E  F034     NOP
1D90  0900     IORLW 0x0
1D92  B4D8     BTFSC STATUS, 2, ACCESS
1D94  D004     BRA 0x1D9E
223:           							appData.state = APP_INITIALIZATION_ERROR;
1D96  0E01     MOVLW 0x1
1D98  0101     MOVLB 0x1
1D9A  6F95     MOVWF 0x95, BANKED
224:           							break;
1D9C  D009     BRA 0x1DB0
225:           						}
1D9E  0E97     MOVLW 0x97
1DA0  6E16     MOVWF Message, ACCESS
1DA2  0E01     MOVLW 0x1
1DA4  6E17     MOVWF _r, ACCESS
1DA6  EC58     CALL 0x54B0, 0
1DA8  F02A     NOP
1DAA  0900     IORLW 0x0
1DAC  B4D8     BTFSC STATUS, 2, ACCESS
1DAE  D7ED     BRA 0x1D8A
226:           					}
227:           
228:           #ifdef	PRODUCTION
229:           					if (appData.state == APP_INITIALIZATION_ERROR)
1DB0  0101     MOVLB 0x1
1DB2  0595     DECF 0x95, W, BANKED
1DB4  B4D8     BTFSC STATUS, 2, ACCESS
1DB6  D373     BRA 0x249E
230:           						break;
231:           #endif
232:           
233:           					clear_MC_port();
1DB8  EC63     CALL 0x66C6, 0
1DBA  F033     NOP
234:           					sprintf(mc_response, cr_text->line1, cr_text->blank);
1DBC  0E28     MOVLW 0x28
1DBE  0100     MOVLB 0x0
1DC0  6FB4     MOVWF s, BANKED
1DC2  0E01     MOVLW 0x1
1DC4  6FB5     MOVWF 0xB5, BANKED
1DC6  0E3E     MOVLW 0x3E
1DC8  25D1     ADDWF cr_text, W, BANKED
1DCA  6FC6     MOVWF 0xC6, BANKED
1DCC  0E00     MOVLW 0x0
1DCE  21D2     ADDWFC 0xD2, W, BANKED
1DD0  6FC7     MOVWF 0xC7, BANKED
1DD2  C0C6     MOVFF 0xC6, TBLPTR
1DD4  FFF6     NOP
1DD6  C0C7     MOVFF 0xC7, TBLPTRH
1DD8  FFF7     NOP
1DDA  0009     TBLRD*+
1DDC  CFF5     MOVFF TABLAT, fmt
1DDE  F0B6     NOP
1DE0  000A     TBLRD*-
1DE2  CFF5     MOVFF TABLAT, 0xB7
1DE4  F0B7     NOP
1DE6  0E06     MOVLW 0x6
1DE8  25D1     ADDWF cr_text, W, BANKED
1DEA  6FC8     MOVWF 0xC8, BANKED
1DEC  0E00     MOVLW 0x0
1DEE  21D2     ADDWFC 0xD2, W, BANKED
1DF0  6FC9     MOVWF 0xC9, BANKED
1DF2  C0C8     MOVFF 0xC8, TBLPTR
1DF4  FFF6     NOP
1DF6  C0C9     MOVFF 0xC9, TBLPTRH
1DF8  FFF7     NOP
1DFA  0009     TBLRD*+
1DFC  CFF5     MOVFF TABLAT, ret
1DFE  F0B8     NOP
1E00  000A     TBLRD*-
1E02  CFF5     MOVFF TABLAT, 0xB9
1E04  F0B9     NOP
1E06  EC27     CALL 0x5E4E, 0
1E08  F02F     NOP
235:           					display_ea_line(mc_response);
1E0A  0E28     MOVLW 0x28
1E0C  0100     MOVLB 0x0
1E0E  6FBC     MOVWF ret, BANKED
1E10  0E01     MOVLW 0x1
1E12  6FBD     MOVWF 0xBD, BANKED
1E14  EC5D     CALL 0x6ABA, 0
1E16  F035     NOP
236:           					sprintf(mc_response, cr_text->line1, appData.receive_packet);
1E18  0E28     MOVLW 0x28
1E1A  0100     MOVLB 0x0
1E1C  6FB4     MOVWF s, BANKED
1E1E  0E01     MOVLW 0x1
1E20  6FB5     MOVWF 0xB5, BANKED
1E22  0E3E     MOVLW 0x3E
1E24  25D1     ADDWF cr_text, W, BANKED
1E26  6FC6     MOVWF 0xC6, BANKED
1E28  0E00     MOVLW 0x0
1E2A  21D2     ADDWFC 0xD2, W, BANKED
1E2C  6FC7     MOVWF 0xC7, BANKED
1E2E  C0C6     MOVFF 0xC6, TBLPTR
1E30  FFF6     NOP
1E32  C0C7     MOVFF 0xC7, TBLPTRH
1E34  FFF7     NOP
1E36  0009     TBLRD*+
1E38  CFF5     MOVFF TABLAT, fmt
1E3A  F0B6     NOP
1E3C  000A     TBLRD*-
1E3E  CFF5     MOVFF TABLAT, 0xB7
1E40  F0B7     NOP
1E42  0E97     MOVLW 0x97
1E44  6FB8     MOVWF ret, BANKED
1E46  0E01     MOVLW 0x1
1E48  6FB9     MOVWF 0xB9, BANKED
1E4A  EC27     CALL 0x5E4E, 0
1E4C  F02F     NOP
237:           					display_ea_line(mc_response);
1E4E  0E28     MOVLW 0x28
1E50  0100     MOVLB 0x0
1E52  6FBC     MOVWF ret, BANKED
1E54  0E01     MOVLW 0x1
1E56  6FBD     MOVWF 0xBD, BANKED
1E58  EC5D     CALL 0x6ABA, 0
1E5A  F035     NOP
238:           
239:           					/* find and compute resolver data */
240:           					if ((m_start = strstr(appData.receive_packet, cr_text->angle))) { // resolver angle data
1E5C  0E97     MOVLW 0x97
1E5E  6E22     MOVWF s, ACCESS
1E60  0E01     MOVLW 0x1
1E62  6E23     MOVWF sep, ACCESS
1E64  0E20     MOVLW 0x20
1E66  0100     MOVLB 0x0
1E68  25D1     ADDWF cr_text, W, BANKED
1E6A  6FC6     MOVWF 0xC6, BANKED
1E6C  0E00     MOVLW 0x0
1E6E  21D2     ADDWFC 0xD2, W, BANKED
1E70  6FC7     MOVWF 0xC7, BANKED
1E72  C0C6     MOVFF 0xC6, TBLPTR
1E74  FFF6     NOP
1E76  C0C7     MOVFF 0xC7, TBLPTRH
1E78  FFF7     NOP
1E7A  0009     TBLRD*+
1E7C  CFF5     MOVFF TABLAT, n
1E7E  F024     NOP
1E80  000A     TBLRD*-
1E82  CFF5     MOVFF TABLAT, quotient
1E84  F025     NOP
1E86  ECE4     CALL 0x5BC8, 0
1E88  F02D     NOP
1E8A  C022     MOVFF s, m_start
1E8C  F120     NOP
1E8E  C023     MOVFF sep, 0x121
1E90  F121     NOP
1E92  0101     MOVLB 0x1
1E94  5120     MOVF r, W, BANKED
1E96  1121     IORWF s, W, BANKED
1E98  B4D8     BTFSC STATUS, 2, ACCESS
1E9A  D094     BRA 0x1FC4
241:           						m_start[4] = ' '; // add another space for parser
1E9C  EE20     LFSR 2, 0x4
1E9E  F004     NOP
1EA0  5120     MOVF r, W, BANKED
1EA2  26D9     ADDWF FSR2, F, ACCESS
1EA4  5121     MOVF s, W, BANKED
1EA6  22DA     ADDWFC FSR2H, F, ACCESS
1EA8  0E20     MOVLW 0x20
1EAA  6EDF     MOVWF INDF2, ACCESS
242:           						m_start[5] = '\000'; // short terminate string
1EAC  EE20     LFSR 2, 0x5
1EAE  F005     NOP
1EB0  5120     MOVF r, W, BANKED
1EB2  26D9     ADDWF FSR2, F, ACCESS
1EB4  5121     MOVF s, W, BANKED
1EB6  22DA     ADDWFC FSR2H, F, ACCESS
1EB8  0E00     MOVLW 0x0
1EBA  6EDF     MOVWF INDF2, ACCESS
243:           						offset = get_pfb(&m_start[-8]); // pass a few of the first unused number digits
1EBC  0EF8     MOVLW 0xF8
1EBE  2520     ADDWF r, W, BANKED
1EC0  0100     MOVLB 0x0
1EC2  6FB4     MOVWF s, BANKED
1EC4  0EFF     MOVLW 0xFF
1EC6  0101     MOVLB 0x1
1EC8  2121     ADDWFC s, W, BANKED
1ECA  0100     MOVLB 0x0
1ECC  6FB5     MOVWF 0xB5, BANKED
1ECE  ECF8     CALL 0x47F0, 0
1ED0  F023     NOP
1ED2  C0B4     MOVFF s, offset
1ED4  F0CA     NOP
1ED6  C0B5     MOVFF 0xB5, 0xCB
1ED8  F0CB     NOP
244:           						if (offset == BADNUM) {
1EDA  0E9A     MOVLW 0x9A
1EDC  0100     MOVLB 0x0
1EDE  19CA     XORWF offset, W, BANKED
1EE0  E103     BNZ 0x1EE8
1EE2  0E02     MOVLW 0x2
1EE4  19CB     XORWF 0xCB, W, BANKED
1EE6  A4D8     BTFSS STATUS, 2, ACCESS
1EE8  D0E3     BRA 0x20B0
245:           							sprintf(mc_response, cr_text->line2, cr_text->error);
1EEA  0E28     MOVLW 0x28
1EEC  6FB4     MOVWF s, BANKED
1EEE  0E01     MOVLW 0x1
1EF0  6FB5     MOVWF 0xB5, BANKED
1EF2  0E40     MOVLW 0x40
1EF4  25D1     ADDWF cr_text, W, BANKED
1EF6  6FC6     MOVWF 0xC6, BANKED
1EF8  0E00     MOVLW 0x0
1EFA  21D2     ADDWFC 0xD2, W, BANKED
1EFC  6FC7     MOVWF 0xC7, BANKED
1EFE  C0C6     MOVFF 0xC6, TBLPTR
1F00  FFF6     NOP
1F02  C0C7     MOVFF 0xC7, TBLPTRH
1F04  FFF7     NOP
1F06  0009     TBLRD*+
1F08  CFF5     MOVFF TABLAT, fmt
1F0A  F0B6     NOP
1F0C  000A     TBLRD*-
1F0E  CFF5     MOVFF TABLAT, 0xB7
1F10  F0B7     NOP
1F12  0E3A     MOVLW 0x3A
1F14  25D1     ADDWF cr_text, W, BANKED
1F16  6FC8     MOVWF 0xC8, BANKED
1F18  0E00     MOVLW 0x0
1F1A  21D2     ADDWFC 0xD2, W, BANKED
1F1C  6FC9     MOVWF 0xC9, BANKED
1F1E  C0C8     MOVFF 0xC8, TBLPTR
1F20  FFF6     NOP
1F22  C0C9     MOVFF 0xC9, TBLPTRH
1F24  FFF7     NOP
1F26  0009     TBLRD*+
1F28  CFF5     MOVFF TABLAT, ret
1F2A  F0B8     NOP
1F2C  000A     TBLRD*-
1F2E  CFF5     MOVFF TABLAT, 0xB9
1F30  F0B9     NOP
1F32  EC27     CALL 0x5E4E, 0
1F34  F02F     NOP
246:           							display_ea_line(mc_response);
1F36  0E28     MOVLW 0x28
1F38  0100     MOVLB 0x0
1F3A  6FBC     MOVWF ret, BANKED
1F3C  0E01     MOVLW 0x1
1F3E  6FBD     MOVWF 0xBD, BANKED
1F40  EC5D     CALL 0x6ABA, 0
1F42  F035     NOP
247:           							c_down = 15;
1F44  0E0F     MOVLW 0xF
1F46  0100     MOVLB 0x0
1F48  6FCC     MOVWF c_down, BANKED
248:           							while (c_down--) {
1F4A  D036     BRA 0x1FB8
249:           								sprintf(mc_response, cr_text->line_d, cr_text->c1, c_down);
1F4C  0E28     MOVLW 0x28
1F4E  6FB4     MOVWF s, BANKED
1F50  0E01     MOVLW 0x1
1F52  6FB5     MOVWF 0xB5, BANKED
1F54  0E46     MOVLW 0x46
1F56  25D1     ADDWF cr_text, W, BANKED
1F58  6FC6     MOVWF 0xC6, BANKED
1F5A  0E00     MOVLW 0x0
1F5C  21D2     ADDWFC 0xD2, W, BANKED
1F5E  6FC7     MOVWF 0xC7, BANKED
1F60  C0C6     MOVFF 0xC6, TBLPTR
1F62  FFF6     NOP
1F64  C0C7     MOVFF 0xC7, TBLPTRH
1F66  FFF7     NOP
1F68  0009     TBLRD*+
1F6A  CFF5     MOVFF TABLAT, fmt
1F6C  F0B6     NOP
1F6E  000A     TBLRD*-
1F70  CFF5     MOVFF TABLAT, 0xB7
1F72  F0B7     NOP
1F74  0E08     MOVLW 0x8
1F76  25D1     ADDWF cr_text, W, BANKED
1F78  6FC8     MOVWF 0xC8, BANKED
1F7A  0E00     MOVLW 0x0
1F7C  21D2     ADDWFC 0xD2, W, BANKED
1F7E  6FC9     MOVWF 0xC9, BANKED
1F80  C0C8     MOVFF 0xC8, TBLPTR
1F82  FFF6     NOP
1F84  C0C9     MOVFF 0xC9, TBLPTRH
1F86  FFF7     NOP
1F88  0009     TBLRD*+
1F8A  CFF5     MOVFF TABLAT, ret
1F8C  F0B8     NOP
1F8E  000A     TBLRD*-
1F90  CFF5     MOVFF TABLAT, 0xB9
1F92  F0B9     NOP
1F94  C0CC     MOVFF c_down, ap
1F96  F0BA     NOP
1F98  6BBB     CLRF 0xBB, BANKED
1F9A  EC27     CALL 0x5E4E, 0
1F9C  F02F     NOP
250:           								display_ea_line(mc_response);
1F9E  0E28     MOVLW 0x28
1FA0  0100     MOVLB 0x0
1FA2  6FBC     MOVWF ret, BANKED
1FA4  0E01     MOVLW 0x1
1FA6  6FBD     MOVWF 0xBD, BANKED
1FA8  EC5D     CALL 0x6ABA, 0
1FAA  F035     NOP
251:           								WaitMs(333);
1FAC  0E01     MOVLW 0x1
1FAE  6E1B     MOVWF c, ACCESS
1FB0  0E4D     MOVLW 0x4D
1FB2  6E1A     MOVWF s, ACCESS
1FB4  EC27     CALL 0x6A4E, 0
1FB6  F035     NOP
252:           							}
1FB8  0100     MOVLB 0x0
1FBA  07CC     DECF c_down, F, BANKED
1FBC  29CC     INCF c_down, W, BANKED
1FBE  A4D8     BTFSS STATUS, 2, ACCESS
1FC0  D7C5     BRA 0x1F4C
1FC2  D071     BRA 0x20A6
253:           #ifdef	PRODUCTION
254:           							RESET();
255:           #endif
256:           							appData.state = APP_INITIALIZATION_ERROR;
257:           							break;
258:           						}
259:           					} else {
260:           						offset = BADNUM2;
1FC4  0E03     MOVLW 0x3
1FC6  0100     MOVLB 0x0
1FC8  6FCB     MOVWF 0xCB, BANKED
1FCA  0EE7     MOVLW 0xE7
1FCC  6FCA     MOVWF offset, BANKED
261:           						sprintf(mc_response, cr_text->line2, cr_text->error);
1FCE  0E28     MOVLW 0x28
1FD0  6FB4     MOVWF s, BANKED
1FD2  0E01     MOVLW 0x1
1FD4  6FB5     MOVWF 0xB5, BANKED
1FD6  0E40     MOVLW 0x40
1FD8  25D1     ADDWF cr_text, W, BANKED
1FDA  6FC6     MOVWF 0xC6, BANKED
1FDC  0E00     MOVLW 0x0
1FDE  21D2     ADDWFC 0xD2, W, BANKED
1FE0  6FC7     MOVWF 0xC7, BANKED
1FE2  C0C6     MOVFF 0xC6, TBLPTR
1FE4  FFF6     NOP
1FE6  C0C7     MOVFF 0xC7, TBLPTRH
1FE8  FFF7     NOP
1FEA  0009     TBLRD*+
1FEC  CFF5     MOVFF TABLAT, fmt
1FEE  F0B6     NOP
1FF0  000A     TBLRD*-
1FF2  CFF5     MOVFF TABLAT, 0xB7
1FF4  F0B7     NOP
1FF6  0E3A     MOVLW 0x3A
1FF8  25D1     ADDWF cr_text, W, BANKED
1FFA  6FC8     MOVWF 0xC8, BANKED
1FFC  0E00     MOVLW 0x0
1FFE  21D2     ADDWFC 0xD2, W, BANKED
2000  6FC9     MOVWF 0xC9, BANKED
2002  C0C8     MOVFF 0xC8, TBLPTR
2004  FFF6     NOP
2006  C0C9     MOVFF 0xC9, TBLPTRH
2008  FFF7     NOP
200A  0009     TBLRD*+
200C  CFF5     MOVFF TABLAT, ret
200E  F0B8     NOP
2010  000A     TBLRD*-
2012  CFF5     MOVFF TABLAT, 0xB9
2014  F0B9     NOP
2016  EC27     CALL 0x5E4E, 0
2018  F02F     NOP
262:           						display_ea_line(mc_response);
201A  0E28     MOVLW 0x28
201C  0100     MOVLB 0x0
201E  6FBC     MOVWF ret, BANKED
2020  0E01     MOVLW 0x1
2022  6FBD     MOVWF 0xBD, BANKED
2024  EC5D     CALL 0x6ABA, 0
2026  F035     NOP
263:           						c_down = 15;
2028  0E0F     MOVLW 0xF
202A  0100     MOVLB 0x0
202C  6FCC     MOVWF c_down, BANKED
264:           						while (c_down--) {
202E  D036     BRA 0x209C
265:           							sprintf(mc_response, cr_text->line_d, cr_text->c1, c_down);
2030  0E28     MOVLW 0x28
2032  6FB4     MOVWF s, BANKED
2034  0E01     MOVLW 0x1
2036  6FB5     MOVWF 0xB5, BANKED
2038  0E46     MOVLW 0x46
203A  25D1     ADDWF cr_text, W, BANKED
203C  6FC6     MOVWF 0xC6, BANKED
203E  0E00     MOVLW 0x0
2040  21D2     ADDWFC 0xD2, W, BANKED
2042  6FC7     MOVWF 0xC7, BANKED
2044  C0C6     MOVFF 0xC6, TBLPTR
2046  FFF6     NOP
2048  C0C7     MOVFF 0xC7, TBLPTRH
204A  FFF7     NOP
204C  0009     TBLRD*+
204E  CFF5     MOVFF TABLAT, fmt
2050  F0B6     NOP
2052  000A     TBLRD*-
2054  CFF5     MOVFF TABLAT, 0xB7
2056  F0B7     NOP
2058  0E08     MOVLW 0x8
205A  25D1     ADDWF cr_text, W, BANKED
205C  6FC8     MOVWF 0xC8, BANKED
205E  0E00     MOVLW 0x0
2060  21D2     ADDWFC 0xD2, W, BANKED
2062  6FC9     MOVWF 0xC9, BANKED
2064  C0C8     MOVFF 0xC8, TBLPTR
2066  FFF6     NOP
2068  C0C9     MOVFF 0xC9, TBLPTRH
206A  FFF7     NOP
206C  0009     TBLRD*+
206E  CFF5     MOVFF TABLAT, ret
2070  F0B8     NOP
2072  000A     TBLRD*-
2074  CFF5     MOVFF TABLAT, 0xB9
2076  F0B9     NOP
2078  C0CC     MOVFF c_down, ap
207A  F0BA     NOP
207C  6BBB     CLRF 0xBB, BANKED
207E  EC27     CALL 0x5E4E, 0
2080  F02F     NOP
266:           							display_ea_line(mc_response);
2082  0E28     MOVLW 0x28
2084  0100     MOVLB 0x0
2086  6FBC     MOVWF ret, BANKED
2088  0E01     MOVLW 0x1
208A  6FBD     MOVWF 0xBD, BANKED
208C  EC5D     CALL 0x6ABA, 0
208E  F035     NOP
267:           							WaitMs(333);
2090  0E01     MOVLW 0x1
2092  6E1B     MOVWF c, ACCESS
2094  0E4D     MOVLW 0x4D
2096  6E1A     MOVWF s, ACCESS
2098  EC27     CALL 0x6A4E, 0
209A  F035     NOP
268:           						}
209C  0100     MOVLB 0x0
209E  07CC     DECF c_down, F, BANKED
20A0  29CC     INCF c_down, W, BANKED
20A2  A4D8     BTFSS STATUS, 2, ACCESS
20A4  D7C5     BRA 0x2030
269:           #ifdef	PRODUCTION
270:           						RESET(); // something is wrong so restart mcu
20A6  00FF     RESET
271:           #endif
272:           						appData.state = APP_INITIALIZATION_ERROR;
20A8  0E01     MOVLW 0x1
20AA  0101     MOVLB 0x1
20AC  6F95     MOVWF 0x95, BANKED
273:           						break;
20AE  D1F7     BRA 0x249E
274:           					}
275:           
276:           					sprintf(mc_response, cr_text->line2, cr_text->blank);
20B0  0E28     MOVLW 0x28
20B2  0100     MOVLB 0x0
20B4  6FB4     MOVWF s, BANKED
20B6  0E01     MOVLW 0x1
20B8  6FB5     MOVWF 0xB5, BANKED
20BA  0E40     MOVLW 0x40
20BC  25D1     ADDWF cr_text, W, BANKED
20BE  6FC6     MOVWF 0xC6, BANKED
20C0  0E00     MOVLW 0x0
20C2  21D2     ADDWFC 0xD2, W, BANKED
20C4  6FC7     MOVWF 0xC7, BANKED
20C6  C0C6     MOVFF 0xC6, TBLPTR
20C8  FFF6     NOP
20CA  C0C7     MOVFF 0xC7, TBLPTRH
20CC  FFF7     NOP
20CE  0009     TBLRD*+
20D0  CFF5     MOVFF TABLAT, fmt
20D2  F0B6     NOP
20D4  000A     TBLRD*-
20D6  CFF5     MOVFF TABLAT, 0xB7
20D8  F0B7     NOP
20DA  0E06     MOVLW 0x6
20DC  25D1     ADDWF cr_text, W, BANKED
20DE  6FC8     MOVWF 0xC8, BANKED
20E0  0E00     MOVLW 0x0
20E2  21D2     ADDWFC 0xD2, W, BANKED
20E4  6FC9     MOVWF 0xC9, BANKED
20E6  C0C8     MOVFF 0xC8, TBLPTR
20E8  FFF6     NOP
20EA  C0C9     MOVFF 0xC9, TBLPTRH
20EC  FFF7     NOP
20EE  0009     TBLRD*+
20F0  CFF5     MOVFF TABLAT, ret
20F2  F0B8     NOP
20F4  000A     TBLRD*-
20F6  CFF5     MOVFF TABLAT, 0xB9
20F8  F0B9     NOP
20FA  EC27     CALL 0x5E4E, 0
20FC  F02F     NOP
277:           					display_ea_line(mc_response);
20FE  0E28     MOVLW 0x28
2100  0100     MOVLB 0x0
2102  6FBC     MOVWF ret, BANKED
2104  0E01     MOVLW 0x1
2106  6FBD     MOVWF 0xBD, BANKED
2108  EC5D     CALL 0x6ABA, 0
210A  F035     NOP
278:           					sprintf(mc_response, rs_text->line_o, offset);
210C  0E28     MOVLW 0x28
210E  0100     MOVLB 0x0
2110  6FB4     MOVWF s, BANKED
2112  0E01     MOVLW 0x1
2114  6FB5     MOVWF 0xB5, BANKED
2116  0E02     MOVLW 0x2
2118  0101     MOVLB 0x1
211A  2593     ADDWF done, W, BANKED
211C  0100     MOVLB 0x0
211E  6FC6     MOVWF 0xC6, BANKED
2120  0E00     MOVLW 0x0
2122  0101     MOVLB 0x1
2124  2194     ADDWFC 0x94, W, BANKED
2126  0100     MOVLB 0x0
2128  6FC7     MOVWF 0xC7, BANKED
212A  C0C6     MOVFF 0xC6, TBLPTR
212C  FFF6     NOP
212E  C0C7     MOVFF 0xC7, TBLPTRH
2130  FFF7     NOP
2132  0009     TBLRD*+
2134  CFF5     MOVFF TABLAT, fmt
2136  F0B6     NOP
2138  000A     TBLRD*-
213A  CFF5     MOVFF TABLAT, 0xB7
213C  F0B7     NOP
213E  C0CA     MOVFF offset, ret
2140  F0B8     NOP
2142  C0CB     MOVFF 0xCB, 0xB9
2144  F0B9     NOP
2146  EC27     CALL 0x5E4E, 0
2148  F02F     NOP
279:           					display_ea_line(mc_response);
214A  0E28     MOVLW 0x28
214C  0100     MOVLB 0x0
214E  6FBC     MOVWF ret, BANKED
2150  0E01     MOVLW 0x1
2152  6FBD     MOVWF 0xBD, BANKED
2154  EC5D     CALL 0x6ABA, 0
2156  F035     NOP
280:           					WaitMs(6000);
2158  0E17     MOVLW 0x17
215A  6E1B     MOVWF c, ACCESS
215C  0E70     MOVLW 0x70
215E  6E1A     MOVWF s, ACCESS
2160  EC27     CALL 0x6A4E, 0
2162  F035     NOP
281:           
282:           					MC_SendCommand(cr_text->dis, true);
2164  0E24     MOVLW 0x24
2166  0100     MOVLB 0x0
2168  25D1     ADDWF cr_text, W, BANKED
216A  6FC6     MOVWF 0xC6, BANKED
216C  0E00     MOVLW 0x0
216E  21D2     ADDWFC 0xD2, W, BANKED
2170  6FC7     MOVWF 0xC7, BANKED
2172  C0C6     MOVFF 0xC6, TBLPTR
2174  FFF6     NOP
2176  C0C7     MOVFF 0xC7, TBLPTRH
2178  FFF7     NOP
217A  0009     TBLRD*+
217C  CFF5     MOVFF TABLAT, c
217E  F01C     NOP
2180  000A     TBLRD*-
2182  CFF5     MOVFF TABLAT, divisor
2184  F01D     NOP
2186  0E01     MOVLW 0x1
2188  6E1E     MOVWF l, ACCESS
218A  ECBB     CALL 0x5D76, 0
218C  F02E     NOP
283:           
284:           					sprintf(mc_response, cr_text->line2, cr_text->s3);
218E  0E28     MOVLW 0x28
2190  0100     MOVLB 0x0
2192  6FB4     MOVWF s, BANKED
2194  0E01     MOVLW 0x1
2196  6FB5     MOVWF 0xB5, BANKED
2198  0E40     MOVLW 0x40
219A  25D1     ADDWF cr_text, W, BANKED
219C  6FC6     MOVWF 0xC6, BANKED
219E  0E00     MOVLW 0x0
21A0  21D2     ADDWFC 0xD2, W, BANKED
21A2  6FC7     MOVWF 0xC7, BANKED
21A4  C0C6     MOVFF 0xC6, TBLPTR
21A6  FFF6     NOP
21A8  C0C7     MOVFF 0xC7, TBLPTRH
21AA  FFF7     NOP
21AC  0009     TBLRD*+
21AE  CFF5     MOVFF TABLAT, fmt
21B0  F0B6     NOP
21B2  000A     TBLRD*-
21B4  CFF5     MOVFF TABLAT, 0xB7
21B6  F0B7     NOP
21B8  0E18     MOVLW 0x18
21BA  25D1     ADDWF cr_text, W, BANKED
21BC  6FC8     MOVWF 0xC8, BANKED
21BE  0E00     MOVLW 0x0
21C0  21D2     ADDWFC 0xD2, W, BANKED
21C2  6FC9     MOVWF 0xC9, BANKED
21C4  C0C8     MOVFF 0xC8, TBLPTR
21C6  FFF6     NOP
21C8  C0C9     MOVFF 0xC9, TBLPTRH
21CA  FFF7     NOP
21CC  0009     TBLRD*+
21CE  CFF5     MOVFF TABLAT, ret
21D0  F0B8     NOP
21D2  000A     TBLRD*-
21D4  CFF5     MOVFF TABLAT, 0xB9
21D6  F0B9     NOP
21D8  EC27     CALL 0x5E4E, 0
21DA  F02F     NOP
285:           					display_ea_line(mc_response);
21DC  0E28     MOVLW 0x28
21DE  0100     MOVLB 0x0
21E0  6FBC     MOVWF ret, BANKED
21E2  0E01     MOVLW 0x1
21E4  6FBD     MOVWF 0xBD, BANKED
21E6  EC5D     CALL 0x6ABA, 0
21E8  F035     NOP
286:           					sprintf(mc_response, cr_text->line3, cr_text->w3);
21EA  0E28     MOVLW 0x28
21EC  0100     MOVLB 0x0
21EE  6FB4     MOVWF s, BANKED
21F0  0E01     MOVLW 0x1
21F2  6FB5     MOVWF 0xB5, BANKED
21F4  0E42     MOVLW 0x42
21F6  25D1     ADDWF cr_text, W, BANKED
21F8  6FC6     MOVWF 0xC6, BANKED
21FA  0E00     MOVLW 0x0
21FC  21D2     ADDWFC 0xD2, W, BANKED
21FE  6FC7     MOVWF 0xC7, BANKED
2200  C0C6     MOVFF 0xC6, TBLPTR
2202  FFF6     NOP
2204  C0C7     MOVFF 0xC7, TBLPTRH
2206  FFF7     NOP
2208  0009     TBLRD*+
220A  CFF5     MOVFF TABLAT, fmt
220C  F0B6     NOP
220E  000A     TBLRD*-
2210  CFF5     MOVFF TABLAT, 0xB7
2212  F0B7     NOP
2214  0E1E     MOVLW 0x1E
2216  25D1     ADDWF cr_text, W, BANKED
2218  6FC8     MOVWF 0xC8, BANKED
221A  0E00     MOVLW 0x0
221C  21D2     ADDWFC 0xD2, W, BANKED
221E  6FC9     MOVWF 0xC9, BANKED
2220  C0C8     MOVFF 0xC8, TBLPTR
2222  FFF6     NOP
2224  C0C9     MOVFF 0xC9, TBLPTRH
2226  FFF7     NOP
2228  0009     TBLRD*+
222A  CFF5     MOVFF TABLAT, ret
222C  F0B8     NOP
222E  000A     TBLRD*-
2230  CFF5     MOVFF TABLAT, 0xB9
2232  F0B9     NOP
2234  EC27     CALL 0x5E4E, 0
2236  F02F     NOP
287:           					display_ea_line(mc_response);
2238  0E28     MOVLW 0x28
223A  0100     MOVLB 0x0
223C  6FBC     MOVWF ret, BANKED
223E  0E01     MOVLW 0x1
2240  6FBD     MOVWF 0xBD, BANKED
2242  EC5D     CALL 0x6ABA, 0
2244  F035     NOP
288:           					while (!appData.sw1) {
2246  D02E     BRA 0x22A4
289:           						sprintf(mc_response, cr_text->line4, cr_text->buttonp);
2248  0E28     MOVLW 0x28
224A  0100     MOVLB 0x0
224C  6FB4     MOVWF s, BANKED
224E  0E01     MOVLW 0x1
2250  6FB5     MOVWF 0xB5, BANKED
2252  0E44     MOVLW 0x44
2254  25D1     ADDWF cr_text, W, BANKED
2256  6FC6     MOVWF 0xC6, BANKED
2258  0E00     MOVLW 0x0
225A  21D2     ADDWFC 0xD2, W, BANKED
225C  6FC7     MOVWF 0xC7, BANKED
225E  C0C6     MOVFF 0xC6, TBLPTR
2260  FFF6     NOP
2262  C0C7     MOVFF 0xC7, TBLPTRH
2264  FFF7     NOP
2266  0009     TBLRD*+
2268  CFF5     MOVFF TABLAT, fmt
226A  F0B6     NOP
226C  000A     TBLRD*-
226E  CFF5     MOVFF TABLAT, 0xB7
2270  F0B7     NOP
2272  0E04     MOVLW 0x4
2274  25D1     ADDWF cr_text, W, BANKED
2276  6FC8     MOVWF 0xC8, BANKED
2278  0E00     MOVLW 0x0
227A  21D2     ADDWFC 0xD2, W, BANKED
227C  6FC9     MOVWF 0xC9, BANKED
227E  C0C8     MOVFF 0xC8, TBLPTR
2280  FFF6     NOP
2282  C0C9     MOVFF 0xC9, TBLPTRH
2284  FFF7     NOP
2286  0009     TBLRD*+
2288  CFF5     MOVFF TABLAT, ret
228A  F0B8     NOP
228C  000A     TBLRD*-
228E  CFF5     MOVFF TABLAT, 0xB9
2290  F0B9     NOP
2292  EC27     CALL 0x5E4E, 0
2294  F02F     NOP
290:           						display_ea_line(mc_response);
2296  0E28     MOVLW 0x28
2298  0100     MOVLB 0x0
229A  6FBC     MOVWF ret, BANKED
229C  0E01     MOVLW 0x1
229E  6FBD     MOVWF 0xBD, BANKED
22A0  EC5D     CALL 0x6ABA, 0
22A2  F035     NOP
291:           					}
22A4  0101     MOVLB 0x1
22A6  51D9     MOVF 0xD9, W, BANKED
22A8  B4D8     BTFSC STATUS, 2, ACCESS
22AA  D7CE     BRA 0x2248
292:           					sprintf(mc_response, cr_text->line1, cr_text->blank);
22AC  0E28     MOVLW 0x28
22AE  0100     MOVLB 0x0
22B0  6FB4     MOVWF s, BANKED
22B2  0E01     MOVLW 0x1
22B4  6FB5     MOVWF 0xB5, BANKED
22B6  0E3E     MOVLW 0x3E
22B8  25D1     ADDWF cr_text, W, BANKED
22BA  6FC6     MOVWF 0xC6, BANKED
22BC  0E00     MOVLW 0x0
22BE  21D2     ADDWFC 0xD2, W, BANKED
22C0  6FC7     MOVWF 0xC7, BANKED
22C2  C0C6     MOVFF 0xC6, TBLPTR
22C4  FFF6     NOP
22C6  C0C7     MOVFF 0xC7, TBLPTRH
22C8  FFF7     NOP
22CA  0009     TBLRD*+
22CC  CFF5     MOVFF TABLAT, fmt
22CE  F0B6     NOP
22D0  000A     TBLRD*-
22D2  CFF5     MOVFF TABLAT, 0xB7
22D4  F0B7     NOP
22D6  0E06     MOVLW 0x6
22D8  25D1     ADDWF cr_text, W, BANKED
22DA  6FC8     MOVWF 0xC8, BANKED
22DC  0E00     MOVLW 0x0
22DE  21D2     ADDWFC 0xD2, W, BANKED
22E0  6FC9     MOVWF 0xC9, BANKED
22E2  C0C8     MOVFF 0xC8, TBLPTR
22E4  FFF6     NOP
22E6  C0C9     MOVFF 0xC9, TBLPTRH
22E8  FFF7     NOP
22EA  0009     TBLRD*+
22EC  CFF5     MOVFF TABLAT, ret
22EE  F0B8     NOP
22F0  000A     TBLRD*-
22F2  CFF5     MOVFF TABLAT, 0xB9
22F4  F0B9     NOP
22F6  EC27     CALL 0x5E4E, 0
22F8  F02F     NOP
293:           					display_ea_line(mc_response);
22FA  0E28     MOVLW 0x28
22FC  0100     MOVLB 0x0
22FE  6FBC     MOVWF ret, BANKED
2300  0E01     MOVLW 0x1
2302  6FBD     MOVWF 0xBD, BANKED
2304  EC5D     CALL 0x6ABA, 0
2306  F035     NOP
294:           					BUZZER_ON;
2308  ECE7     CALL 0x6BCE, 0
230A  F035     NOP
295:           					appData.sw1 = false;
230C  0E00     MOVLW 0x0
230E  0101     MOVLB 0x1
2310  6FD9     MOVWF 0xD9, BANKED
296:           					WaitMs(100);
2312  0E00     MOVLW 0x0
2314  6E1B     MOVWF c, ACCESS
2316  0E64     MOVLW 0x64
2318  6E1A     MOVWF s, ACCESS
231A  EC27     CALL 0x6A4E, 0
231C  F035     NOP
297:           					BUZZER_OFF;
231E  ECE5     CALL 0x6BCA, 0
2320  F035     NOP
298:           
299:           					clear_MC_port();
2322  EC63     CALL 0x66C6, 0
2324  F033     NOP
300:           					sprintf(mc_response, rs_text->line_m, offset); // send data to controller
2326  0E28     MOVLW 0x28
2328  0100     MOVLB 0x0
232A  6FB4     MOVWF s, BANKED
232C  0E01     MOVLW 0x1
232E  6FB5     MOVWF 0xB5, BANKED
2330  C193     MOVFF rs_text, TBLPTR
2332  FFF6     NOP
2334  C194     MOVFF 0x194, TBLPTRH
2336  FFF7     NOP
2338  0009     TBLRD*+
233A  CFF5     MOVFF TABLAT, fmt
233C  F0B6     NOP
233E  000A     TBLRD*-
2340  CFF5     MOVFF TABLAT, 0xB7
2342  F0B7     NOP
2344  C0CA     MOVFF offset, ret
2346  F0B8     NOP
2348  C0CB     MOVFF 0xCB, 0xB9
234A  F0B9     NOP
234C  EC27     CALL 0x5E4E, 0
234E  F02F     NOP
301:           					MC_SendCommand(mc_response, true);
2350  0E28     MOVLW 0x28
2352  6E1C     MOVWF c, ACCESS
2354  0E01     MOVLW 0x1
2356  6E1D     MOVWF divisor, ACCESS
2358  0E01     MOVLW 0x1
235A  6E1E     MOVWF l, ACCESS
235C  ECBB     CALL 0x5D76, 0
235E  F02E     NOP
302:           					MC_SendCommand(cr_text->msg0, true);
2360  0E34     MOVLW 0x34
2362  0100     MOVLB 0x0
2364  25D1     ADDWF cr_text, W, BANKED
2366  6FC6     MOVWF 0xC6, BANKED
2368  0E00     MOVLW 0x0
236A  21D2     ADDWFC 0xD2, W, BANKED
236C  6FC7     MOVWF 0xC7, BANKED
236E  C0C6     MOVFF 0xC6, TBLPTR
2370  FFF6     NOP
2372  C0C7     MOVFF 0xC7, TBLPTRH
2374  FFF7     NOP
2376  0009     TBLRD*+
2378  CFF5     MOVFF TABLAT, c
237A  F01C     NOP
237C  000A     TBLRD*-
237E  CFF5     MOVFF TABLAT, divisor
2380  F01D     NOP
2382  0E01     MOVLW 0x1
2384  6E1E     MOVWF l, ACCESS
2386  ECBB     CALL 0x5D76, 0
2388  F02E     NOP
303:           					MC_SendCommand(cr_text->mnumber0, true);
238A  0E36     MOVLW 0x36
238C  0100     MOVLB 0x0
238E  25D1     ADDWF cr_text, W, BANKED
2390  6FC6     MOVWF 0xC6, BANKED
2392  0E00     MOVLW 0x0
2394  21D2     ADDWFC 0xD2, W, BANKED
2396  6FC7     MOVWF 0xC7, BANKED
2398  C0C6     MOVFF 0xC6, TBLPTR
239A  FFF6     NOP
239C  C0C7     MOVFF 0xC7, TBLPTRH
239E  FFF7     NOP
23A0  0009     TBLRD*+
23A2  CFF5     MOVFF TABLAT, c
23A4  F01C     NOP
23A6  000A     TBLRD*-
23A8  CFF5     MOVFF TABLAT, divisor
23AA  F01D     NOP
23AC  0E01     MOVLW 0x1
23AE  6E1E     MOVWF l, ACCESS
23B0  ECBB     CALL 0x5D76, 0
23B2  F02E     NOP
304:           					MC_SendCommand(cr_text->save_parm, true); // save updated offset angle to controller
23B4  0E38     MOVLW 0x38
23B6  0100     MOVLB 0x0
23B8  25D1     ADDWF cr_text, W, BANKED
23BA  6FC6     MOVWF 0xC6, BANKED
23BC  0E00     MOVLW 0x0
23BE  21D2     ADDWFC 0xD2, W, BANKED
23C0  6FC7     MOVWF 0xC7, BANKED
23C2  C0C6     MOVFF 0xC6, TBLPTR
23C4  FFF6     NOP
23C6  C0C7     MOVFF 0xC7, TBLPTRH
23C8  FFF7     NOP
23CA  0009     TBLRD*+
23CC  CFF5     MOVFF TABLAT, c
23CE  F01C     NOP
23D0  000A     TBLRD*-
23D2  CFF5     MOVFF TABLAT, divisor
23D4  F01D     NOP
23D6  0E01     MOVLW 0x1
23D8  6E1E     MOVWF l, ACCESS
23DA  ECBB     CALL 0x5D76, 0
23DC  F02E     NOP
305:           					BUZZER_ON;
23DE  ECE7     CALL 0x6BCE, 0
23E0  F035     NOP
306:           					WaitMs(100);
23E2  0E00     MOVLW 0x0
23E4  6E1B     MOVWF c, ACCESS
23E6  0E64     MOVLW 0x64
23E8  6E1A     MOVWF s, ACCESS
23EA  EC27     CALL 0x6A4E, 0
23EC  F035     NOP
307:           					BUZZER_OFF;
23EE  ECE5     CALL 0x6BCA, 0
23F0  F035     NOP
308:           
309:           					appData.state = APP_DONE;
23F2  0E05     MOVLW 0x5
23F4  0101     MOVLB 0x1
23F6  6F95     MOVWF 0x95, BANKED
310:           					appData.mc = MC_DONE;
23F8  0E08     MOVLW 0x8
23FA  6F96     MOVWF 0x96, BANKED
311:           					break;
23FC  D050     BRA 0x249E
312:           				case MC_DONE:
313:           					sprintf(mc_response, rs_text->line_s, cr_text->done);
23FE  0E28     MOVLW 0x28
2400  0100     MOVLB 0x0
2402  6FB4     MOVWF s, BANKED
2404  0E01     MOVLW 0x1
2406  6FB5     MOVWF 0xB5, BANKED
2408  0E04     MOVLW 0x4
240A  0101     MOVLB 0x1
240C  2593     ADDWF done, W, BANKED
240E  0100     MOVLB 0x0
2410  6FC6     MOVWF 0xC6, BANKED
2412  0E00     MOVLW 0x0
2414  0101     MOVLB 0x1
2416  2194     ADDWFC 0x94, W, BANKED
2418  0100     MOVLB 0x0
241A  6FC7     MOVWF 0xC7, BANKED
241C  C0C6     MOVFF 0xC6, TBLPTR
241E  FFF6     NOP
2420  C0C7     MOVFF 0xC7, TBLPTRH
2422  FFF7     NOP
2424  0009     TBLRD*+
2426  CFF5     MOVFF TABLAT, fmt
2428  F0B6     NOP
242A  000A     TBLRD*-
242C  CFF5     MOVFF TABLAT, 0xB7
242E  F0B7     NOP
2430  0E3C     MOVLW 0x3C
2432  25D1     ADDWF cr_text, W, BANKED
2434  6FC8     MOVWF 0xC8, BANKED
2436  0E00     MOVLW 0x0
2438  21D2     ADDWFC 0xD2, W, BANKED
243A  6FC9     MOVWF 0xC9, BANKED
243C  C0C8     MOVFF 0xC8, TBLPTR
243E  FFF6     NOP
2440  C0C9     MOVFF 0xC9, TBLPTRH
2442  FFF7     NOP
2444  0009     TBLRD*+
2446  CFF5     MOVFF TABLAT, ret
2448  F0B8     NOP
244A  000A     TBLRD*-
244C  CFF5     MOVFF TABLAT, 0xB9
244E  F0B9     NOP
2450  EC27     CALL 0x5E4E, 0
2452  F02F     NOP
314:           					display_ea_line(mc_response);
2454  0E28     MOVLW 0x28
2456  0100     MOVLB 0x0
2458  6FBC     MOVWF ret, BANKED
245A  0E01     MOVLW 0x1
245C  6FBD     MOVWF 0xBD, BANKED
245E  EC5D     CALL 0x6ABA, 0
2460  F035     NOP
315:           					break;
316:           				default:
317:           					break;
318:           				}
2462  D01D     BRA 0x249E
2464  0101     MOVLB 0x1
2466  5196     MOVF 0x96, W, BANKED
2468  0100     MOVLB 0x0
246A  6FC6     MOVWF 0xC6, BANKED
246C  6BC7     CLRF 0xC7, BANKED
246E  51C7     MOVF 0xC7, W, BANKED
2470  0A00     XORLW 0x0
2472  A4D8     BTFSS STATUS, 2, ACCESS
2474  D014     BRA 0x249E
2476  51C6     MOVF 0xC6, W, BANKED
2478  0A00     XORLW 0x0
247A  B4D8     BTFSC STATUS, 2, ACCESS
247C  EF2D     GOTO 0x165A
247E  F00B     NOP
2480  0A02     XORLW 0x2
2482  B4D8     BTFSC STATUS, 2, ACCESS
2484  EF5D     GOTO 0x16BA
2486  F00B     NOP
2488  0A01     XORLW 0x1
248A  B4D8     BTFSC STATUS, 2, ACCESS
248C  EF76     GOTO 0x16EC
248E  F00B     NOP
2490  0A06     XORLW 0x6
2492  B4D8     BTFSC STATUS, 2, ACCESS
2494  EF8F     GOTO 0x171E
2496  F00B     NOP
2498  0A0D     XORLW 0xD
249A  B4D8     BTFSC STATUS, 2, ACCESS
249C  D7B0     BRA 0x23FE
319:           				appData.got_packet = false;
249E  0E00     MOVLW 0x0
24A0  0101     MOVLB 0x1
24A2  6FD7     MOVWF 0xD7, BANKED
320:           			} else {
24A4  D07E     BRA 0x25A2
321:           				if (appData.sw1) {
24A6  51D9     MOVF 0xD9, W, BANKED
24A8  B4D8     BTFSC STATUS, 2, ACCESS
24AA  D00B     BRA 0x24C2
322:           					BUZZER_ON;
24AC  ECE7     CALL 0x6BCE, 0
24AE  F035     NOP
323:           					appData.sw1 = false;
24B0  0E00     MOVLW 0x0
24B2  0101     MOVLB 0x1
24B4  6FD9     MOVWF 0xD9, BANKED
324:           					WaitMs(100);
24B6  0E00     MOVLW 0x0
24B8  6E1B     MOVWF c, ACCESS
24BA  0E64     MOVLW 0x64
24BC  6E1A     MOVWF s, ACCESS
24BE  EC27     CALL 0x6A4E, 0
24C0  F035     NOP
325:           				}
326:           				sprintf(mc_response, cr_text->line_h, cr_text->headder, APP_VERSION_STR);
24C2  0E28     MOVLW 0x28
24C4  0100     MOVLB 0x0
24C6  6FB4     MOVWF s, BANKED
24C8  0E01     MOVLW 0x1
24CA  6FB5     MOVWF 0xB5, BANKED
24CC  0E48     MOVLW 0x48
24CE  25D1     ADDWF cr_text, W, BANKED
24D0  6FC6     MOVWF 0xC6, BANKED
24D2  0E00     MOVLW 0x0
24D4  21D2     ADDWFC 0xD2, W, BANKED
24D6  6FC7     MOVWF 0xC7, BANKED
24D8  C0C6     MOVFF 0xC6, TBLPTR
24DA  FFF6     NOP
24DC  C0C7     MOVFF 0xC7, TBLPTRH
24DE  FFF7     NOP
24E0  0009     TBLRD*+
24E2  CFF5     MOVFF TABLAT, fmt
24E4  F0B6     NOP
24E6  000A     TBLRD*-
24E8  CFF5     MOVFF TABLAT, 0xB7
24EA  F0B7     NOP
24EC  C0D1     MOVFF cr_text, TBLPTR
24EE  FFF6     NOP
24F0  C0D2     MOVFF 0xD2, TBLPTRH
24F2  FFF7     NOP
24F4  0009     TBLRD*+
24F6  CFF5     MOVFF TABLAT, ret
24F8  F0B8     NOP
24FA  000A     TBLRD*-
24FC  CFF5     MOVFF TABLAT, 0xB9
24FE  F0B9     NOP
2500  0EE3     MOVLW 0xE3
2502  6FBA     MOVWF ap, BANKED
2504  0E7F     MOVLW 0x7F
2506  6FBB     MOVWF 0xBB, BANKED
2508  EC27     CALL 0x5E4E, 0
250A  F02F     NOP
327:           				display_ea_line(mc_response);
250C  0E28     MOVLW 0x28
250E  0100     MOVLB 0x0
2510  6FBC     MOVWF ret, BANKED
2512  0E01     MOVLW 0x1
2514  6FBD     MOVWF 0xBD, BANKED
2516  EC5D     CALL 0x6ABA, 0
2518  F035     NOP
328:           				sprintf(mc_response, cr_text->line2, __DATE__);
251A  0E28     MOVLW 0x28
251C  0100     MOVLB 0x0
251E  6FB4     MOVWF s, BANKED
2520  0E01     MOVLW 0x1
2522  6FB5     MOVWF 0xB5, BANKED
2524  0E40     MOVLW 0x40
2526  25D1     ADDWF cr_text, W, BANKED
2528  6FC6     MOVWF 0xC6, BANKED
252A  0E00     MOVLW 0x0
252C  21D2     ADDWFC 0xD2, W, BANKED
252E  6FC7     MOVWF 0xC7, BANKED
2530  C0C6     MOVFF 0xC6, TBLPTR
2532  FFF6     NOP
2534  C0C7     MOVFF 0xC7, TBLPTRH
2536  FFF7     NOP
2538  0009     TBLRD*+
253A  CFF5     MOVFF TABLAT, fmt
253C  F0B6     NOP
253E  000A     TBLRD*-
2540  CFF5     MOVFF TABLAT, 0xB7
2542  F0B7     NOP
2544  0EFB     MOVLW 0xFB
2546  6FB8     MOVWF ret, BANKED
2548  0E7E     MOVLW 0x7E
254A  6FB9     MOVWF 0xB9, BANKED
254C  EC27     CALL 0x5E4E, 0
254E  F02F     NOP
329:           				display_ea_line(mc_response);
2550  0E28     MOVLW 0x28
2552  0100     MOVLB 0x0
2554  6FBC     MOVWF ret, BANKED
2556  0E01     MOVLW 0x1
2558  6FBD     MOVWF 0xBD, BANKED
255A  EC5D     CALL 0x6ABA, 0
255C  F035     NOP
330:           				sprintf(mc_response, cr_text->line3, __TIME__);
255E  0E28     MOVLW 0x28
2560  0100     MOVLB 0x0
2562  6FB4     MOVWF s, BANKED
2564  0E01     MOVLW 0x1
2566  6FB5     MOVWF 0xB5, BANKED
2568  0E42     MOVLW 0x42
256A  25D1     ADDWF cr_text, W, BANKED
256C  6FC6     MOVWF 0xC6, BANKED
256E  0E00     MOVLW 0x0
2570  21D2     ADDWFC 0xD2, W, BANKED
2572  6FC7     MOVWF 0xC7, BANKED
2574  C0C6     MOVFF 0xC6, TBLPTR
2576  FFF6     NOP
2578  C0C7     MOVFF 0xC7, TBLPTRH
257A  FFF7     NOP
257C  0009     TBLRD*+
257E  CFF5     MOVFF TABLAT, fmt
2580  F0B6     NOP
2582  000A     TBLRD*-
2584  CFF5     MOVFF TABLAT, 0xB7
2586  F0B7     NOP
2588  0E60     MOVLW 0x60
258A  6FB8     MOVWF ret, BANKED
258C  0E7F     MOVLW 0x7F
258E  6FB9     MOVWF 0xB9, BANKED
2590  EC27     CALL 0x5E4E, 0
2592  F02F     NOP
331:           				display_ea_line(mc_response);
2594  0E28     MOVLW 0x28
2596  0100     MOVLB 0x0
2598  6FBC     MOVWF ret, BANKED
259A  0E01     MOVLW 0x1
259C  6FBD     MOVWF 0xBD, BANKED
259E  EC5D     CALL 0x6ABA, 0
25A0  F035     NOP
332:           			}
333:           			StartTimer(TMR_DIS, DIS_REFRESH_MS);
25A2  0E00     MOVLW 0x0
25A4  6E16     MOVWF Message, ACCESS
25A6  0E46     MOVLW 0x46
25A8  6E15     MOVWF dividend, ACCESS
25AA  0E03     MOVLW 0x3
25AC  EC1B     CALL 0x6836, 0
25AE  F034     NOP
334:           		}
335:           		break;
25B0  D04A     BRA 0x2646
336:           	case APP_DONE:
337:           		while (true) {
338:           			sprintf(mc_response, rs_text->line_m, offset);
25B2  0E28     MOVLW 0x28
25B4  0100     MOVLB 0x0
25B6  6FB4     MOVWF s, BANKED
25B8  0E01     MOVLW 0x1
25BA  6FB5     MOVWF 0xB5, BANKED
25BC  C193     MOVFF rs_text, TBLPTR
25BE  FFF6     NOP
25C0  C194     MOVFF 0x194, TBLPTRH
25C2  FFF7     NOP
25C4  0009     TBLRD*+
25C6  CFF5     MOVFF TABLAT, fmt
25C8  F0B6     NOP
25CA  000A     TBLRD*-
25CC  CFF5     MOVFF TABLAT, 0xB7
25CE  F0B7     NOP
25D0  C0CA     MOVFF offset, ret
25D2  F0B8     NOP
25D4  C0CB     MOVFF 0xCB, 0xB9
25D6  F0B9     NOP
25D8  EC27     CALL 0x5E4E, 0
25DA  F02F     NOP
339:           			display_ea_line(mc_response);
25DC  0E28     MOVLW 0x28
25DE  0100     MOVLB 0x0
25E0  6FBC     MOVWF ret, BANKED
25E2  0E01     MOVLW 0x1
25E4  6FBD     MOVWF 0xBD, BANKED
25E6  EC5D     CALL 0x6ABA, 0
25E8  F035     NOP
340:           			WaitMs(100);
25EA  0E00     MOVLW 0x0
25EC  6E1B     MOVWF c, ACCESS
25EE  0E64     MOVLW 0x64
25F0  6E1A     MOVWF s, ACCESS
25F2  EC27     CALL 0x6A4E, 0
25F4  F035     NOP
341:           			BUZZER_OFF;
25F6  ECE5     CALL 0x6BCA, 0
25F8  F035     NOP
342:           			WaitMs(1333);
25FA  0E05     MOVLW 0x5
25FC  6E1B     MOVWF c, ACCESS
25FE  0E35     MOVLW 0x35
2600  6E1A     MOVWF s, ACCESS
2602  EC27     CALL 0x6A4E, 0
2604  F035     NOP
343:           			BUZZER_ON;
2606  ECE7     CALL 0x6BCE, 0
2608  F035     NOP
344:           		};
260A  D7D3     BRA 0x25B2
345:           		break;
346:           	default:
347:           		break;
348:           	} //end switch(appData.state)
260C  0101     MOVLB 0x1
260E  5195     MOVF 0x95, W, BANKED
2610  0100     MOVLB 0x0
2612  6FC6     MOVWF 0xC6, BANKED
2614  6BC7     CLRF 0xC7, BANKED
2616  51C7     MOVF 0xC7, W, BANKED
2618  0A00     XORLW 0x0
261A  A4D8     BTFSS STATUS, 2, ACCESS
261C  D014     BRA 0x2646
261E  51C6     MOVF 0xC6, W, BANKED
2620  0A00     XORLW 0x0
2622  B4D8     BTFSC STATUS, 2, ACCESS
2624  EFFF     GOTO 0x13FE
2626  F009     NOP
2628  0A01     XORLW 0x1
262A  B4D8     BTFSC STATUS, 2, ACCESS
262C  EF33     GOTO 0x1466
262E  F00A     NOP
2630  0A03     XORLW 0x3
2632  B4D8     BTFSC STATUS, 2, ACCESS
2634  EF3A     GOTO 0x1474
2636  F00A     NOP
2638  0A01     XORLW 0x1
263A  B4D8     BTFSC STATUS, 2, ACCESS
263C  EFBD     GOTO 0x157A
263E  F00A     NOP
2640  0A06     XORLW 0x6
2642  B4D8     BTFSC STATUS, 2, ACCESS
2644  D7B6     BRA 0x25B2
349:           
350:           	// start programming sequence without MC 'booting'
351:           	if (appData.sw2) {
2646  0101     MOVLB 0x1
2648  51DA     MOVF 0xDA, W, BANKED
264A  B4D8     BTFSC STATUS, 2, ACCESS
264C  D02D     BRA 0x26A8
352:           		BUZZER_ON;
264E  ECE7     CALL 0x6BCE, 0
2650  F035     NOP
353:           		appData.sw2 = false;
2652  0E00     MOVLW 0x0
2654  0101     MOVLB 0x1
2656  6FDA     MOVWF 0xDA, BANKED
354:           		appData.mc = MC_BOOT;
2658  0E02     MOVLW 0x2
265A  6F96     MOVWF 0x96, BANKED
355:           		appData.got_packet = true;
265C  0E01     MOVLW 0x1
265E  6FD7     MOVWF 0xD7, BANKED
356:           		display_ea_ff(1);
2660  0E00     MOVLW 0x0
2662  0100     MOVLB 0x0
2664  6FBD     MOVWF 0xBD, BANKED
2666  0E01     MOVLW 0x1
2668  6FBC     MOVWF ret, BANKED
266A  EC8E     CALL 0x691C, 0
266C  F034     NOP
357:           		sprintf(appData.receive_packet, cr_text->bootb);
266E  0E97     MOVLW 0x97
2670  0100     MOVLB 0x0
2672  6FB4     MOVWF s, BANKED
2674  0E01     MOVLW 0x1
2676  6FB5     MOVWF 0xB5, BANKED
2678  0E02     MOVLW 0x2
267A  25D1     ADDWF cr_text, W, BANKED
267C  6FC6     MOVWF 0xC6, BANKED
267E  0E00     MOVLW 0x0
2680  21D2     ADDWFC 0xD2, W, BANKED
2682  6FC7     MOVWF 0xC7, BANKED
2684  C0C6     MOVFF 0xC6, TBLPTR
2686  FFF6     NOP
2688  C0C7     MOVFF 0xC7, TBLPTRH
268A  FFF7     NOP
268C  0009     TBLRD*+
268E  CFF5     MOVFF TABLAT, fmt
2690  F0B6     NOP
2692  000A     TBLRD*-
2694  CFF5     MOVFF TABLAT, 0xB7
2696  F0B7     NOP
2698  EC27     CALL 0x5E4E, 0
269A  F02F     NOP
358:           		WaitMs(25);
269C  0E00     MOVLW 0x0
269E  6E1B     MOVWF c, ACCESS
26A0  0E19     MOVLW 0x19
26A2  6E1A     MOVWF s, ACCESS
26A4  EC27     CALL 0x6A4E, 0
26A6  F035     NOP
359:           	}
360:           	BUZZER_OFF;
26A8  ECE5     CALL 0x6BCA, 0
26AA  F035     NOP
361:           } //end APP_Tasks()
26AC  0012     RETURN 0
362:           
363:           // collect and buffer controller data
364:           
365:           bool MC_ReceivePacket(char * Message)
366:           {
367:           	static enum McDecodeState btDecodeState = WaitForCR; //Static so maintains state on reentry, Byte read(s) from the UART buffer
368:           	static uint16_t i = 0;
369:           
370:           	if (EUSART1_is_rx_ready()) //Check if new data byte 
54B0  ECE9     CALL 0x6BD2, 0
54B2  F035     NOP
54B4  0900     IORLW 0x0
54B6  B4D8     BTFSC STATUS, 2, ACCESS
54B8  D078     BRA 0x55AA
371:           	{
372:           
373:           		Message[i++] = EUSART1_Read();
54BA  ECD0     CALL 0x65A0, 0
54BC  F032     NOP
54BE  6E18     MOVWF 0x18, ACCESS
54C0  503D     MOVF i, W, ACCESS
54C2  2416     ADDWF Message, W, ACCESS
54C4  6ED9     MOVWF FSR2, ACCESS
54C6  503E     MOVF 0x3E, W, ACCESS
54C8  2017     ADDWFC _r, W, ACCESS
54CA  6EDA     MOVWF FSR2H, ACCESS
54CC  C018     MOVFF 0x18, INDF2
54CE  FFDF     NOP
54D0  4A3D     INFSNZ i, F, ACCESS
54D2  2A3E     INCF 0x3E, F, ACCESS
374:           		if (i == MC_RX_PKT_SZ) {
54D4  0E40     MOVLW 0x40
54D6  183D     XORWF i, W, ACCESS
54D8  103E     IORWF 0x3E, W, ACCESS
54DA  A4D8     BTFSS STATUS, 2, ACCESS
54DC  D056     BRA 0x558A
375:           			i = 0;
54DE  0E00     MOVLW 0x0
54E0  6E3E     MOVWF 0x3E, ACCESS
54E2  0E00     MOVLW 0x0
54E4  6E3D     MOVWF i, ACCESS
376:           		}
377:           
378:           
379:           		switch (btDecodeState) {
54E6  D051     BRA 0x558A
380:           		case WaitForCR:
381:           			if (Message[i - 1] == '\r') { //See if this is the 'ENTER' key
54E8  0EFF     MOVLW 0xFF
54EA  6E18     MOVWF 0x18, ACCESS
54EC  0EFF     MOVLW 0xFF
54EE  6E19     MOVWF multiplicand, ACCESS
54F0  C03D     MOVFF i, s
54F2  F01A     NOP
54F4  C03E     MOVFF 0x3E, c
54F6  F01B     NOP
54F8  5018     MOVF 0x18, W, ACCESS
54FA  261A     ADDWF s, F, ACCESS
54FC  5019     MOVF multiplicand, W, ACCESS
54FE  221B     ADDWFC c, F, ACCESS
5500  501A     MOVF s, W, ACCESS
5502  2416     ADDWF Message, W, ACCESS
5504  6ED9     MOVWF FSR2, ACCESS
5506  501B     MOVF c, W, ACCESS
5508  2017     ADDWFC _r, W, ACCESS
550A  6EDA     MOVWF FSR2H, ACCESS
550C  0E0D     MOVLW 0xD
550E  18DE     XORWF POSTINC2, W, ACCESS
5510  A4D8     BTFSS STATUS, 2, ACCESS
5512  D04B     BRA 0x55AA
382:           				btDecodeState = WaitForLF; //Is CR so wait for LF
5514  0E01     MOVLW 0x1
5516  0101     MOVLB 0x1
5518  D036     BRA 0x5586
383:           			}
384:           			break;
385:           
386:           		case WaitForLF:
387:           			btDecodeState = WaitForCR; //Will be looking for a new packet next
551A  0E00     MOVLW 0x0
551C  6F26     MOVWF sign, BANKED
388:           			if (Message[i - 1] == '\n') //See if this is the LF 'CTRL-J' key
551E  0EFF     MOVLW 0xFF
5520  6E18     MOVWF 0x18, ACCESS
5522  0EFF     MOVLW 0xFF
5524  6E19     MOVWF multiplicand, ACCESS
5526  C03D     MOVFF i, s
5528  F01A     NOP
552A  C03E     MOVFF 0x3E, c
552C  F01B     NOP
552E  5018     MOVF 0x18, W, ACCESS
5530  261A     ADDWF s, F, ACCESS
5532  5019     MOVF multiplicand, W, ACCESS
5534  221B     ADDWFC c, F, ACCESS
5536  501A     MOVF s, W, ACCESS
5538  2416     ADDWF Message, W, ACCESS
553A  6ED9     MOVWF FSR2, ACCESS
553C  501B     MOVF c, W, ACCESS
553E  2017     ADDWFC _r, W, ACCESS
5540  6EDA     MOVWF FSR2H, ACCESS
5542  0E0A     MOVLW 0xA
5544  18DE     XORWF POSTINC2, W, ACCESS
5546  A4D8     BTFSS STATUS, 2, ACCESS
5548  D030     BRA 0x55AA
389:           			{
390:           				Message[i] = 0; //Got a complete message!
554A  503D     MOVF i, W, ACCESS
554C  2416     ADDWF Message, W, ACCESS
554E  6ED9     MOVWF FSR2, ACCESS
5550  503E     MOVF 0x3E, W, ACCESS
5552  2017     ADDWFC _r, W, ACCESS
5554  6EDA     MOVWF FSR2H, ACCESS
5556  0E00     MOVLW 0x0
5558  6EDF     MOVWF INDF2, ACCESS
391:           				i = 0;
555A  0E00     MOVLW 0x0
555C  6E3E     MOVWF 0x3E, ACCESS
555E  0E00     MOVLW 0x0
5560  6E3D     MOVWF i, ACCESS
392:           				IO_RA3_Toggle();
5562  A689     BTFSS LATA, 3, ACCESS
5564  D002     BRA 0x556A
5566  0E01     MOVLW 0x1
5568  D001     BRA 0x556C
556A  0E00     MOVLW 0x0
556C  0AFF     XORLW 0xFF
556E  6E18     MOVWF 0x18, ACCESS
5570  4618     RLNCF 0x18, F, ACCESS
5572  4618     RLNCF 0x18, F, ACCESS
5574  4618     RLNCF 0x18, F, ACCESS
5576  5089     MOVF LATA, W, ACCESS
5578  1818     XORWF 0x18, W, ACCESS
557A  0BF7     ANDLW 0xF7
557C  1818     XORWF 0x18, W, ACCESS
557E  6E89     MOVWF LATA, ACCESS
393:           				return true;
5580  0E01     MOVLW 0x1
5582  0012     RETURN 0
394:           			}
395:           			break;
396:           
397:           		default: //Invalid state so start looking for a new start of frame
398:           			btDecodeState = WaitForCR;
5584  0E00     MOVLW 0x0
5586  6F26     MOVWF sign, BANKED
399:           		}
5588  D010     BRA 0x55AA
558A  0101     MOVLB 0x1
558C  5126     MOVF sign, W, BANKED
558E  6E18     MOVWF 0x18, ACCESS
5590  6A19     CLRF multiplicand, ACCESS
5592  5019     MOVF multiplicand, W, ACCESS
5594  0A00     XORLW 0x0
5596  A4D8     BTFSS STATUS, 2, ACCESS
5598  D7F5     BRA 0x5584
559A  5018     MOVF 0x18, W, ACCESS
559C  0A00     XORLW 0x0
559E  B4D8     BTFSC STATUS, 2, ACCESS
55A0  D7A3     BRA 0x54E8
55A2  0A01     XORLW 0x1
55A4  B4D8     BTFSC STATUS, 2, ACCESS
55A6  D7B9     BRA 0x551A
55A8  D7ED     BRA 0x5584
400:           	}
401:           	return false;
55AA  0E00     MOVLW 0x0
55AC  0012     RETURN 0
402:           }
403:           
404:           bool MC_SendCommand(const char *data, bool wait)
405:           {
406:           	uint16_t i;
407:           
408:           	for (i = 0; i < SIZE_TxBuffer; i++) {
5D76  0E00     MOVLW 0x0
5D78  6E20     MOVWF r, ACCESS
5D7A  0E00     MOVLW 0x0
5D7C  6E1F     MOVWF i, ACCESS
5D7E  5020     MOVF r, W, ACCESS
5D80  E12E     BNZ 0x5DDE
5D82  0E40     MOVLW 0x40
5D84  5C1F     SUBWF i, W, ACCESS
5D86  B0D8     BTFSC STATUS, 0, ACCESS
5D88  D02A     BRA 0x5DDE
409:           		if (*data != '\0') //Keep loading bytes until end of string
5D8A  C01C     MOVFF c, TBLPTR
5D8C  FFF6     NOP
5D8E  C01D     MOVFF divisor, TBLPTRH
5D90  FFF7     NOP
5D92  6AF8     CLRF TBLPTRU, ACCESS
5D94  0E0E     MOVLW 0xE
5D96  64F7     CPFSGT TBLPTRH, ACCESS
5D98  D003     BRA 0x5DA0
5D9A  0008     TBLRD*
5D9C  50F5     MOVF TABLAT, W, ACCESS
5D9E  D005     BRA 0x5DAA
5DA0  CFF6     MOVFF TBLPTR, FSR0
5DA2  FFE9     NOP
5DA4  CFF7     MOVFF TBLPTRH, FSR0H
5DA6  FFEA     NOP
5DA8  50EF     MOVF INDF0, W, ACCESS
5DAA  0900     IORLW 0x0
5DAC  B4D8     BTFSC STATUS, 2, ACCESS
5DAE  D017     BRA 0x5DDE
410:           			EUSART1_Write(*data++); //Load byte into the transmit buffer
5DB0  C01C     MOVFF c, TBLPTR
5DB2  FFF6     NOP
5DB4  C01D     MOVFF divisor, TBLPTRH
5DB6  FFF7     NOP
5DB8  6AF8     CLRF TBLPTRU, ACCESS
5DBA  0E0E     MOVLW 0xE
5DBC  64F7     CPFSGT TBLPTRH, ACCESS
5DBE  D003     BRA 0x5DC6
5DC0  0008     TBLRD*
5DC2  50F5     MOVF TABLAT, W, ACCESS
5DC4  D005     BRA 0x5DD0
5DC6  CFF6     MOVFF TBLPTR, FSR0
5DC8  FFE9     NOP
5DCA  CFF7     MOVFF TBLPTRH, FSR0H
5DCC  FFEA     NOP
5DCE  50EF     MOVF INDF0, W, ACCESS
5DD0  ECB7     CALL 0x636E, 0
5DD2  F031     NOP
5DD4  4A1C     INFSNZ c, F, ACCESS
5DD6  2A1D     INCF divisor, F, ACCESS
411:           		else
412:           			break;
413:           	}
5DD8  4A1F     INFSNZ i, F, ACCESS
5DDA  2A20     INCF r, F, ACCESS
5DDC  D7D0     BRA 0x5D7E
414:           
415:           	if (wait) {
5DDE  501E     MOVF l, W, ACCESS
5DE0  B4D8     BTFSC STATUS, 2, ACCESS
5DE2  0012     RETURN 0
416:           		WaitMs(200);
5DE4  0E00     MOVLW 0x0
5DE6  6E1B     MOVWF c, ACCESS
5DE8  0EC8     MOVLW 0xC8
5DEA  6E1A     MOVWF s, ACCESS
5DEC  EC27     CALL 0x6A4E, 0
5DEE  F035     NOP
417:           	}
5DF0  0012     RETURN 0
418:           	return true;
419:           }
420:           
